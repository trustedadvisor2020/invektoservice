diff --git a/InvektoServis.sln b/InvektoServis.sln
index 9c98ea7..10d1026 100644
--- a/InvektoServis.sln
+++ b/InvektoServis.sln
@@ -21,6 +21,8 @@ Project("{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}") = "Invekto.Automation", "src\I
 EndProject
 Project("{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}") = "Invekto.AgentAI", "src\Invekto.AgentAI\Invekto.AgentAI.csproj", "{B3A1D2E4-5F67-4890-AB12-CD34EF56A789}"
 EndProject
+Project("{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}") = "Invekto.Outbound", "src\Invekto.Outbound\Invekto.Outbound.csproj", "{20F24E9A-831F-46B9-A006-B606A5404E41}"
+EndProject
 Global
 	GlobalSection(SolutionConfigurationPlatforms) = preSolution
 		Debug|Any CPU = Debug|Any CPU
@@ -58,6 +60,10 @@ Global
 		{B3A1D2E4-5F67-4890-AB12-CD34EF56A789}.Debug|Any CPU.Build.0 = Debug|Any CPU
 		{B3A1D2E4-5F67-4890-AB12-CD34EF56A789}.Release|Any CPU.ActiveCfg = Release|Any CPU
 		{B3A1D2E4-5F67-4890-AB12-CD34EF56A789}.Release|Any CPU.Build.0 = Release|Any CPU
+		{20F24E9A-831F-46B9-A006-B606A5404E41}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
+		{20F24E9A-831F-46B9-A006-B606A5404E41}.Debug|Any CPU.Build.0 = Debug|Any CPU
+		{20F24E9A-831F-46B9-A006-B606A5404E41}.Release|Any CPU.ActiveCfg = Release|Any CPU
+		{20F24E9A-831F-46B9-A006-B606A5404E41}.Release|Any CPU.Build.0 = Release|Any CPU
 	EndGlobalSection
 	GlobalSection(NestedProjects) = preSolution
 		{15F8FD75-7433-4D26-A091-8B804B50C75C} = {2D97BB8D-A179-4B02-AABE-097A26C8ECFD}
@@ -67,5 +73,6 @@ Global
 		{0EDF88EB-3AA1-4437-A4EF-40AF8F8ABB20} = {4858822B-FBD3-429F-9855-560EA526C9B1}
 		{940E6C4F-877B-4CA4-A4F4-2BE9F6FBA5B0} = {2D97BB8D-A179-4B02-AABE-097A26C8ECFD}
 		{B3A1D2E4-5F67-4890-AB12-CD34EF56A789} = {2D97BB8D-A179-4B02-AABE-097A26C8ECFD}
+		{20F24E9A-831F-46B9-A006-B606A5404E41} = {2D97BB8D-A179-4B02-AABE-097A26C8ECFD}
 	EndGlobalSection
 EndGlobal
diff --git a/arch/active-work.md b/arch/active-work.md
index 0a881cf..3e28a1a 100644
--- a/arch/active-work.md
+++ b/arch/active-work.md
@@ -6,7 +6,7 @@
 
 | Slug | Status | Started | Description |
 |------|--------|---------|-------------|
-| (none) | - | - | - |
+| 20260212-outbound-service | BUILD_PASS | 2026-02-12 | GR-1.3: Invekto.Outbound broadcast & trigger engine (Port 7107) - Implemented, build PASS, /rev bekliyor |
 
 ---
 
diff --git a/arch/contracts/outbound-broadcast.json b/arch/contracts/outbound-broadcast.json
new file mode 100644
index 0000000..e5d714a
--- /dev/null
+++ b/arch/contracts/outbound-broadcast.json
@@ -0,0 +1,200 @@
+{
+  "$schema": "outbound-broadcast-contract",
+  "version": "1.0",
+  "service": "Invekto.Outbound",
+  "port": 7107,
+  "description": "Outbound broadcast, trigger, template, and opt-out API contracts",
+
+  "endpoints": {
+    "broadcast_send": {
+      "method": "POST",
+      "path": "/api/v1/broadcast/send",
+      "auth": "JWT",
+      "request": {
+        "template_id": { "type": "integer", "required": true, "desc": "Template ID to use" },
+        "recipients": {
+          "type": "array",
+          "required": true,
+          "max_items": 1000,
+          "item": {
+            "phone": { "type": "string", "required": true, "desc": "E.164 format phone" },
+            "variables": { "type": "object", "required": false, "desc": "Template variables per recipient" }
+          }
+        },
+        "scheduled_at": { "type": "string", "format": "ISO8601", "required": false, "desc": "One-time scheduled send" }
+      },
+      "response_202": {
+        "broadcast_id": "uuid",
+        "total_recipients": "integer",
+        "queued": "integer",
+        "skipped_optout": "integer"
+      }
+    },
+
+    "broadcast_status": {
+      "method": "GET",
+      "path": "/api/v1/broadcast/{broadcastId}/status",
+      "auth": "JWT",
+      "response_200": {
+        "broadcast_id": "uuid",
+        "status": "queued|processing|completed|failed",
+        "total_recipients": "integer",
+        "queued": "integer",
+        "sent": "integer",
+        "delivered": "integer",
+        "read": "integer",
+        "failed": "integer",
+        "created_at": "ISO8601",
+        "started_at": "ISO8601|null",
+        "completed_at": "ISO8601|null"
+      }
+    },
+
+    "webhook_trigger": {
+      "method": "POST",
+      "path": "/api/v1/webhook/trigger",
+      "auth": "JWT",
+      "request": {
+        "event": { "type": "string", "required": true, "desc": "new_lead|payment_received|appointment_reminder" },
+        "phone": { "type": "string", "required": true, "desc": "Recipient phone" },
+        "variables": { "type": "object", "required": false, "desc": "Template variables" }
+      },
+      "response_202": {
+        "message_id": "bigint",
+        "template_id": "integer",
+        "template_name": "string"
+      },
+      "response_404": {
+        "error_code": "INV-OB-008",
+        "message": "No matching trigger template"
+      }
+    },
+
+    "webhook_delivery_status": {
+      "method": "POST",
+      "path": "/api/v1/webhook/delivery-status",
+      "auth": "JWT",
+      "request": {
+        "external_message_id": { "type": "string", "required": true },
+        "status": { "type": "string", "required": true, "desc": "sent|delivered|read|failed" },
+        "failed_reason": { "type": "string", "required": false },
+        "timestamp": { "type": "string", "format": "ISO8601", "required": false }
+      },
+      "response_200": {
+        "updated": "boolean"
+      }
+    },
+
+    "webhook_message": {
+      "method": "POST",
+      "path": "/api/v1/webhook/message",
+      "auth": "JWT",
+      "request": {
+        "phone": { "type": "string", "required": true },
+        "message_text": { "type": "string", "required": true }
+      },
+      "response_200": {
+        "opted_out": "boolean",
+        "keyword_matched": "string|null"
+      }
+    },
+
+    "templates_list": {
+      "method": "GET",
+      "path": "/api/v1/templates",
+      "auth": "JWT",
+      "response_200": {
+        "templates": [{
+          "id": "integer",
+          "name": "string",
+          "trigger_event": "string",
+          "message_template": "string",
+          "variables_json": "object|null",
+          "is_active": "boolean",
+          "created_at": "ISO8601",
+          "updated_at": "ISO8601"
+        }]
+      }
+    },
+
+    "template_create": {
+      "method": "POST",
+      "path": "/api/v1/templates",
+      "auth": "JWT",
+      "request": {
+        "name": { "type": "string", "required": true, "max_length": 200 },
+        "trigger_event": { "type": "string", "required": false, "default": "manual" },
+        "message_template": { "type": "string", "required": true },
+        "variables_json": { "type": "object", "required": false }
+      },
+      "response_201": {
+        "id": "integer",
+        "name": "string"
+      }
+    },
+
+    "template_update": {
+      "method": "PUT",
+      "path": "/api/v1/templates/{id}",
+      "auth": "JWT",
+      "request": {
+        "name": { "type": "string", "required": false },
+        "trigger_event": { "type": "string", "required": false },
+        "message_template": { "type": "string", "required": false },
+        "variables_json": { "type": "object", "required": false }
+      },
+      "response_200": {
+        "id": "integer",
+        "updated": true
+      }
+    },
+
+    "template_delete": {
+      "method": "DELETE",
+      "path": "/api/v1/templates/{id}",
+      "auth": "JWT",
+      "desc": "Soft delete: sets is_active=false",
+      "response_200": {
+        "id": "integer",
+        "deactivated": true
+      }
+    },
+
+    "optout_add": {
+      "method": "POST",
+      "path": "/api/v1/optout",
+      "auth": "JWT",
+      "request": {
+        "phone": { "type": "string", "required": true },
+        "reason": { "type": "string", "required": false }
+      },
+      "response_200": {
+        "phone": "string",
+        "opted_out": true
+      }
+    },
+
+    "optout_remove": {
+      "method": "DELETE",
+      "path": "/api/v1/optout/{phone}",
+      "auth": "JWT",
+      "response_200": {
+        "phone": "string",
+        "removed": true
+      }
+    },
+
+    "optout_check": {
+      "method": "GET",
+      "path": "/api/v1/optout/check/{phone}",
+      "auth": "JWT",
+      "response_200": {
+        "phone": "string",
+        "opted_out": "boolean",
+        "opted_out_at": "ISO8601|null"
+      }
+    }
+  },
+
+  "stop_keywords": ["STOP", "DUR", "─░PTAL", "IPTAL", "DURDU", "├çIKI┼₧", "CIKIS"]
+}
diff --git a/arch/db/outbound.sql b/arch/db/outbound.sql
new file mode 100644
index 0000000..5e83809
--- /dev/null
+++ b/arch/db/outbound.sql
@@ -0,0 +1,139 @@
+-- =============================================================
+-- Invekto.Outbound Database Schema
+-- Service: Invekto.Outbound (port 7107)
+-- Database: invekto (PostgreSQL, shared instance)
+-- Convention: snake_case for all identifiers
+-- =============================================================
+
+-- Depends on: tenant-registry.sql (tenant_registry table)
+
+-- =============================================================
+-- outbound_templates: Message templates for broadcasts & triggers
+-- =============================================================
+
+CREATE TABLE IF NOT EXISTS outbound_templates (
+    id                      SERIAL PRIMARY KEY,
+    tenant_id               INTEGER NOT NULL REFERENCES tenant_registry(tenant_id),
+    name                    VARCHAR(200) NOT NULL,
+    trigger_event           VARCHAR(50) NOT NULL DEFAULT 'manual',
+    message_template        TEXT NOT NULL,
+    variables_json          JSONB,
+    is_active               BOOLEAN NOT NULL DEFAULT TRUE,
+    created_at              TIMESTAMPTZ NOT NULL DEFAULT NOW(),
+    updated_at              TIMESTAMPTZ NOT NULL DEFAULT NOW(),
+
+    -- trigger_event values: manual, new_lead, payment_received, appointment_reminder
+    CONSTRAINT chk_trigger_event CHECK (trigger_event IN ('manual', 'new_lead', 'payment_received', 'appointment_reminder'))
+);
+
+CREATE INDEX IF NOT EXISTS idx_outbound_templates_tenant_active
+    ON outbound_templates (tenant_id, is_active) WHERE is_active = TRUE;
+
+CREATE INDEX IF NOT EXISTS idx_outbound_templates_tenant_trigger
+    ON outbound_templates (tenant_id, trigger_event) WHERE is_active = TRUE;
+
+-- =============================================================
+-- outbound_broadcasts: Broadcast job records
+-- =============================================================
+
+CREATE TABLE IF NOT EXISTS outbound_broadcasts (
+    id                      UUID PRIMARY KEY DEFAULT gen_random_uuid(),
+    tenant_id               INTEGER NOT NULL REFERENCES tenant_registry(tenant_id),
+    template_id             INTEGER REFERENCES outbound_templates(id),
+    total_recipients        INTEGER NOT NULL DEFAULT 0,
+    queued                  INTEGER NOT NULL DEFAULT 0,
+    sent                    INTEGER NOT NULL DEFAULT 0,
+    delivered               INTEGER NOT NULL DEFAULT 0,
+    read                    INTEGER NOT NULL DEFAULT 0,
+    failed                  INTEGER NOT NULL DEFAULT 0,
+    status                  VARCHAR(20) NOT NULL DEFAULT 'queued',
+    scheduled_at            TIMESTAMPTZ,
+    started_at              TIMESTAMPTZ,
+    completed_at            TIMESTAMPTZ,
+    created_at              TIMESTAMPTZ NOT NULL DEFAULT NOW(),
+
+    -- status values: queued, processing, completed, failed
+    CONSTRAINT chk_broadcast_status CHECK (status IN ('queued', 'processing', 'completed', 'failed'))
+);
+
+CREATE INDEX IF NOT EXISTS idx_outbound_broadcasts_tenant_created
+    ON outbound_broadcasts (tenant_id, created_at DESC);
+
+CREATE INDEX IF NOT EXISTS idx_outbound_broadcasts_status
+    ON outbound_broadcasts (status) WHERE status IN ('queued', 'processing');
+
+-- =============================================================
+-- outbound_messages: Individual message records in a broadcast
+-- =============================================================
+
+CREATE TABLE IF NOT EXISTS outbound_messages (
+    id                      BIGSERIAL PRIMARY KEY,
+    tenant_id               INTEGER NOT NULL REFERENCES tenant_registry(tenant_id),
+    broadcast_id            UUID REFERENCES outbound_broadcasts(id),
+    template_id             INTEGER REFERENCES outbound_templates(id),
+    recipient_phone         VARCHAR(20) NOT NULL,
+    message_text            TEXT NOT NULL,
+    status                  VARCHAR(20) NOT NULL DEFAULT 'queued',
+    external_message_id     VARCHAR(100),
+    sent_at                 TIMESTAMPTZ,
+    delivered_at            TIMESTAMPTZ,
+    read_at                 TIMESTAMPTZ,
+    failed_reason           VARCHAR(500),
+    created_at              TIMESTAMPTZ NOT NULL DEFAULT NOW(),
+
+    -- status values: queued, sending, sent, delivered, read, failed
+    -- broadcast_id is NULL for trigger-based single messages
+    CONSTRAINT chk_message_status CHECK (status IN ('queued', 'sending', 'sent', 'delivered', 'read', 'failed'))
+);
+
+CREATE INDEX IF NOT EXISTS idx_outbound_messages_tenant_created
+    ON outbound_messages (tenant_id, created_at DESC);
+
+CREATE INDEX IF NOT EXISTS idx_outbound_messages_broadcast_status
+    ON outbound_messages (broadcast_id, status);
+
+CREATE INDEX IF NOT EXISTS idx_outbound_messages_queued
+    ON outbound_messages (status, created_at) WHERE status = 'queued';
+
+CREATE INDEX IF NOT EXISTS idx_outbound_messages_external_id
+    ON outbound_messages (external_message_id) WHERE external_message_id IS NOT NULL;
+
+-- =============================================================
+-- outbound_optouts: Opt-out registry per tenant+phone
+-- =============================================================
+
+CREATE TABLE IF NOT EXISTS outbound_optouts (
+    id                      SERIAL PRIMARY KEY,
+    tenant_id               INTEGER NOT NULL REFERENCES tenant_registry(tenant_id),
+    phone                   VARCHAR(20) NOT NULL,
+    reason                  VARCHAR(200),
+    created_at              TIMESTAMPTZ NOT NULL DEFAULT NOW(),
+
+    -- One opt-out record per phone per tenant
+    CONSTRAINT uq_optout_tenant_phone UNIQUE (tenant_id, phone)
+);
+
+-- =============================================================
+-- Grants (run after creating tables)
+-- =============================================================
+
+GRANT SELECT, INSERT, UPDATE, DELETE ON outbound_templates TO invekto;
+GRANT SELECT, INSERT, UPDATE, DELETE ON outbound_broadcasts TO invekto;
+GRANT SELECT, INSERT, UPDATE, DELETE ON outbound_messages TO invekto;
+GRANT SELECT, INSERT, UPDATE, DELETE ON outbound_optouts TO invekto;
+GRANT USAGE, SELECT ON SEQUENCE outbound_templates_id_seq TO invekto;
+GRANT USAGE, SELECT ON SEQUENCE outbound_messages_id_seq TO invekto;
+GRANT USAGE, SELECT ON SEQUENCE outbound_optouts_id_seq TO invekto;
+
+-- =============================================================
+-- Usage Notes
+-- =============================================================
+--
+-- 1. outbound_templates: trigger_event='manual' for broadcast-only templates
+-- 2. outbound_broadcasts: counter columns (queued/sent/delivered/read/failed)
+--    are updated atomically via UPDATE ... SET sent = sent + 1
+-- 3. outbound_messages: broadcast_id is NULL for trigger-based single messages
+-- 4. outbound_optouts: checked before every message send, UNIQUE prevents duplicates
+-- 5. Rate limiting is handled in-memory (per tenant msg/minute), not in DB
+-- 6. external_message_id links to WapCRM/WhatsApp message ID for delivery tracking
+-- =============================================================
diff --git a/arch/deploy/appsettings.Production.Backend.json b/arch/deploy/appsettings.Production.Backend.json
index c09400a..deb0b90 100644
--- a/arch/deploy/appsettings.Production.Backend.json
+++ b/arch/deploy/appsettings.Production.Backend.json
@@ -24,6 +24,11 @@
       "Url": "http://localhost:7105",
       "LogPath": "E:\\Invekto\\AgentAI\\logs",
       "SuggestTimeoutMs": 15000
+    },
+    "Outbound": {
+      "Url": "http://localhost:7107",
+      "LogPath": "E:\\Invekto\\Outbound\\logs",
+      "TimeoutMs": 10000
     }
   },
   "Jwt": {
diff --git a/arch/deploy/deploy-watcher.ps1 b/arch/deploy/deploy-watcher.ps1
index d057110..736b90d 100644
--- a/arch/deploy/deploy-watcher.ps1
+++ b/arch/deploy/deploy-watcher.ps1
@@ -6,7 +6,7 @@
 
 $watchPath = "E:\Invekto"
 $nssm = "E:\nssm.exe"
-$services = @("InvektoBackend", "InvektoChatAnalysis", "InvektoAutomation", "InvektoAgentAI")
+$services = @("InvektoBackend", "InvektoChatAnalysis", "InvektoAutomation", "InvektoAgentAI", "InvektoOutbound")
 $logFile = "E:\Invekto\logs\deploy-watcher.log"
 
 # Ensure log directory exists
diff --git a/arch/deploy/firewall-rules.bat b/arch/deploy/firewall-rules.bat
index 69315f2..43e993f 100644
--- a/arch/deploy/firewall-rules.bat
+++ b/arch/deploy/firewall-rules.bat
@@ -17,6 +17,9 @@ netsh advfirewall firewall add rule name="Invekto ChatAnalysis (TCP 7101)" dir=i
 REM AgentAI (port 7105) - Localhost only (Backend proxies, not direct external access)
 netsh advfirewall firewall add rule name="Invekto AgentAI (TCP 7105)" dir=in action=allow protocol=tcp localport=7105 profile=any remoteip=127.0.0.1
 
+REM Outbound (port 7107) - Localhost only (Backend proxies, not direct external access)
+netsh advfirewall firewall add rule name="Invekto Outbound (TCP 7107)" dir=in action=allow protocol=tcp localport=7107 profile=any remoteip=127.0.0.1
+
 REM Automation (port 7108) - External access (Main App webhooks)
 netsh advfirewall firewall add rule name="Invekto Automation (TCP 7108)" dir=in action=allow protocol=tcp localport=7108 profile=any
 
@@ -33,6 +36,7 @@ echo    4500  Simulator     (external)
 echo    5000  Backend       (external)
 echo    7101  ChatAnalysis  (localhost only)
 echo    7105  AgentAI       (localhost only)
+echo    7107  Outbound      (localhost only)
 echo    7108  Automation    (external)
 echo    5432  PostgreSQL    (localhost only)
 echo ============================================
diff --git a/arch/deploy/install-services.bat b/arch/deploy/install-services.bat
index 02e28be..c0e9716 100644
--- a/arch/deploy/install-services.bat
+++ b/arch/deploy/install-services.bat
@@ -13,7 +13,7 @@ echo ============================================
 echo.
 
 REM Backend Service
-echo [1/4] Installing InvektoBackend...
+echo [1/5] Installing InvektoBackend...
 %NSSM% install InvektoBackend "E:\Invekto\Backend\current\Invekto.Backend.exe"
 %NSSM% set InvektoBackend DisplayName "Invekto Backend"
 %NSSM% set InvektoBackend Description "Invekto Backend API - Port 5000"
@@ -32,7 +32,7 @@ echo [OK] InvektoBackend installed
 echo.
 
 REM ChatAnalysis Service
-echo [2/4] Installing InvektoChatAnalysis...
+echo [2/5] Installing InvektoChatAnalysis...
 %NSSM% install InvektoChatAnalysis "E:\Invekto\ChatAnalysis\current\Invekto.ChatAnalysis.exe"
 %NSSM% set InvektoChatAnalysis DisplayName "Invekto ChatAnalysis"
 %NSSM% set InvektoChatAnalysis Description "Invekto Chat Analysis Microservice - Port 7101"
@@ -51,7 +51,7 @@ echo [OK] InvektoChatAnalysis installed
 echo.
 
 REM Automation Service
-echo [3/4] Installing InvektoAutomation...
+echo [3/5] Installing InvektoAutomation...
 %NSSM% install InvektoAutomation "E:\Invekto\Automation\current\Invekto.Automation.exe"
 %NSSM% set InvektoAutomation DisplayName "Invekto Automation"
 %NSSM% set InvektoAutomation Description "Invekto Automation Chatbot/Flow Builder - Port 7108"
@@ -70,7 +70,7 @@ echo [OK] InvektoAutomation installed
 echo.
 
 REM AgentAI Service
-echo [4/4] Installing InvektoAgentAI...
+echo [4/5] Installing InvektoAgentAI...
 %NSSM% install InvektoAgentAI "E:\Invekto\AgentAI\current\Invekto.AgentAI.exe"
 %NSSM% set InvektoAgentAI DisplayName "Invekto AgentAI"
 %NSSM% set InvektoAgentAI Description "Invekto AI Agent Assist Microservice - Port 7105"
@@ -88,11 +88,31 @@ echo [4/4] Installing InvektoAgentAI...
 echo [OK] InvektoAgentAI installed
 echo.
 
+REM Outbound Service
+echo [5/5] Installing InvektoOutbound...
+%NSSM% install InvektoOutbound "E:\Invekto\Outbound\current\Invekto.Outbound.exe"
+%NSSM% set InvektoOutbound DisplayName "Invekto Outbound"
+%NSSM% set InvektoOutbound Description "Invekto Outbound Broadcast Messaging - Port 7107"
+%NSSM% set InvektoOutbound AppDirectory "E:\Invekto\Outbound\current"
+%NSSM% set InvektoOutbound AppEnvironmentExtra "ASPNETCORE_ENVIRONMENT=Production"
+%NSSM% set InvektoOutbound AppStdout "E:\Invekto\Outbound\logs\service-stdout.log"
+%NSSM% set InvektoOutbound AppStderr "E:\Invekto\Outbound\logs\service-stderr.log"
+%NSSM% set InvektoOutbound AppStdoutCreationDisposition 4
+%NSSM% set InvektoOutbound AppStderrCreationDisposition 4
+%NSSM% set InvektoOutbound AppRotateFiles 1
+%NSSM% set InvektoOutbound AppRotateBytes 10485760
+%NSSM% set InvektoOutbound Start SERVICE_AUTO_START
+%NSSM% set InvektoOutbound AppExit Default Restart
+%NSSM% set InvektoOutbound AppRestartDelay 5000
+echo [OK] InvektoOutbound installed
+echo.
+
 REM Create log directories
 if not exist "E:\Invekto\Backend\logs" mkdir "E:\Invekto\Backend\logs"
 if not exist "E:\Invekto\ChatAnalysis\logs" mkdir "E:\Invekto\ChatAnalysis\logs"
 if not exist "E:\Invekto\Automation\logs" mkdir "E:\Invekto\Automation\logs"
 if not exist "E:\Invekto\AgentAI\logs" mkdir "E:\Invekto\AgentAI\logs"
+if not exist "E:\Invekto\Outbound\logs" mkdir "E:\Invekto\Outbound\logs"
 
 REM Start services
 echo Starting services...
@@ -104,6 +124,8 @@ timeout /t 3 /nobreak >nul
 timeout /t 3 /nobreak >nul
 %NSSM% start InvektoAgentAI
 timeout /t 3 /nobreak >nul
+%NSSM% start InvektoOutbound
+timeout /t 3 /nobreak >nul
 
 echo.
 echo ============================================
@@ -115,11 +137,13 @@ echo Services:
 %NSSM% status InvektoChatAnalysis
 %NSSM% status InvektoAutomation
 %NSSM% status InvektoAgentAI
+%NSSM% status InvektoOutbound
 echo.
 echo Test:
 echo   http://localhost:5000/health
 echo   http://localhost:7101/health
 echo   http://localhost:7105/health
+echo   http://localhost:7107/health
 echo   http://localhost:7108/health
 echo.
 echo Manage:
@@ -127,5 +151,6 @@ echo   %NSSM% edit InvektoBackend
 echo   %NSSM% edit InvektoChatAnalysis
 echo   %NSSM% edit InvektoAutomation
 echo   %NSSM% edit InvektoAgentAI
+echo   %NSSM% edit InvektoOutbound
 echo.
 pause
diff --git a/arch/deploy/restart-services.bat b/arch/deploy/restart-services.bat
index 90e6f2b..7bd4dfe 100644
--- a/arch/deploy/restart-services.bat
+++ b/arch/deploy/restart-services.bat
@@ -12,6 +12,7 @@ echo Stopping services...
 %NSSM% stop InvektoChatAnalysis
 %NSSM% stop InvektoAutomation
 %NSSM% stop InvektoAgentAI
+%NSSM% stop InvektoOutbound
 timeout /t 3 /nobreak >nul
 
 echo.
@@ -24,6 +25,8 @@ timeout /t 2 /nobreak >nul
 timeout /t 2 /nobreak >nul
 %NSSM% start InvektoAgentAI
 timeout /t 2 /nobreak >nul
+%NSSM% start InvektoOutbound
+timeout /t 2 /nobreak >nul
 
 echo.
 echo Status:
@@ -31,10 +34,12 @@ echo Status:
 %NSSM% status InvektoChatAnalysis
 %NSSM% status InvektoAutomation
 %NSSM% status InvektoAgentAI
+%NSSM% status InvektoOutbound
 echo.
 echo Test: http://localhost:5000/health
 echo Test: http://localhost:7101/health
-echo Test: http://localhost:7108/health
 echo Test: http://localhost:7105/health
+echo Test: http://localhost:7107/health
+echo Test: http://localhost:7108/health
 echo.
 pause
diff --git a/arch/errors.md b/arch/errors.md
index 602fb38..9fb5479 100644
--- a/arch/errors.md
+++ b/arch/errors.md
@@ -25,6 +25,7 @@ INV-{SERVICE}-{NUMBER}
 | INT | Integration | GR-1.9: Entegrasyon k├╢pr├╝s├╝ hatalar─▒ |
 | DB | Database | Veritaban─▒ hatalar─▒ |
 | VAL | Validation | Validasyon hatalar─▒ |
+| OB | Outbound | GR-1.3: Broadcast & trigger engine hatalar─▒ |
 | EXT | External | D─▒┼ƒ servis hatalar─▒ |
 
 ---
@@ -131,6 +132,23 @@ INV-{SERVICE}-{NUMBER}
 
 ---
 
+## OB - Outbound Errors (GR-1.3)
+
+| Code | Description | User Message |
+|------|-------------|--------------|
+| INV-OB-001 | Invalid broadcast payload | Gecersiz toplu mesaj istegi. |
+| INV-OB-002 | Template not found | Mesaj sablonu bulunamadi. |
+| INV-OB-003 | Rate limit exceeded (queued) | Gonderim limiti asildi, mesajlar kuyrukta bekliyor. |
+| INV-OB-004 | Recipient opted out | Alici mesaj almak istemiyor (opt-out). |
+| INV-OB-005 | Broadcast not found | Toplu mesaj kaydi bulunamadi. |
+| INV-OB-006 | Delivery status update failed | Teslimat durumu guncellenemedi. |
+| INV-OB-007 | Invalid template payload | Gecersiz sablon formati. |
+| INV-OB-008 | No matching trigger template | Bu event icin esle&#351;en sablon bulunamadi. |
+| INV-OB-009 | Message send callback failed | Mesaj gonderim callback'i basarisiz oldu. |
+| INV-OB-010 | Too many recipients (max 1000) | Alici sayisi siniri asildi (max 1000). |
+
+---
+
 ## EXT - External Service Errors
 
 | Code | Description | User Message |
diff --git a/arch/plans/20260212-outbound-service.json b/arch/plans/20260212-outbound-service.json
new file mode 100644
index 0000000..141833d
--- /dev/null
+++ b/arch/plans/20260212-outbound-service.json
@@ -0,0 +1,315 @@
+{
+  "slug": "20260212-outbound-service",
+  "title": "GR-1.3: Invekto.Outbound Broadcast & Trigger Engine",
+  "status": "REVIEW",
+  "risk": "HIGH",
+  "iteration": 0,
+  "created_at": "2026-02-12",
+  "summary": "Yeni Invekto.Outbound mikroservisi (Port 7107): toplu mesaj g├╢nderimi, event-based trigger engine, template engine ({{var}}), tenant-bazl─▒ rate limiting ile kuyruk, opt-out y├╢netimi (STOP keyword detection), delivery status tracking. Callback pattern ile mesaj g├╢nderimi (Outbound ΓåÆ Main App ΓåÆ WapCRM).",
+
+  "interview_decisions": {
+    "send_flow": "Callback pattern: Outbound kuyru─ƒa al─▒r ΓåÆ Main App'e send_message callback ΓåÆ Main App WapCRM'e g├╢nderir",
+    "trigger_engine": "Webhook triggers + send_at (one-time scheduled). Full cron engine Phase 2",
+    "segment_recipient": "Main App telefon listesini g├╢nderir (max 1,000 per request). Outbound segment mant─▒─ƒ─▒ bilmez",
+    "rate_limiting": "Tenant-bazl─▒ rate limit (msg/dakika). Limit a┼ƒ─▒l─▒nca mesaj kuyrukta bekler, reject yok",
+    "delivery_status": "Main App ΓåÆ Outbound webhook (POST /delivery-status). Outbound DB g├╝nceller",
+    "template_variables": "Per-recipient variables: {phone, variables: {isim, firma}}",
+    "optout": "Main App raw mesaj─▒ forward eder ΓåÆ Outbound STOP/DUR/─░PTAL keyword detect eder ve opt-out kayd─▒ olu┼ƒturur",
+    "trigger_events": "Phase 1: new_lead, payment_received, appointment_reminder",
+    "batch_size": "Max 1,000 recipients per broadcast request"
+  },
+
+  "architecture": {
+    "broadcast_flow": [
+      "Main App ΓåÆ Backend /api/v1/outbound/broadcast/send (JWT + recipients)",
+      "Backend ΓåÆ Outbound /api/v1/broadcast/send (proxy)",
+      "Outbound: validate ΓåÆ create broadcast record ΓåÆ insert messages as 'queued'",
+      "Return 202 Accepted with broadcast_id",
+      "Background IHostedService dequeues messages respecting rate limit",
+      "Per message: send_message callback to Main App via MainAppCallbackClient",
+      "Main App sends via WapCRM",
+      "Main App receives delivery status ΓåÆ forwards to Outbound",
+      "Outbound updates message status (sent/delivered/read/failed)"
+    ],
+    "trigger_flow": [
+      "Main App event occurs (new_lead, payment, etc.)",
+      "Main App ΓåÆ Backend ΓåÆ Outbound /api/v1/webhook/trigger",
+      "Outbound checks outbound_templates for matching trigger_event + tenant",
+      "Applies template variables from webhook data",
+      "Inserts single message as 'queued' (same rate-limited queue)",
+      "Background sender processes"
+    ],
+    "optout_flow": [
+      "Customer sends 'STOP' on WhatsApp",
+      "Main App receives ΓåÆ forwards to Backend ΓåÆ Outbound /api/v1/webhook/message",
+      "Outbound checks for stop keywords (STOP, DUR, ─░PTAL, IPTAL, DURDU, ├çIKI┼₧, CIKIS)",
+      "If match: create opt-out record, return {opted_out: true}",
+      "Future broadcasts skip opted-out phones"
+    ]
+  },
+
+  "db_tables": {
+    "outbound_templates": {
+      "columns": "id SERIAL PK, tenant_id INT FK, name VARCHAR(200), trigger_event VARCHAR(50), message_template TEXT, variables_json JSONB, is_active BOOL, created_at TIMESTAMPTZ, updated_at TIMESTAMPTZ",
+      "indexes": ["(tenant_id, is_active) WHERE is_active=true", "(tenant_id, trigger_event) WHERE is_active=true"],
+      "notes": "trigger_event: new_lead, payment_received, appointment_reminder, manual (for broadcast-only templates)"
+    },
+    "outbound_broadcasts": {
+      "columns": "id UUID PK, tenant_id INT FK, template_id INT, total_recipients INT, queued INT, sent INT, delivered INT, read INT, failed INT, status VARCHAR(20), scheduled_at TIMESTAMPTZ, started_at TIMESTAMPTZ, completed_at TIMESTAMPTZ, created_at TIMESTAMPTZ",
+      "indexes": ["(tenant_id, created_at DESC)", "(status) WHERE status IN ('queued','processing')"],
+      "notes": "status: queued, processing, completed, failed. Counter columns for fast status queries"
+    },
+    "outbound_messages": {
+      "columns": "id BIGSERIAL PK, tenant_id INT FK, broadcast_id UUID, template_id INT, recipient_phone VARCHAR(20), message_text TEXT, status VARCHAR(20), external_message_id VARCHAR(100), sent_at TIMESTAMPTZ, delivered_at TIMESTAMPTZ, read_at TIMESTAMPTZ, failed_reason VARCHAR(500), created_at TIMESTAMPTZ",
+      "indexes": ["(tenant_id, created_at DESC)", "(broadcast_id, status)", "(status, created_at) WHERE status='queued'", "(external_message_id) WHERE external_message_id IS NOT NULL"],
+      "notes": "status: queued, sending, sent, delivered, read, failed. broadcast_id nullable (null for trigger-based single messages)"
+    },
+    "outbound_optouts": {
+      "columns": "id SERIAL PK, tenant_id INT FK, phone VARCHAR(20), reason VARCHAR(200), created_at TIMESTAMPTZ",
+      "indexes": ["UNIQUE (tenant_id, phone)"],
+      "notes": "Unique constraint: bir phone bir tenant'ta tek opt-out kayd─▒"
+    }
+  },
+
+  "endpoints": {
+    "outbound_service": [
+      {"method": "POST", "path": "/api/v1/broadcast/send", "auth": "JWT", "response": "202", "desc": "Submit broadcast (async)"},
+      {"method": "GET", "path": "/api/v1/broadcast/{broadcastId}/status", "auth": "JWT", "response": "200", "desc": "Get broadcast delivery status"},
+      {"method": "POST", "path": "/api/v1/webhook/trigger", "auth": "JWT", "response": "202", "desc": "Receive trigger event from Main App"},
+      {"method": "POST", "path": "/api/v1/webhook/delivery-status", "auth": "JWT", "response": "200", "desc": "Receive delivery status update"},
+      {"method": "POST", "path": "/api/v1/webhook/message", "auth": "JWT", "response": "200", "desc": "Receive incoming message for opt-out detection"},
+      {"method": "GET", "path": "/api/v1/templates", "auth": "JWT", "response": "200", "desc": "List active templates"},
+      {"method": "POST", "path": "/api/v1/templates", "auth": "JWT", "response": "201", "desc": "Create template"},
+      {"method": "PUT", "path": "/api/v1/templates/{id}", "auth": "JWT", "response": "200", "desc": "Update template"},
+      {"method": "DELETE", "path": "/api/v1/templates/{id}", "auth": "JWT", "response": "200", "desc": "Deactivate template"},
+      {"method": "POST", "path": "/api/v1/optout", "auth": "JWT", "response": "200", "desc": "Manual opt-out add"},
+      {"method": "DELETE", "path": "/api/v1/optout/{phone}", "auth": "JWT", "response": "200", "desc": "Remove opt-out"},
+      {"method": "GET", "path": "/api/v1/optout/check/{phone}", "auth": "JWT", "response": "200", "desc": "Check if phone opted out"},
+      {"method": "GET", "path": "/health", "auth": "none", "response": "200", "desc": "Health check"},
+      {"method": "GET", "path": "/ready", "auth": "none", "response": "200", "desc": "Readiness probe (DB check)"},
+      {"method": "GET", "path": "/api/ops/endpoints", "auth": "none", "response": "200", "desc": "Endpoint discovery"}
+    ],
+    "backend_proxy": [
+      {"method": "POST", "path": "/api/v1/outbound/broadcast/send", "proxies_to": "/api/v1/broadcast/send"},
+      {"method": "GET", "path": "/api/v1/outbound/broadcast/{broadcastId}/status", "proxies_to": "/api/v1/broadcast/{broadcastId}/status"},
+      {"method": "POST", "path": "/api/v1/outbound/webhook/trigger", "proxies_to": "/api/v1/webhook/trigger"},
+      {"method": "POST", "path": "/api/v1/outbound/webhook/delivery-status", "proxies_to": "/api/v1/webhook/delivery-status"},
+      {"method": "POST", "path": "/api/v1/outbound/webhook/message", "proxies_to": "/api/v1/webhook/message"},
+      {"method": "GET", "path": "/api/v1/outbound/templates", "proxies_to": "/api/v1/templates"},
+      {"method": "POST", "path": "/api/v1/outbound/templates", "proxies_to": "/api/v1/templates"},
+      {"method": "PUT", "path": "/api/v1/outbound/templates/{id}", "proxies_to": "/api/v1/templates/{id}"},
+      {"method": "DELETE", "path": "/api/v1/outbound/templates/{id}", "proxies_to": "/api/v1/templates/{id}"},
+      {"method": "POST", "path": "/api/v1/outbound/optout", "proxies_to": "/api/v1/optout"},
+      {"method": "DELETE", "path": "/api/v1/outbound/optout/{phone}", "proxies_to": "/api/v1/optout/{phone}"},
+      {"method": "GET", "path": "/api/v1/outbound/optout/check/{phone}", "proxies_to": "/api/v1/optout/check/{phone}"}
+    ]
+  },
+
+  "error_codes": {
+    "INV-OB-001": "Invalid broadcast payload",
+    "INV-OB-002": "Template not found",
+    "INV-OB-003": "Rate limit exceeded (queued for later)",
+    "INV-OB-004": "Recipient opted out",
+    "INV-OB-005": "Broadcast not found",
+    "INV-OB-006": "Delivery status update failed",
+    "INV-OB-007": "Invalid template payload",
+    "INV-OB-008": "No matching trigger template",
+    "INV-OB-009": "Message send callback failed",
+    "INV-OB-010": "Too many recipients (max 1000)"
+  },
+
+  "files_to_create": [
+    "src/Invekto.Outbound/Invekto.Outbound.csproj",
+    "src/Invekto.Outbound/Program.cs",
+    "src/Invekto.Outbound/appsettings.json",
+    "src/Invekto.Outbound/Data/OutboundRepository.cs",
+    "src/Invekto.Outbound/Services/TemplateEngine.cs",
+    "src/Invekto.Outbound/Services/OptOutManager.cs",
+    "src/Invekto.Outbound/Services/RateLimiter.cs",
+    "src/Invekto.Outbound/Services/BroadcastOrchestrator.cs",
+    "src/Invekto.Outbound/Services/TriggerProcessor.cs",
+    "src/Invekto.Outbound/Services/MessageSenderService.cs",
+    "src/Invekto.Shared/DTOs/Outbound/BroadcastDtos.cs",
+    "src/Invekto.Shared/DTOs/Outbound/TemplateDtos.cs",
+    "src/Invekto.Shared/DTOs/Outbound/WebhookDtos.cs",
+    "src/Invekto.Backend/Services/OutboundClient.cs",
+    "arch/db/outbound.sql",
+    "arch/contracts/outbound-broadcast.json",
+    "src/Invekto.Outbound/appsettings.Production.json"
+  ],
+
+  "files_to_modify": [
+    "src/Invekto.Shared/Constants/ErrorCodes.cs",
+    "src/Invekto.Shared/DTOs/Integration/OutgoingCallback.cs",
+    "arch/errors.md",
+    "src/Invekto.Backend/appsettings.json",
+    "arch/deploy/appsettings.Production.Backend.json",
+    "src/Invekto.Backend/Program.cs",
+    "dev-to-invekto-services.bat",
+    "arch/deploy/install-services.bat",
+    "arch/deploy/firewall-rules.bat",
+    "arch/deploy/restart-services.bat",
+    "arch/deploy/deploy-watcher.ps1",
+    "arch/session-memory.md",
+    "arch/active-work.md"
+  ],
+
+  "implementation_steps": [
+    {
+      "step": 1,
+      "name": "Arch files + Error codes",
+      "files": ["arch/db/outbound.sql", "arch/contracts/outbound-broadcast.json", "arch/errors.md", "src/Invekto.Shared/Constants/ErrorCodes.cs"],
+      "desc": "DB schema, API contract, error code definitions"
+    },
+    {
+      "step": 2,
+      "name": "Shared DTOs + CallbackData extension",
+      "files": ["src/Invekto.Shared/DTOs/Outbound/BroadcastDtos.cs", "src/Invekto.Shared/DTOs/Outbound/TemplateDtos.cs", "src/Invekto.Shared/DTOs/Outbound/WebhookDtos.cs", "src/Invekto.Shared/DTOs/Integration/OutgoingCallback.cs"],
+      "desc": "Request/response DTOs, extend CallbackData with phone/broadcast_id/message_id"
+    },
+    {
+      "step": 3,
+      "name": "Outbound project skeleton + health endpoints",
+      "files": ["src/Invekto.Outbound/Invekto.Outbound.csproj", "src/Invekto.Outbound/Program.cs", "src/Invekto.Outbound/appsettings.json", "src/Invekto.Outbound/appsettings.Production.json"],
+      "desc": "Project file, Kestrel 7107, WindowsService, JWT, PostgreSQL, health/ready"
+    },
+    {
+      "step": 4,
+      "name": "Data layer + Services",
+      "files": ["src/Invekto.Outbound/Data/OutboundRepository.cs", "src/Invekto.Outbound/Services/TemplateEngine.cs", "src/Invekto.Outbound/Services/OptOutManager.cs", "src/Invekto.Outbound/Services/RateLimiter.cs", "src/Invekto.Outbound/Services/BroadcastOrchestrator.cs", "src/Invekto.Outbound/Services/TriggerProcessor.cs", "src/Invekto.Outbound/Services/MessageSenderService.cs"],
+      "desc": "All business logic: repository, template engine, opt-out, rate limiter, orchestrator, trigger processor, background message sender"
+    },
+    {
+      "step": 5,
+      "name": "Wire all endpoints in Program.cs",
+      "files": ["src/Invekto.Outbound/Program.cs"],
+      "desc": "Complete all API endpoints: broadcast, templates, webhooks, optout"
+    },
+    {
+      "step": 6,
+      "name": "Backend proxy + deploy scripts",
+      "files": ["src/Invekto.Backend/Services/OutboundClient.cs", "src/Invekto.Backend/Program.cs", "src/Invekto.Backend/appsettings.json", "arch/deploy/appsettings.Production.Backend.json", "dev-to-invekto-services.bat", "arch/deploy/install-services.bat", "arch/deploy/firewall-rules.bat", "arch/deploy/restart-services.bat", "arch/deploy/deploy-watcher.ps1"],
+      "desc": "Backend OutboundClient, proxy endpoints, all deploy scripts updated for Outbound"
+    },
+    {
+      "step": 7,
+      "name": "Build + arch update",
+      "files": ["arch/session-memory.md", "arch/active-work.md"],
+      "desc": "Full solution build, update session memory"
+    }
+  ],
+
+  "verification_questions": [
+    {"category": "DB_SYNC", "question": "outbound_templates, outbound_broadcasts, outbound_messages, outbound_optouts tablolar─▒ outbound.sql'de do─ƒru tan─▒ml─▒ m─▒? FK, index, constraint'ler var m─▒?"},
+    {"category": "RATE_LIMIT", "question": "RateLimiter tenant-bazl─▒ ├ºal─▒┼ƒ─▒yor mu? Limit a┼ƒ─▒l─▒nca mesaj reject DE─₧─░L kuyrukta bekliyor mu?"},
+    {"category": "OPT_OUT", "question": "Broadcast g├╢nderiminde opt-out check yap─▒l─▒yor mu? Opted-out telefona mesaj g├╢nderilmiyor mu?"},
+    {"category": "CALLBACK", "question": "send_message callback'inde phone alan─▒ var m─▒? Main App hangi numaraya g├╢nderece─ƒini biliyor mu?"},
+    {"category": "TEMPLATE", "question": "Template {{var}} substitution d├╝zg├╝n ├ºal─▒┼ƒ─▒yor mu? Eksik variable handle ediliyor mu?"},
+    {"category": "TRIGGER", "question": "Trigger webhook'u template e┼ƒle┼ƒtirmesi yap─▒yor mu? E┼ƒle┼ƒen yoksa INV-OB-008 d├╢n├╝yor mu?"},
+    {"category": "BACKGROUND", "question": "MessageSenderService IHostedService olarak register edilmi┼ƒ mi? Graceful shutdown yap─▒yor mu?"},
+    {"category": "AUTH", "question": "T├╝m /api/v1/ endpoint'leri JWT korumal─▒ m─▒? Backend proxy JWT forwarding yap─▒yor mu?"},
+    {"category": "DEPLOY", "question": "T├╝m deploy scriptleri g├╝ncellendi mi? (7 dosya: deploy-bat, install, firewall, restart, watcher, Backend appsettings dev+prod)"},
+    {"category": "ERROR_CODES", "question": "INV-OB-001~010 error code'lar─▒ hem errors.md hem ErrorCodes.cs'de tan─▒ml─▒ m─▒?"}
+  ],
+
+  "aha_moments": [
+    {
+      "category": "UX",
+      "user_pain": "Toplu mesaj g├╢nderirken agent tek tek numaralara kopyala-yap─▒┼ƒt─▒r yap─▒yor",
+      "suggestion": "Broadcast send'den sonra ger├ºek zamanl─▒ progress bar g├╢ster (queued ΓåÆ sent ΓåÆ delivered y├╝zdeleri)",
+      "aha_moment": "Agent 'G├╢nder' bas─▒yor, 500 mesaj─▒n %'si canl─▒ olarak y├╝kseliyor - 'vay, hepsini takip edebiliyorum!'"
+    },
+    {
+      "category": "SPEED",
+      "user_pain": "Yeni lead geldi─ƒinde kar┼ƒ─▒lama mesaj─▒ g├╢ndermek i├ºin birinin online olmas─▒ gerekiyor",
+      "suggestion": "Trigger engine: new_lead event'i otomatik kar┼ƒ─▒lama mesaj─▒ g├╢nderir (< 5 saniye)",
+      "aha_moment": "Lead formu doldurur, 3 saniyede WhatsApp'tan 'Ho┼ƒ geldiniz Ali!' mesaj─▒ gelir - 'bunlar ├ºok h─▒zl─▒!'"
+    },
+    {
+      "category": "RELIABILITY",
+      "user_pain": "WhatsApp rate limit'e tak─▒l─▒p mesajlar kaybolabilir",
+      "suggestion": "Rate limiter + queue: hi├ºbir mesaj kaybolmaz, s─▒raya al─▒n─▒r ve g├╝venli h─▒zda g├╢nderilir",
+      "aha_moment": "1000 mesajl─▒k kampanya, hepsi teslim edildi, 0 kay─▒p - 'g├╝venle g├╢nderebiliyoruz!'"
+    },
+    {
+      "category": "SALES",
+      "user_pain": "M├╝┼ƒteri 'STOP' yaz─▒nca hala mesaj almaya devam ediyor, ┼ƒikayet geliyor",
+      "suggestion": "Otomatik opt-out: STOP/DUR/─░PTAL alg─▒lan─▒r, m├╝┼ƒteri listelendir ve bir daha rahats─▒z edilmez",
+      "aha_moment": "M├╝┼ƒteri 'dur' yazar, an─▒nda opt-out kayd─▒ olu┼ƒur - 'yasal uyumluluk otomatik!'"
+    },
+    {
+      "category": "SUPPORT",
+      "user_pain": "Template mesajlar─▒nda m├╝┼ƒteri ad─▒ yerine {{isim}} gidiyor - utan├º verici",
+      "suggestion": "Template engine her mesaj─▒ g├╢ndermeden ├╢nce t├╝m de─ƒi┼ƒkenleri kontrol eder, eksik varsa bloklar",
+      "aha_moment": "De─ƒi┼ƒken eksik olan mesaj g├╢nderilmez, agent uyar─▒l─▒r - 'hatal─▒ mesaj m├╝┼ƒteriye gitmedi!'"
+    }
+  ],
+
+  "git_diff": {
+    "sha256": "128BA1F76E0951161D03FC6B2BE1AC5403603BA7BF48FE3BC0AB944F4B71C384",
+    "full_path": "arch/plans/diffs/20260212-outbound-service.diff",
+    "stats": {
+      "insertions": 7424,
+      "deletions": 30,
+      "files_count": 35
+    }
+  },
+
+  "files_changed": [
+    {"path": "InvektoServis.sln", "is_new": false},
+    {"path": "arch/active-work.md", "is_new": false},
+    {"path": "arch/contracts/outbound-broadcast.json", "is_new": true},
+    {"path": "arch/db/outbound.sql", "is_new": true},
+    {"path": "arch/deploy/appsettings.Production.Backend.json", "is_new": false},
+    {"path": "arch/deploy/deploy-watcher.ps1", "is_new": false},
+    {"path": "arch/deploy/firewall-rules.bat", "is_new": false},
+    {"path": "arch/deploy/install-services.bat", "is_new": false},
+    {"path": "arch/deploy/restart-services.bat", "is_new": false},
+    {"path": "arch/errors.md", "is_new": false},
+    {"path": "arch/plans/20260212-outbound-service.json", "is_new": true},
+    {"path": "arch/session-memory.md", "is_new": false},
+    {"path": "dev-to-invekto-services.bat", "is_new": false},
+    {"path": "src/Invekto.Backend/Program.cs", "is_new": false},
+    {"path": "src/Invekto.Backend/Services/OutboundClient.cs", "is_new": true},
+    {"path": "src/Invekto.Backend/appsettings.json", "is_new": false},
+    {"path": "src/Invekto.Outbound/Data/OutboundRepository.cs", "is_new": true},
+    {"path": "src/Invekto.Outbound/Invekto.Outbound.csproj", "is_new": true},
+    {"path": "src/Invekto.Outbound/Middleware/JwtAuthMiddleware.cs", "is_new": true},
+    {"path": "src/Invekto.Outbound/Middleware/TrafficLoggingMiddleware.cs", "is_new": true},
+    {"path": "src/Invekto.Outbound/Program.cs", "is_new": true},
+    {"path": "src/Invekto.Outbound/Services/BroadcastOrchestrator.cs", "is_new": true},
+    {"path": "src/Invekto.Outbound/Services/MessageSenderService.cs", "is_new": true},
+    {"path": "src/Invekto.Outbound/Services/OptOutManager.cs", "is_new": true},
+    {"path": "src/Invekto.Outbound/Services/RateLimiter.cs", "is_new": true},
+    {"path": "src/Invekto.Outbound/Services/TemplateEngine.cs", "is_new": true},
+    {"path": "src/Invekto.Outbound/Services/TriggerProcessor.cs", "is_new": true},
+    {"path": "src/Invekto.Outbound/appsettings.json", "is_new": true},
+    {"path": "src/Invekto.Shared/Constants/ErrorCodes.cs", "is_new": false},
+    {"path": "src/Invekto.Shared/DTOs/Integration/OutgoingCallback.cs", "is_new": false},
+    {"path": "src/Invekto.Shared/DTOs/Outbound/BroadcastDtos.cs", "is_new": true},
+    {"path": "src/Invekto.Shared/DTOs/Outbound/TemplateDtos.cs", "is_new": true},
+    {"path": "src/Invekto.Shared/DTOs/Outbound/WebhookDtos.cs", "is_new": true},
+    {"path": "src/Invekto.Shared/Services/TemplateSubstitution.cs", "is_new": true},
+    {"path": "arch/plans/diffs/20260212-outbound-service.diff", "is_new": true}
+  ],
+
+  "build": {
+    "timestamp": "2026-02-12T21:10:00Z",
+    "result": "PASS",
+    "errors": 0,
+    "warnings": 10
+  },
+
+  "updated_at": "2026-02-12T20:50:00Z",
+
+  "codex_review": {
+    "iteration": 1,
+    "verdict": "FAIL",
+    "blocking_issues": [
+      "CQ2: Silent catch in OutboundRepository.ReadTemplateDto - malformed JSON swallowed",
+      "CQ4: Duplicate TemplateEngine between AgentAI and Outbound",
+      "CQ6: N+1 DB queries in BroadcastOrchestrator - per-recipient opt-out check + insert",
+      "Q7: Shutdown race - messages stuck in sending status after shutdown"
+    ]
+  }
+}
diff --git a/arch/plans/diffs/20260212-outbound-service.diff b/arch/plans/diffs/20260212-outbound-service.diff
new file mode 100644
index 0000000..ab3ddbc
--- /dev/null
+++ b/arch/plans/diffs/20260212-outbound-service.diff
@@ -0,0 +1,8080 @@
+∩╗┐diff --git a/InvektoServis.sln b/InvektoServis.sln
+index 9c98ea7..10d1026 100644
+--- a/InvektoServis.sln
++++ b/InvektoServis.sln
+@@ -21,6 +21,8 @@ Project("{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}") = "Invekto.Automation", "src\I
+ EndProject
+ Project("{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}") = "Invekto.AgentAI", "src\Invekto.AgentAI\Invekto.AgentAI.csproj", "{B3A1D2E4-5F67-4890-AB12-CD34EF56A789}"
+ EndProject
++Project("{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}") = "Invekto.Outbound", "src\Invekto.Outbound\Invekto.Outbound.csproj", "{20F24E9A-831F-46B9-A006-B606A5404E41}"
++EndProject
+ Global
+ 	GlobalSection(SolutionConfigurationPlatforms) = preSolution
+ 		Debug|Any CPU = Debug|Any CPU
+@@ -58,6 +60,10 @@ Global
+ 		{B3A1D2E4-5F67-4890-AB12-CD34EF56A789}.Debug|Any CPU.Build.0 = Debug|Any CPU
+ 		{B3A1D2E4-5F67-4890-AB12-CD34EF56A789}.Release|Any CPU.ActiveCfg = Release|Any CPU
+ 		{B3A1D2E4-5F67-4890-AB12-CD34EF56A789}.Release|Any CPU.Build.0 = Release|Any CPU
++		{20F24E9A-831F-46B9-A006-B606A5404E41}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
++		{20F24E9A-831F-46B9-A006-B606A5404E41}.Debug|Any CPU.Build.0 = Debug|Any CPU
++		{20F24E9A-831F-46B9-A006-B606A5404E41}.Release|Any CPU.ActiveCfg = Release|Any CPU
++		{20F24E9A-831F-46B9-A006-B606A5404E41}.Release|Any CPU.Build.0 = Release|Any CPU
+ 	EndGlobalSection
+ 	GlobalSection(NestedProjects) = preSolution
+ 		{15F8FD75-7433-4D26-A091-8B804B50C75C} = {2D97BB8D-A179-4B02-AABE-097A26C8ECFD}
+@@ -67,5 +73,6 @@ Global
+ 		{0EDF88EB-3AA1-4437-A4EF-40AF8F8ABB20} = {4858822B-FBD3-429F-9855-560EA526C9B1}
+ 		{940E6C4F-877B-4CA4-A4F4-2BE9F6FBA5B0} = {2D97BB8D-A179-4B02-AABE-097A26C8ECFD}
+ 		{B3A1D2E4-5F67-4890-AB12-CD34EF56A789} = {2D97BB8D-A179-4B02-AABE-097A26C8ECFD}
++		{20F24E9A-831F-46B9-A006-B606A5404E41} = {2D97BB8D-A179-4B02-AABE-097A26C8ECFD}
+ 	EndGlobalSection
+ EndGlobal
+diff --git a/arch/active-work.md b/arch/active-work.md
+index 0a881cf..3e28a1a 100644
+--- a/arch/active-work.md
++++ b/arch/active-work.md
+@@ -6,7 +6,7 @@
+ 
+ | Slug | Status | Started | Description |
+ |------|--------|---------|-------------|
+-| (none) | - | - | - |
++| 20260212-outbound-service | BUILD_PASS | 2026-02-12 | GR-1.3: Invekto.Outbound broadcast & trigger engine (Port 7107) - Implemented, build PASS, /rev bekliyor |
+ 
+ ---
+ 
+diff --git a/arch/contracts/outbound-broadcast.json b/arch/contracts/outbound-broadcast.json
+new file mode 100644
+index 0000000..e5d714a
+--- /dev/null
++++ b/arch/contracts/outbound-broadcast.json
+@@ -0,0 +1,200 @@
++{
++  "$schema": "outbound-broadcast-contract",
++  "version": "1.0",
++  "service": "Invekto.Outbound",
++  "port": 7107,
++  "description": "Outbound broadcast, trigger, template, and opt-out API contracts",
++
++  "endpoints": {
++    "broadcast_send": {
++      "method": "POST",
++      "path": "/api/v1/broadcast/send",
++      "auth": "JWT",
++      "request": {
++        "template_id": { "type": "integer", "required": true, "desc": "Template ID to use" },
++        "recipients": {
++          "type": "array",
++          "required": true,
++          "max_items": 1000,
++          "item": {
++            "phone": { "type": "string", "required": true, "desc": "E.164 format phone" },
++            "variables": { "type": "object", "required": false, "desc": "Template variables per recipient" }
++          }
++        },
++        "scheduled_at": { "type": "string", "format": "ISO8601", "required": false, "desc": "One-time scheduled send" }
++      },
++      "response_202": {
++        "broadcast_id": "uuid",
++        "total_recipients": "integer",
++        "queued": "integer",
++        "skipped_optout": "integer"
++      }
++    },
++
++    "broadcast_status": {
++      "method": "GET",
++      "path": "/api/v1/broadcast/{broadcastId}/status",
++      "auth": "JWT",
++      "response_200": {
++        "broadcast_id": "uuid",
++        "status": "queued|processing|completed|failed",
++        "total_recipients": "integer",
++        "queued": "integer",
++        "sent": "integer",
++        "delivered": "integer",
++        "read": "integer",
++        "failed": "integer",
++        "created_at": "ISO8601",
++        "started_at": "ISO8601|null",
++        "completed_at": "ISO8601|null"
++      }
++    },
++
++    "webhook_trigger": {
++      "method": "POST",
++      "path": "/api/v1/webhook/trigger",
++      "auth": "JWT",
++      "request": {
++        "event": { "type": "string", "required": true, "desc": "new_lead|payment_received|appointment_reminder" },
++        "phone": { "type": "string", "required": true, "desc": "Recipient phone" },
++        "variables": { "type": "object", "required": false, "desc": "Template variables" }
++      },
++      "response_202": {
++        "message_id": "bigint",
++        "template_id": "integer",
++        "template_name": "string"
++      },
++      "response_404": {
++        "error_code": "INV-OB-008",
++        "message": "No matching trigger template"
++      }
++    },
++
++    "webhook_delivery_status": {
++      "method": "POST",
++      "path": "/api/v1/webhook/delivery-status",
++      "auth": "JWT",
++      "request": {
++        "external_message_id": { "type": "string", "required": true },
++        "status": { "type": "string", "required": true, "desc": "sent|delivered|read|failed" },
++        "failed_reason": { "type": "string", "required": false },
++        "timestamp": { "type": "string", "format": "ISO8601", "required": false }
++      },
++      "response_200": {
++        "updated": "boolean"
++      }
++    },
++
++    "webhook_message": {
++      "method": "POST",
++      "path": "/api/v1/webhook/message",
++      "auth": "JWT",
++      "request": {
++        "phone": { "type": "string", "required": true },
++        "message_text": { "type": "string", "required": true }
++      },
++      "response_200": {
++        "opted_out": "boolean",
++        "keyword_matched": "string|null"
++      }
++    },
++
++    "templates_list": {
++      "method": "GET",
++      "path": "/api/v1/templates",
++      "auth": "JWT",
++      "response_200": {
++        "templates": [{
++          "id": "integer",
++          "name": "string",
++          "trigger_event": "string",
++          "message_template": "string",
++          "variables_json": "object|null",
++          "is_active": "boolean",
++          "created_at": "ISO8601",
++          "updated_at": "ISO8601"
++        }]
++      }
++    },
++
++    "template_create": {
++      "method": "POST",
++      "path": "/api/v1/templates",
++      "auth": "JWT",
++      "request": {
++        "name": { "type": "string", "required": true, "max_length": 200 },
++        "trigger_event": { "type": "string", "required": false, "default": "manual" },
++        "message_template": { "type": "string", "required": true },
++        "variables_json": { "type": "object", "required": false }
++      },
++      "response_201": {
++        "id": "integer",
++        "name": "string"
++      }
++    },
++
++    "template_update": {
++      "method": "PUT",
++      "path": "/api/v1/templates/{id}",
++      "auth": "JWT",
++      "request": {
++        "name": { "type": "string", "required": false },
++        "trigger_event": { "type": "string", "required": false },
++        "message_template": { "type": "string", "required": false },
++        "variables_json": { "type": "object", "required": false }
++      },
++      "response_200": {
++        "id": "integer",
++        "updated": true
++      }
++    },
++
++    "template_delete": {
++      "method": "DELETE",
++      "path": "/api/v1/templates/{id}",
++      "auth": "JWT",
++      "desc": "Soft delete: sets is_active=false",
++      "response_200": {
++        "id": "integer",
++        "deactivated": true
++      }
++    },
++
++    "optout_add": {
++      "method": "POST",
++      "path": "/api/v1/optout",
++      "auth": "JWT",
++      "request": {
++        "phone": { "type": "string", "required": true },
++        "reason": { "type": "string", "required": false }
++      },
++      "response_200": {
++        "phone": "string",
++        "opted_out": true
++      }
++    },
++
++    "optout_remove": {
++      "method": "DELETE",
++      "path": "/api/v1/optout/{phone}",
++      "auth": "JWT",
++      "response_200": {
++        "phone": "string",
++        "removed": true
++      }
++    },
++
++    "optout_check": {
++      "method": "GET",
++      "path": "/api/v1/optout/check/{phone}",
++      "auth": "JWT",
++      "response_200": {
++        "phone": "string",
++        "opted_out": "boolean",
++        "opted_out_at": "ISO8601|null"
++      }
++    }
++  },
++
++  "stop_keywords": ["STOP", "DUR", "ΓöÇΓûæPTAL", "IPTAL", "DURDU", "Γö£├ºIKIΓö╝Γéº", "CIKIS"]
++}
+diff --git a/arch/db/outbound.sql b/arch/db/outbound.sql
+new file mode 100644
+index 0000000..5e83809
+--- /dev/null
++++ b/arch/db/outbound.sql
+@@ -0,0 +1,139 @@
++-- =============================================================
++-- Invekto.Outbound Database Schema
++-- Service: Invekto.Outbound (port 7107)
++-- Database: invekto (PostgreSQL, shared instance)
++-- Convention: snake_case for all identifiers
++-- =============================================================
++
++-- Depends on: tenant-registry.sql (tenant_registry table)
++
++-- =============================================================
++-- outbound_templates: Message templates for broadcasts & triggers
++-- =============================================================
++
++CREATE TABLE IF NOT EXISTS outbound_templates (
++    id                      SERIAL PRIMARY KEY,
++    tenant_id               INTEGER NOT NULL REFERENCES tenant_registry(tenant_id),
++    name                    VARCHAR(200) NOT NULL,
++    trigger_event           VARCHAR(50) NOT NULL DEFAULT 'manual',
++    message_template        TEXT NOT NULL,
++    variables_json          JSONB,
++    is_active               BOOLEAN NOT NULL DEFAULT TRUE,
++    created_at              TIMESTAMPTZ NOT NULL DEFAULT NOW(),
++    updated_at              TIMESTAMPTZ NOT NULL DEFAULT NOW(),
++
++    -- trigger_event values: manual, new_lead, payment_received, appointment_reminder
++    CONSTRAINT chk_trigger_event CHECK (trigger_event IN ('manual', 'new_lead', 'payment_received', 'appointment_reminder'))
++);
++
++CREATE INDEX IF NOT EXISTS idx_outbound_templates_tenant_active
++    ON outbound_templates (tenant_id, is_active) WHERE is_active = TRUE;
++
++CREATE INDEX IF NOT EXISTS idx_outbound_templates_tenant_trigger
++    ON outbound_templates (tenant_id, trigger_event) WHERE is_active = TRUE;
++
++-- =============================================================
++-- outbound_broadcasts: Broadcast job records
++-- =============================================================
++
++CREATE TABLE IF NOT EXISTS outbound_broadcasts (
++    id                      UUID PRIMARY KEY DEFAULT gen_random_uuid(),
++    tenant_id               INTEGER NOT NULL REFERENCES tenant_registry(tenant_id),
++    template_id             INTEGER REFERENCES outbound_templates(id),
++    total_recipients        INTEGER NOT NULL DEFAULT 0,
++    queued                  INTEGER NOT NULL DEFAULT 0,
++    sent                    INTEGER NOT NULL DEFAULT 0,
++    delivered               INTEGER NOT NULL DEFAULT 0,
++    read                    INTEGER NOT NULL DEFAULT 0,
++    failed                  INTEGER NOT NULL DEFAULT 0,
++    status                  VARCHAR(20) NOT NULL DEFAULT 'queued',
++    scheduled_at            TIMESTAMPTZ,
++    started_at              TIMESTAMPTZ,
++    completed_at            TIMESTAMPTZ,
++    created_at              TIMESTAMPTZ NOT NULL DEFAULT NOW(),
++
++    -- status values: queued, processing, completed, failed
++    CONSTRAINT chk_broadcast_status CHECK (status IN ('queued', 'processing', 'completed', 'failed'))
++);
++
++CREATE INDEX IF NOT EXISTS idx_outbound_broadcasts_tenant_created
++    ON outbound_broadcasts (tenant_id, created_at DESC);
++
++CREATE INDEX IF NOT EXISTS idx_outbound_broadcasts_status
++    ON outbound_broadcasts (status) WHERE status IN ('queued', 'processing');
++
++-- =============================================================
++-- outbound_messages: Individual message records in a broadcast
++-- =============================================================
++
++CREATE TABLE IF NOT EXISTS outbound_messages (
++    id                      BIGSERIAL PRIMARY KEY,
++    tenant_id               INTEGER NOT NULL REFERENCES tenant_registry(tenant_id),
++    broadcast_id            UUID REFERENCES outbound_broadcasts(id),
++    template_id             INTEGER REFERENCES outbound_templates(id),
++    recipient_phone         VARCHAR(20) NOT NULL,
++    message_text            TEXT NOT NULL,
++    status                  VARCHAR(20) NOT NULL DEFAULT 'queued',
++    external_message_id     VARCHAR(100),
++    sent_at                 TIMESTAMPTZ,
++    delivered_at            TIMESTAMPTZ,
++    read_at                 TIMESTAMPTZ,
++    failed_reason           VARCHAR(500),
++    created_at              TIMESTAMPTZ NOT NULL DEFAULT NOW(),
++
++    -- status values: queued, sending, sent, delivered, read, failed
++    -- broadcast_id is NULL for trigger-based single messages
++    CONSTRAINT chk_message_status CHECK (status IN ('queued', 'sending', 'sent', 'delivered', 'read', 'failed'))
++);
++
++CREATE INDEX IF NOT EXISTS idx_outbound_messages_tenant_created
++    ON outbound_messages (tenant_id, created_at DESC);
++
++CREATE INDEX IF NOT EXISTS idx_outbound_messages_broadcast_status
++    ON outbound_messages (broadcast_id, status);
++
++CREATE INDEX IF NOT EXISTS idx_outbound_messages_queued
++    ON outbound_messages (status, created_at) WHERE status = 'queued';
++
++CREATE INDEX IF NOT EXISTS idx_outbound_messages_external_id
++    ON outbound_messages (external_message_id) WHERE external_message_id IS NOT NULL;
++
++-- =============================================================
++-- outbound_optouts: Opt-out registry per tenant+phone
++-- =============================================================
++
++CREATE TABLE IF NOT EXISTS outbound_optouts (
++    id                      SERIAL PRIMARY KEY,
++    tenant_id               INTEGER NOT NULL REFERENCES tenant_registry(tenant_id),
++    phone                   VARCHAR(20) NOT NULL,
++    reason                  VARCHAR(200),
++    created_at              TIMESTAMPTZ NOT NULL DEFAULT NOW(),
++
++    -- One opt-out record per phone per tenant
++    CONSTRAINT uq_optout_tenant_phone UNIQUE (tenant_id, phone)
++);
++
++-- =============================================================
++-- Grants (run after creating tables)
++-- =============================================================
++
++GRANT SELECT, INSERT, UPDATE, DELETE ON outbound_templates TO invekto;
++GRANT SELECT, INSERT, UPDATE, DELETE ON outbound_broadcasts TO invekto;
++GRANT SELECT, INSERT, UPDATE, DELETE ON outbound_messages TO invekto;
++GRANT SELECT, INSERT, UPDATE, DELETE ON outbound_optouts TO invekto;
++GRANT USAGE, SELECT ON SEQUENCE outbound_templates_id_seq TO invekto;
++GRANT USAGE, SELECT ON SEQUENCE outbound_messages_id_seq TO invekto;
++GRANT USAGE, SELECT ON SEQUENCE outbound_optouts_id_seq TO invekto;
++
++-- =============================================================
++-- Usage Notes
++-- =============================================================
++--
++-- 1. outbound_templates: trigger_event='manual' for broadcast-only templates
++-- 2. outbound_broadcasts: counter columns (queued/sent/delivered/read/failed)
++--    are updated atomically via UPDATE ... SET sent = sent + 1
++-- 3. outbound_messages: broadcast_id is NULL for trigger-based single messages
++-- 4. outbound_optouts: checked before every message send, UNIQUE prevents duplicates
++-- 5. Rate limiting is handled in-memory (per tenant msg/minute), not in DB
++-- 6. external_message_id links to WapCRM/WhatsApp message ID for delivery tracking
++-- =============================================================
+diff --git a/arch/deploy/appsettings.Production.Backend.json b/arch/deploy/appsettings.Production.Backend.json
+index c09400a..deb0b90 100644
+--- a/arch/deploy/appsettings.Production.Backend.json
++++ b/arch/deploy/appsettings.Production.Backend.json
+@@ -24,6 +24,11 @@
+       "Url": "http://localhost:7105",
+       "LogPath": "E:\\Invekto\\AgentAI\\logs",
+       "SuggestTimeoutMs": 15000
++    },
++    "Outbound": {
++      "Url": "http://localhost:7107",
++      "LogPath": "E:\\Invekto\\Outbound\\logs",
++      "TimeoutMs": 10000
+     }
+   },
+   "Jwt": {
+diff --git a/arch/deploy/deploy-watcher.ps1 b/arch/deploy/deploy-watcher.ps1
+index d057110..736b90d 100644
+--- a/arch/deploy/deploy-watcher.ps1
++++ b/arch/deploy/deploy-watcher.ps1
+@@ -6,7 +6,7 @@
+ 
+ $watchPath = "E:\Invekto"
+ $nssm = "E:\nssm.exe"
+-$services = @("InvektoBackend", "InvektoChatAnalysis", "InvektoAutomation", "InvektoAgentAI")
++$services = @("InvektoBackend", "InvektoChatAnalysis", "InvektoAutomation", "InvektoAgentAI", "InvektoOutbound")
+ $logFile = "E:\Invekto\logs\deploy-watcher.log"
+ 
+ # Ensure log directory exists
+diff --git a/arch/deploy/firewall-rules.bat b/arch/deploy/firewall-rules.bat
+index 69315f2..43e993f 100644
+--- a/arch/deploy/firewall-rules.bat
++++ b/arch/deploy/firewall-rules.bat
+@@ -17,6 +17,9 @@ netsh advfirewall firewall add rule name="Invekto ChatAnalysis (TCP 7101)" dir=i
+ REM AgentAI (port 7105) - Localhost only (Backend proxies, not direct external access)
+ netsh advfirewall firewall add rule name="Invekto AgentAI (TCP 7105)" dir=in action=allow protocol=tcp localport=7105 profile=any remoteip=127.0.0.1
+ 
++REM Outbound (port 7107) - Localhost only (Backend proxies, not direct external access)
++netsh advfirewall firewall add rule name="Invekto Outbound (TCP 7107)" dir=in action=allow protocol=tcp localport=7107 profile=any remoteip=127.0.0.1
++
+ REM Automation (port 7108) - External access (Main App webhooks)
+ netsh advfirewall firewall add rule name="Invekto Automation (TCP 7108)" dir=in action=allow protocol=tcp localport=7108 profile=any
+ 
+@@ -33,6 +36,7 @@ echo    4500  Simulator     (external)
+ echo    5000  Backend       (external)
+ echo    7101  ChatAnalysis  (localhost only)
+ echo    7105  AgentAI       (localhost only)
++echo    7107  Outbound      (localhost only)
+ echo    7108  Automation    (external)
+ echo    5432  PostgreSQL    (localhost only)
+ echo ============================================
+diff --git a/arch/deploy/install-services.bat b/arch/deploy/install-services.bat
+index 02e28be..c0e9716 100644
+--- a/arch/deploy/install-services.bat
++++ b/arch/deploy/install-services.bat
+@@ -13,7 +13,7 @@ echo ============================================
+ echo.
+ 
+ REM Backend Service
+-echo [1/4] Installing InvektoBackend...
++echo [1/5] Installing InvektoBackend...
+ %NSSM% install InvektoBackend "E:\Invekto\Backend\current\Invekto.Backend.exe"
+ %NSSM% set InvektoBackend DisplayName "Invekto Backend"
+ %NSSM% set InvektoBackend Description "Invekto Backend API - Port 5000"
+@@ -32,7 +32,7 @@ echo [OK] InvektoBackend installed
+ echo.
+ 
+ REM ChatAnalysis Service
+-echo [2/4] Installing InvektoChatAnalysis...
++echo [2/5] Installing InvektoChatAnalysis...
+ %NSSM% install InvektoChatAnalysis "E:\Invekto\ChatAnalysis\current\Invekto.ChatAnalysis.exe"
+ %NSSM% set InvektoChatAnalysis DisplayName "Invekto ChatAnalysis"
+ %NSSM% set InvektoChatAnalysis Description "Invekto Chat Analysis Microservice - Port 7101"
+@@ -51,7 +51,7 @@ echo [OK] InvektoChatAnalysis installed
+ echo.
+ 
+ REM Automation Service
+-echo [3/4] Installing InvektoAutomation...
++echo [3/5] Installing InvektoAutomation...
+ %NSSM% install InvektoAutomation "E:\Invekto\Automation\current\Invekto.Automation.exe"
+ %NSSM% set InvektoAutomation DisplayName "Invekto Automation"
+ %NSSM% set InvektoAutomation Description "Invekto Automation Chatbot/Flow Builder - Port 7108"
+@@ -70,7 +70,7 @@ echo [OK] InvektoAutomation installed
+ echo.
+ 
+ REM AgentAI Service
+-echo [4/4] Installing InvektoAgentAI...
++echo [4/5] Installing InvektoAgentAI...
+ %NSSM% install InvektoAgentAI "E:\Invekto\AgentAI\current\Invekto.AgentAI.exe"
+ %NSSM% set InvektoAgentAI DisplayName "Invekto AgentAI"
+ %NSSM% set InvektoAgentAI Description "Invekto AI Agent Assist Microservice - Port 7105"
+@@ -88,11 +88,31 @@ echo [4/4] Installing InvektoAgentAI...
+ echo [OK] InvektoAgentAI installed
+ echo.
+ 
++REM Outbound Service
++echo [5/5] Installing InvektoOutbound...
++%NSSM% install InvektoOutbound "E:\Invekto\Outbound\current\Invekto.Outbound.exe"
++%NSSM% set InvektoOutbound DisplayName "Invekto Outbound"
++%NSSM% set InvektoOutbound Description "Invekto Outbound Broadcast Messaging - Port 7107"
++%NSSM% set InvektoOutbound AppDirectory "E:\Invekto\Outbound\current"
++%NSSM% set InvektoOutbound AppEnvironmentExtra "ASPNETCORE_ENVIRONMENT=Production"
++%NSSM% set InvektoOutbound AppStdout "E:\Invekto\Outbound\logs\service-stdout.log"
++%NSSM% set InvektoOutbound AppStderr "E:\Invekto\Outbound\logs\service-stderr.log"
++%NSSM% set InvektoOutbound AppStdoutCreationDisposition 4
++%NSSM% set InvektoOutbound AppStderrCreationDisposition 4
++%NSSM% set InvektoOutbound AppRotateFiles 1
++%NSSM% set InvektoOutbound AppRotateBytes 10485760
++%NSSM% set InvektoOutbound Start SERVICE_AUTO_START
++%NSSM% set InvektoOutbound AppExit Default Restart
++%NSSM% set InvektoOutbound AppRestartDelay 5000
++echo [OK] InvektoOutbound installed
++echo.
++
+ REM Create log directories
+ if not exist "E:\Invekto\Backend\logs" mkdir "E:\Invekto\Backend\logs"
+ if not exist "E:\Invekto\ChatAnalysis\logs" mkdir "E:\Invekto\ChatAnalysis\logs"
+ if not exist "E:\Invekto\Automation\logs" mkdir "E:\Invekto\Automation\logs"
+ if not exist "E:\Invekto\AgentAI\logs" mkdir "E:\Invekto\AgentAI\logs"
++if not exist "E:\Invekto\Outbound\logs" mkdir "E:\Invekto\Outbound\logs"
+ 
+ REM Start services
+ echo Starting services...
+@@ -104,6 +124,8 @@ timeout /t 3 /nobreak >nul
+ timeout /t 3 /nobreak >nul
+ %NSSM% start InvektoAgentAI
+ timeout /t 3 /nobreak >nul
++%NSSM% start InvektoOutbound
++timeout /t 3 /nobreak >nul
+ 
+ echo.
+ echo ============================================
+@@ -115,11 +137,13 @@ echo Services:
+ %NSSM% status InvektoChatAnalysis
+ %NSSM% status InvektoAutomation
+ %NSSM% status InvektoAgentAI
++%NSSM% status InvektoOutbound
+ echo.
+ echo Test:
+ echo   http://localhost:5000/health
+ echo   http://localhost:7101/health
+ echo   http://localhost:7105/health
++echo   http://localhost:7107/health
+ echo   http://localhost:7108/health
+ echo.
+ echo Manage:
+@@ -127,5 +151,6 @@ echo   %NSSM% edit InvektoBackend
+ echo   %NSSM% edit InvektoChatAnalysis
+ echo   %NSSM% edit InvektoAutomation
+ echo   %NSSM% edit InvektoAgentAI
++echo   %NSSM% edit InvektoOutbound
+ echo.
+ pause
+diff --git a/arch/deploy/restart-services.bat b/arch/deploy/restart-services.bat
+index 90e6f2b..7bd4dfe 100644
+--- a/arch/deploy/restart-services.bat
++++ b/arch/deploy/restart-services.bat
+@@ -12,6 +12,7 @@ echo Stopping services...
+ %NSSM% stop InvektoChatAnalysis
+ %NSSM% stop InvektoAutomation
+ %NSSM% stop InvektoAgentAI
++%NSSM% stop InvektoOutbound
+ timeout /t 3 /nobreak >nul
+ 
+ echo.
+@@ -24,6 +25,8 @@ timeout /t 2 /nobreak >nul
+ timeout /t 2 /nobreak >nul
+ %NSSM% start InvektoAgentAI
+ timeout /t 2 /nobreak >nul
++%NSSM% start InvektoOutbound
++timeout /t 2 /nobreak >nul
+ 
+ echo.
+ echo Status:
+@@ -31,10 +34,12 @@ echo Status:
+ %NSSM% status InvektoChatAnalysis
+ %NSSM% status InvektoAutomation
+ %NSSM% status InvektoAgentAI
++%NSSM% status InvektoOutbound
+ echo.
+ echo Test: http://localhost:5000/health
+ echo Test: http://localhost:7101/health
+-echo Test: http://localhost:7108/health
+ echo Test: http://localhost:7105/health
++echo Test: http://localhost:7107/health
++echo Test: http://localhost:7108/health
+ echo.
+ pause
+diff --git a/arch/errors.md b/arch/errors.md
+index 602fb38..9fb5479 100644
+--- a/arch/errors.md
++++ b/arch/errors.md
+@@ -25,6 +25,7 @@ INV-{SERVICE}-{NUMBER}
+ | INT | Integration | GR-1.9: Entegrasyon kΓö£ΓòóprΓö£Γò¥sΓö£Γò¥ hatalarΓöÇΓûÆ |
+ | DB | Database | VeritabanΓöÇΓûÆ hatalarΓöÇΓûÆ |
+ | VAL | Validation | Validasyon hatalarΓöÇΓûÆ |
++| OB | Outbound | GR-1.3: Broadcast & trigger engine hatalarΓöÇΓûÆ |
+ | EXT | External | DΓöÇΓûÆΓö╝╞Æ servis hatalarΓöÇΓûÆ |
+ 
+ ---
+@@ -131,6 +132,23 @@ INV-{SERVICE}-{NUMBER}
+ 
+ ---
+ 
++## OB - Outbound Errors (GR-1.3)
++
++| Code | Description | User Message |
++|------|-------------|--------------|
++| INV-OB-001 | Invalid broadcast payload | Gecersiz toplu mesaj istegi. |
++| INV-OB-002 | Template not found | Mesaj sablonu bulunamadi. |
++| INV-OB-003 | Rate limit exceeded (queued) | Gonderim limiti asildi, mesajlar kuyrukta bekliyor. |
++| INV-OB-004 | Recipient opted out | Alici mesaj almak istemiyor (opt-out). |
++| INV-OB-005 | Broadcast not found | Toplu mesaj kaydi bulunamadi. |
++| INV-OB-006 | Delivery status update failed | Teslimat durumu guncellenemedi. |
++| INV-OB-007 | Invalid template payload | Gecersiz sablon formati. |
++| INV-OB-008 | No matching trigger template | Bu event icin esle&#351;en sablon bulunamadi. |
++| INV-OB-009 | Message send callback failed | Mesaj gonderim callback'i basarisiz oldu. |
++| INV-OB-010 | Too many recipients (max 1000) | Alici sayisi siniri asildi (max 1000). |
++
++---
++
+ ## EXT - External Service Errors
+ 
+ | Code | Description | User Message |
+diff --git a/arch/plans/20260212-outbound-service.json b/arch/plans/20260212-outbound-service.json
+new file mode 100644
+index 0000000..c9755d4
+--- /dev/null
++++ b/arch/plans/20260212-outbound-service.json
+@@ -0,0 +1,313 @@
++{
++  "slug": "20260212-outbound-service",
++  "title": "GR-1.3: Invekto.Outbound Broadcast & Trigger Engine",
++  "status": "REVIEW",
++  "risk": "HIGH",
++  "iteration": 0,
++  "created_at": "2026-02-12",
++  "summary": "Yeni Invekto.Outbound mikroservisi (Port 7107): toplu mesaj gΓö£Γòónderimi, event-based trigger engine, template engine ({{var}}), tenant-bazlΓöÇΓûÆ rate limiting ile kuyruk, opt-out yΓö£Γòónetimi (STOP keyword detection), delivery status tracking. Callback pattern ile mesaj gΓö£Γòónderimi (Outbound ╬ô├Ñ├å Main App ╬ô├Ñ├å WapCRM).",
++
++  "interview_decisions": {
++    "send_flow": "Callback pattern: Outbound kuyruΓöÇ╞Æa alΓöÇΓûÆr ╬ô├Ñ├å Main App'e send_message callback ╬ô├Ñ├å Main App WapCRM'e gΓö£Γòónderir",
++    "trigger_engine": "Webhook triggers + send_at (one-time scheduled). Full cron engine Phase 2",
++    "segment_recipient": "Main App telefon listesini gΓö£Γòónderir (max 1,000 per request). Outbound segment mantΓöÇΓûÆΓöÇ╞ÆΓöÇΓûÆ bilmez",
++    "rate_limiting": "Tenant-bazlΓöÇΓûÆ rate limit (msg/dakika). Limit aΓö╝╞ÆΓöÇΓûÆlΓöÇΓûÆnca mesaj kuyrukta bekler, reject yok",
++    "delivery_status": "Main App ╬ô├Ñ├å Outbound webhook (POST /delivery-status). Outbound DB gΓö£Γò¥nceller",
++    "template_variables": "Per-recipient variables: {phone, variables: {isim, firma}}",
++    "optout": "Main App raw mesajΓöÇΓûÆ forward eder ╬ô├Ñ├å Outbound STOP/DUR/ΓöÇΓûæPTAL keyword detect eder ve opt-out kaydΓöÇΓûÆ oluΓö╝╞Æturur",
++    "trigger_events": "Phase 1: new_lead, payment_received, appointment_reminder",
++    "batch_size": "Max 1,000 recipients per broadcast request"
++  },
++
++  "architecture": {
++    "broadcast_flow": [
++      "Main App ╬ô├Ñ├å Backend /api/v1/outbound/broadcast/send (JWT + recipients)",
++      "Backend ╬ô├Ñ├å Outbound /api/v1/broadcast/send (proxy)",
++      "Outbound: validate ╬ô├Ñ├å create broadcast record ╬ô├Ñ├å insert messages as 'queued'",
++      "Return 202 Accepted with broadcast_id",
++      "Background IHostedService dequeues messages respecting rate limit",
++      "Per message: send_message callback to Main App via MainAppCallbackClient",
++      "Main App sends via WapCRM",
++      "Main App receives delivery status ╬ô├Ñ├å forwards to Outbound",
++      "Outbound updates message status (sent/delivered/read/failed)"
++    ],
++    "trigger_flow": [
++      "Main App event occurs (new_lead, payment, etc.)",
++      "Main App ╬ô├Ñ├å Backend ╬ô├Ñ├å Outbound /api/v1/webhook/trigger",
++      "Outbound checks outbound_templates for matching trigger_event + tenant",
++      "Applies template variables from webhook data",
++      "Inserts single message as 'queued' (same rate-limited queue)",
++      "Background sender processes"
++    ],
++    "optout_flow": [
++      "Customer sends 'STOP' on WhatsApp",
++      "Main App receives ╬ô├Ñ├å forwards to Backend ╬ô├Ñ├å Outbound /api/v1/webhook/message",
++      "Outbound checks for stop keywords (STOP, DUR, ΓöÇΓûæPTAL, IPTAL, DURDU, Γö£├ºIKIΓö╝Γéº, CIKIS)",
++      "If match: create opt-out record, return {opted_out: true}",
++      "Future broadcasts skip opted-out phones"
++    ]
++  },
++
++  "db_tables": {
++    "outbound_templates": {
++      "columns": "id SERIAL PK, tenant_id INT FK, name VARCHAR(200), trigger_event VARCHAR(50), message_template TEXT, variables_json JSONB, is_active BOOL, created_at TIMESTAMPTZ, updated_at TIMESTAMPTZ",
++      "indexes": ["(tenant_id, is_active) WHERE is_active=true", "(tenant_id, trigger_event) WHERE is_active=true"],
++      "notes": "trigger_event: new_lead, payment_received, appointment_reminder, manual (for broadcast-only templates)"
++    },
++    "outbound_broadcasts": {
++      "columns": "id UUID PK, tenant_id INT FK, template_id INT, total_recipients INT, queued INT, sent INT, delivered INT, read INT, failed INT, status VARCHAR(20), scheduled_at TIMESTAMPTZ, started_at TIMESTAMPTZ, completed_at TIMESTAMPTZ, created_at TIMESTAMPTZ",
++      "indexes": ["(tenant_id, created_at DESC)", "(status) WHERE status IN ('queued','processing')"],
++      "notes": "status: queued, processing, completed, failed. Counter columns for fast status queries"
++    },
++    "outbound_messages": {
++      "columns": "id BIGSERIAL PK, tenant_id INT FK, broadcast_id UUID, template_id INT, recipient_phone VARCHAR(20), message_text TEXT, status VARCHAR(20), external_message_id VARCHAR(100), sent_at TIMESTAMPTZ, delivered_at TIMESTAMPTZ, read_at TIMESTAMPTZ, failed_reason VARCHAR(500), created_at TIMESTAMPTZ",
++      "indexes": ["(tenant_id, created_at DESC)", "(broadcast_id, status)", "(status, created_at) WHERE status='queued'", "(external_message_id) WHERE external_message_id IS NOT NULL"],
++      "notes": "status: queued, sending, sent, delivered, read, failed. broadcast_id nullable (null for trigger-based single messages)"
++    },
++    "outbound_optouts": {
++      "columns": "id SERIAL PK, tenant_id INT FK, phone VARCHAR(20), reason VARCHAR(200), created_at TIMESTAMPTZ",
++      "indexes": ["UNIQUE (tenant_id, phone)"],
++      "notes": "Unique constraint: bir phone bir tenant'ta tek opt-out kaydΓöÇΓûÆ"
++    }
++  },
++
++  "endpoints": {
++    "outbound_service": [
++      {"method": "POST", "path": "/api/v1/broadcast/send", "auth": "JWT", "response": "202", "desc": "Submit broadcast (async)"},
++      {"method": "GET", "path": "/api/v1/broadcast/{broadcastId}/status", "auth": "JWT", "response": "200", "desc": "Get broadcast delivery status"},
++      {"method": "POST", "path": "/api/v1/webhook/trigger", "auth": "JWT", "response": "202", "desc": "Receive trigger event from Main App"},
++      {"method": "POST", "path": "/api/v1/webhook/delivery-status", "auth": "JWT", "response": "200", "desc": "Receive delivery status update"},
++      {"method": "POST", "path": "/api/v1/webhook/message", "auth": "JWT", "response": "200", "desc": "Receive incoming message for opt-out detection"},
++      {"method": "GET", "path": "/api/v1/templates", "auth": "JWT", "response": "200", "desc": "List active templates"},
++      {"method": "POST", "path": "/api/v1/templates", "auth": "JWT", "response": "201", "desc": "Create template"},
++      {"method": "PUT", "path": "/api/v1/templates/{id}", "auth": "JWT", "response": "200", "desc": "Update template"},
++      {"method": "DELETE", "path": "/api/v1/templates/{id}", "auth": "JWT", "response": "200", "desc": "Deactivate template"},
++      {"method": "POST", "path": "/api/v1/optout", "auth": "JWT", "response": "200", "desc": "Manual opt-out add"},
++      {"method": "DELETE", "path": "/api/v1/optout/{phone}", "auth": "JWT", "response": "200", "desc": "Remove opt-out"},
++      {"method": "GET", "path": "/api/v1/optout/check/{phone}", "auth": "JWT", "response": "200", "desc": "Check if phone opted out"},
++      {"method": "GET", "path": "/health", "auth": "none", "response": "200", "desc": "Health check"},
++      {"method": "GET", "path": "/ready", "auth": "none", "response": "200", "desc": "Readiness probe (DB check)"},
++      {"method": "GET", "path": "/api/ops/endpoints", "auth": "none", "response": "200", "desc": "Endpoint discovery"}
++    ],
++    "backend_proxy": [
++      {"method": "POST", "path": "/api/v1/outbound/broadcast/send", "proxies_to": "/api/v1/broadcast/send"},
++      {"method": "GET", "path": "/api/v1/outbound/broadcast/{broadcastId}/status", "proxies_to": "/api/v1/broadcast/{broadcastId}/status"},
++      {"method": "POST", "path": "/api/v1/outbound/webhook/trigger", "proxies_to": "/api/v1/webhook/trigger"},
++      {"method": "POST", "path": "/api/v1/outbound/webhook/delivery-status", "proxies_to": "/api/v1/webhook/delivery-status"},
++      {"method": "POST", "path": "/api/v1/outbound/webhook/message", "proxies_to": "/api/v1/webhook/message"},
++      {"method": "GET", "path": "/api/v1/outbound/templates", "proxies_to": "/api/v1/templates"},
++      {"method": "POST", "path": "/api/v1/outbound/templates", "proxies_to": "/api/v1/templates"},
++      {"method": "PUT", "path": "/api/v1/outbound/templates/{id}", "proxies_to": "/api/v1/templates/{id}"},
++      {"method": "DELETE", "path": "/api/v1/outbound/templates/{id}", "proxies_to": "/api/v1/templates/{id}"},
++      {"method": "POST", "path": "/api/v1/outbound/optout", "proxies_to": "/api/v1/optout"},
++      {"method": "DELETE", "path": "/api/v1/outbound/optout/{phone}", "proxies_to": "/api/v1/optout/{phone}"},
++      {"method": "GET", "path": "/api/v1/outbound/optout/check/{phone}", "proxies_to": "/api/v1/optout/check/{phone}"}
++    ]
++  },
++
++  "error_codes": {
++    "INV-OB-001": "Invalid broadcast payload",
++    "INV-OB-002": "Template not found",
++    "INV-OB-003": "Rate limit exceeded (queued for later)",
++    "INV-OB-004": "Recipient opted out",
++    "INV-OB-005": "Broadcast not found",
++    "INV-OB-006": "Delivery status update failed",
++    "INV-OB-007": "Invalid template payload",
++    "INV-OB-008": "No matching trigger template",
++    "INV-OB-009": "Message send callback failed",
++    "INV-OB-010": "Too many recipients (max 1000)"
++  },
++
++  "files_to_create": [
++    "src/Invekto.Outbound/Invekto.Outbound.csproj",
++    "src/Invekto.Outbound/Program.cs",
++    "src/Invekto.Outbound/appsettings.json",
++    "src/Invekto.Outbound/Data/OutboundRepository.cs",
++    "src/Invekto.Outbound/Services/TemplateEngine.cs",
++    "src/Invekto.Outbound/Services/OptOutManager.cs",
++    "src/Invekto.Outbound/Services/RateLimiter.cs",
++    "src/Invekto.Outbound/Services/BroadcastOrchestrator.cs",
++    "src/Invekto.Outbound/Services/TriggerProcessor.cs",
++    "src/Invekto.Outbound/Services/MessageSenderService.cs",
++    "src/Invekto.Shared/DTOs/Outbound/BroadcastDtos.cs",
++    "src/Invekto.Shared/DTOs/Outbound/TemplateDtos.cs",
++    "src/Invekto.Shared/DTOs/Outbound/WebhookDtos.cs",
++    "src/Invekto.Backend/Services/OutboundClient.cs",
++    "arch/db/outbound.sql",
++    "arch/contracts/outbound-broadcast.json",
++    "src/Invekto.Outbound/appsettings.Production.json"
++  ],
++
++  "files_to_modify": [
++    "src/Invekto.Shared/Constants/ErrorCodes.cs",
++    "src/Invekto.Shared/DTOs/Integration/OutgoingCallback.cs",
++    "arch/errors.md",
++    "src/Invekto.Backend/appsettings.json",
++    "arch/deploy/appsettings.Production.Backend.json",
++    "src/Invekto.Backend/Program.cs",
++    "dev-to-invekto-services.bat",
++    "arch/deploy/install-services.bat",
++    "arch/deploy/firewall-rules.bat",
++    "arch/deploy/restart-services.bat",
++    "arch/deploy/deploy-watcher.ps1",
++    "arch/session-memory.md",
++    "arch/active-work.md"
++  ],
++
++  "implementation_steps": [
++    {
++      "step": 1,
++      "name": "Arch files + Error codes",
++      "files": ["arch/db/outbound.sql", "arch/contracts/outbound-broadcast.json", "arch/errors.md", "src/Invekto.Shared/Constants/ErrorCodes.cs"],
++      "desc": "DB schema, API contract, error code definitions"
++    },
++    {
++      "step": 2,
++      "name": "Shared DTOs + CallbackData extension",
++      "files": ["src/Invekto.Shared/DTOs/Outbound/BroadcastDtos.cs", "src/Invekto.Shared/DTOs/Outbound/TemplateDtos.cs", "src/Invekto.Shared/DTOs/Outbound/WebhookDtos.cs", "src/Invekto.Shared/DTOs/Integration/OutgoingCallback.cs"],
++      "desc": "Request/response DTOs, extend CallbackData with phone/broadcast_id/message_id"
++    },
++    {
++      "step": 3,
++      "name": "Outbound project skeleton + health endpoints",
++      "files": ["src/Invekto.Outbound/Invekto.Outbound.csproj", "src/Invekto.Outbound/Program.cs", "src/Invekto.Outbound/appsettings.json", "src/Invekto.Outbound/appsettings.Production.json"],
++      "desc": "Project file, Kestrel 7107, WindowsService, JWT, PostgreSQL, health/ready"
++    },
++    {
++      "step": 4,
++      "name": "Data layer + Services",
++      "files": ["src/Invekto.Outbound/Data/OutboundRepository.cs", "src/Invekto.Outbound/Services/TemplateEngine.cs", "src/Invekto.Outbound/Services/OptOutManager.cs", "src/Invekto.Outbound/Services/RateLimiter.cs", "src/Invekto.Outbound/Services/BroadcastOrchestrator.cs", "src/Invekto.Outbound/Services/TriggerProcessor.cs", "src/Invekto.Outbound/Services/MessageSenderService.cs"],
++      "desc": "All business logic: repository, template engine, opt-out, rate limiter, orchestrator, trigger processor, background message sender"
++    },
++    {
++      "step": 5,
++      "name": "Wire all endpoints in Program.cs",
++      "files": ["src/Invekto.Outbound/Program.cs"],
++      "desc": "Complete all API endpoints: broadcast, templates, webhooks, optout"
++    },
++    {
++      "step": 6,
++      "name": "Backend proxy + deploy scripts",
++      "files": ["src/Invekto.Backend/Services/OutboundClient.cs", "src/Invekto.Backend/Program.cs", "src/Invekto.Backend/appsettings.json", "arch/deploy/appsettings.Production.Backend.json", "dev-to-invekto-services.bat", "arch/deploy/install-services.bat", "arch/deploy/firewall-rules.bat", "arch/deploy/restart-services.bat", "arch/deploy/deploy-watcher.ps1"],
++      "desc": "Backend OutboundClient, proxy endpoints, all deploy scripts updated for Outbound"
++    },
++    {
++      "step": 7,
++      "name": "Build + arch update",
++      "files": ["arch/session-memory.md", "arch/active-work.md"],
++      "desc": "Full solution build, update session memory"
++    }
++  ],
++
++  "verification_questions": [
++    {"category": "DB_SYNC", "question": "outbound_templates, outbound_broadcasts, outbound_messages, outbound_optouts tablolarΓöÇΓûÆ outbound.sql'de doΓöÇ╞Æru tanΓöÇΓûÆmlΓöÇΓûÆ mΓöÇΓûÆ? FK, index, constraint'ler var mΓöÇΓûÆ?"},
++    {"category": "RATE_LIMIT", "question": "RateLimiter tenant-bazlΓöÇΓûÆ Γö£┬║alΓöÇΓûÆΓö╝╞ÆΓöÇΓûÆyor mu? Limit aΓö╝╞ÆΓöÇΓûÆlΓöÇΓûÆnca mesaj reject DEΓöÇΓéºΓöÇΓûæL kuyrukta bekliyor mu?"},
++    {"category": "OPT_OUT", "question": "Broadcast gΓö£Γòónderiminde opt-out check yapΓöÇΓûÆlΓöÇΓûÆyor mu? Opted-out telefona mesaj gΓö£Γòónderilmiyor mu?"},
++    {"category": "CALLBACK", "question": "send_message callback'inde phone alanΓöÇΓûÆ var mΓöÇΓûÆ? Main App hangi numaraya gΓö£ΓòóndereceΓöÇ╞Æini biliyor mu?"},
++    {"category": "TEMPLATE", "question": "Template {{var}} substitution dΓö£Γò¥zgΓö£Γò¥n Γö£┬║alΓöÇΓûÆΓö╝╞ÆΓöÇΓûÆyor mu? Eksik variable handle ediliyor mu?"},
++    {"category": "TRIGGER", "question": "Trigger webhook'u template eΓö╝╞ÆleΓö╝╞Ætirmesi yapΓöÇΓûÆyor mu? EΓö╝╞ÆleΓö╝╞Æen yoksa INV-OB-008 dΓö£ΓòónΓö£Γò¥yor mu?"},
++    {"category": "BACKGROUND", "question": "MessageSenderService IHostedService olarak register edilmiΓö╝╞Æ mi? Graceful shutdown yapΓöÇΓûÆyor mu?"},
++    {"category": "AUTH", "question": "TΓö£Γò¥m /api/v1/ endpoint'leri JWT korumalΓöÇΓûÆ mΓöÇΓûÆ? Backend proxy JWT forwarding yapΓöÇΓûÆyor mu?"},
++    {"category": "DEPLOY", "question": "TΓö£Γò¥m deploy scriptleri gΓö£Γò¥ncellendi mi? (7 dosya: deploy-bat, install, firewall, restart, watcher, Backend appsettings dev+prod)"},
++    {"category": "ERROR_CODES", "question": "INV-OB-001~010 error code'larΓöÇΓûÆ hem errors.md hem ErrorCodes.cs'de tanΓöÇΓûÆmlΓöÇΓûÆ mΓöÇΓûÆ?"}
++  ],
++
++  "aha_moments": [
++    {
++      "category": "UX",
++      "user_pain": "Toplu mesaj gΓö£Γòónderirken agent tek tek numaralara kopyala-yapΓöÇΓûÆΓö╝╞ÆtΓöÇΓûÆr yapΓöÇΓûÆyor",
++      "suggestion": "Broadcast send'den sonra gerΓö£┬║ek zamanlΓöÇΓûÆ progress bar gΓö£Γòóster (queued ╬ô├Ñ├å sent ╬ô├Ñ├å delivered yΓö£Γò¥zdeleri)",
++      "aha_moment": "Agent 'GΓö£Γòónder' basΓöÇΓûÆyor, 500 mesajΓöÇΓûÆn %'si canlΓöÇΓûÆ olarak yΓö£Γò¥kseliyor - 'vay, hepsini takip edebiliyorum!'"
++    },
++    {
++      "category": "SPEED",
++      "user_pain": "Yeni lead geldiΓöÇ╞Æinde karΓö╝╞ÆΓöÇΓûÆlama mesajΓöÇΓûÆ gΓö£Γòóndermek iΓö£┬║in birinin online olmasΓöÇΓûÆ gerekiyor",
++      "suggestion": "Trigger engine: new_lead event'i otomatik karΓö╝╞ÆΓöÇΓûÆlama mesajΓöÇΓûÆ gΓö£Γòónderir (< 5 saniye)",
++      "aha_moment": "Lead formu doldurur, 3 saniyede WhatsApp'tan 'HoΓö╝╞Æ geldiniz Ali!' mesajΓöÇΓûÆ gelir - 'bunlar Γö£┬║ok hΓöÇΓûÆzlΓöÇΓûÆ!'"
++    },
++    {
++      "category": "RELIABILITY",
++      "user_pain": "WhatsApp rate limit'e takΓöÇΓûÆlΓöÇΓûÆp mesajlar kaybolabilir",
++      "suggestion": "Rate limiter + queue: hiΓö£┬║bir mesaj kaybolmaz, sΓöÇΓûÆraya alΓöÇΓûÆnΓöÇΓûÆr ve gΓö£Γò¥venli hΓöÇΓûÆzda gΓö£Γòónderilir",
++      "aha_moment": "1000 mesajlΓöÇΓûÆk kampanya, hepsi teslim edildi, 0 kayΓöÇΓûÆp - 'gΓö£Γò¥venle gΓö£Γòónderebiliyoruz!'"
++    },
++    {
++      "category": "SALES",
++      "user_pain": "MΓö£Γò¥Γö╝╞Æteri 'STOP' yazΓöÇΓûÆnca hala mesaj almaya devam ediyor, Γö╝╞Æikayet geliyor",
++      "suggestion": "Otomatik opt-out: STOP/DUR/ΓöÇΓûæPTAL algΓöÇΓûÆlanΓöÇΓûÆr, mΓö£Γò¥Γö╝╞Æteri listelendir ve bir daha rahatsΓöÇΓûÆz edilmez",
++      "aha_moment": "MΓö£Γò¥Γö╝╞Æteri 'dur' yazar, anΓöÇΓûÆnda opt-out kaydΓöÇΓûÆ oluΓö╝╞Æur - 'yasal uyumluluk otomatik!'"
++    },
++    {
++      "category": "SUPPORT",
++      "user_pain": "Template mesajlarΓöÇΓûÆnda mΓö£Γò¥Γö╝╞Æteri adΓöÇΓûÆ yerine {{isim}} gidiyor - utanΓö£┬║ verici",
++      "suggestion": "Template engine her mesajΓöÇΓûÆ gΓö£Γòóndermeden Γö£Γòónce tΓö£Γò¥m deΓöÇ╞ÆiΓö╝╞Ækenleri kontrol eder, eksik varsa bloklar",
++      "aha_moment": "DeΓöÇ╞ÆiΓö╝╞Æken eksik olan mesaj gΓö£Γòónderilmez, agent uyarΓöÇΓûÆlΓöÇΓûÆr - 'hatalΓöÇΓûÆ mesaj mΓö£Γò¥Γö╝╞Æteriye gitmedi!'"
++    }
++  ],
++
++  "git_diff": {
++    "sha256": "1FF7F106A561916569C8EA0DB9D51478883E277C8C44CC954A9CEA50ED6A6890",
++    "full_path": "arch/plans/diffs/20260212-outbound-service.diff",
++    "stats": {
++      "insertions": 3306,
++      "deletions": 30,
++      "files_count": 33
++    }
++  },
++
++  "files_changed": [
++    {"path": "InvektoServis.sln", "is_new": false},
++    {"path": "arch/active-work.md", "is_new": false},
++    {"path": "arch/contracts/outbound-broadcast.json", "is_new": true},
++    {"path": "arch/db/outbound.sql", "is_new": true},
++    {"path": "arch/deploy/appsettings.Production.Backend.json", "is_new": false},
++    {"path": "arch/deploy/deploy-watcher.ps1", "is_new": false},
++    {"path": "arch/deploy/firewall-rules.bat", "is_new": false},
++    {"path": "arch/deploy/install-services.bat", "is_new": false},
++    {"path": "arch/deploy/restart-services.bat", "is_new": false},
++    {"path": "arch/errors.md", "is_new": false},
++    {"path": "arch/plans/20260212-outbound-service.json", "is_new": true},
++    {"path": "arch/session-memory.md", "is_new": false},
++    {"path": "dev-to-invekto-services.bat", "is_new": false},
++    {"path": "src/Invekto.Backend/Program.cs", "is_new": false},
++    {"path": "src/Invekto.Backend/Services/OutboundClient.cs", "is_new": true},
++    {"path": "src/Invekto.Backend/appsettings.json", "is_new": false},
++    {"path": "src/Invekto.Outbound/Data/OutboundRepository.cs", "is_new": true},
++    {"path": "src/Invekto.Outbound/Invekto.Outbound.csproj", "is_new": true},
++    {"path": "src/Invekto.Outbound/Middleware/JwtAuthMiddleware.cs", "is_new": true},
++    {"path": "src/Invekto.Outbound/Middleware/TrafficLoggingMiddleware.cs", "is_new": true},
++    {"path": "src/Invekto.Outbound/Program.cs", "is_new": true},
++    {"path": "src/Invekto.Outbound/Services/BroadcastOrchestrator.cs", "is_new": true},
++    {"path": "src/Invekto.Outbound/Services/MessageSenderService.cs", "is_new": true},
++    {"path": "src/Invekto.Outbound/Services/OptOutManager.cs", "is_new": true},
++    {"path": "src/Invekto.Outbound/Services/RateLimiter.cs", "is_new": true},
++    {"path": "src/Invekto.Outbound/Services/TemplateEngine.cs", "is_new": true},
++    {"path": "src/Invekto.Outbound/Services/TriggerProcessor.cs", "is_new": true},
++    {"path": "src/Invekto.Outbound/appsettings.json", "is_new": true},
++    {"path": "src/Invekto.Shared/Constants/ErrorCodes.cs", "is_new": false},
++    {"path": "src/Invekto.Shared/DTOs/Integration/OutgoingCallback.cs", "is_new": false},
++    {"path": "src/Invekto.Shared/DTOs/Outbound/BroadcastDtos.cs", "is_new": true},
++    {"path": "src/Invekto.Shared/DTOs/Outbound/TemplateDtos.cs", "is_new": true},
++    {"path": "src/Invekto.Shared/DTOs/Outbound/WebhookDtos.cs", "is_new": true}
++  ],
++
++  "build": {
++    "timestamp": "2026-02-12T20:48:00Z",
++    "result": "PASS",
++    "errors": 0,
++    "warnings": 10
++  },
++
++  "updated_at": "2026-02-12T20:50:00Z",
++
++  "codex_review": {
++    "iteration": 1,
++    "verdict": "FAIL",
++    "blocking_issues": [
++      "CQ2: Silent catch in OutboundRepository.ReadTemplateDto - malformed JSON swallowed",
++      "CQ4: Duplicate TemplateEngine between AgentAI and Outbound",
++      "CQ6: N+1 DB queries in BroadcastOrchestrator - per-recipient opt-out check + insert",
++      "Q7: Shutdown race - messages stuck in sending status after shutdown"
++    ]
++  }
++}
+diff --git a/arch/plans/diffs/20260212-outbound-service.diff b/arch/plans/diffs/20260212-outbound-service.diff
+new file mode 100644
+index 0000000..36d5edf
+--- /dev/null
++++ b/arch/plans/diffs/20260212-outbound-service.diff
+@@ -0,0 +1,3950 @@
++Γê⌐ΓòùΓöÉdiff --git a/InvektoServis.sln b/InvektoServis.sln
++index 9c98ea7..10d1026 100644
++--- a/InvektoServis.sln
+++++ b/InvektoServis.sln
++@@ -21,6 +21,8 @@ Project("{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}") = "Invekto.Automation", "src\I
++ EndProject
++ Project("{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}") = "Invekto.AgentAI", "src\Invekto.AgentAI\Invekto.AgentAI.csproj", "{B3A1D2E4-5F67-4890-AB12-CD34EF56A789}"
++ EndProject
+++Project("{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}") = "Invekto.Outbound", "src\Invekto.Outbound\Invekto.Outbound.csproj", "{20F24E9A-831F-46B9-A006-B606A5404E41}"
+++EndProject
++ Global
++ 	GlobalSection(SolutionConfigurationPlatforms) = preSolution
++ 		Debug|Any CPU = Debug|Any CPU
++@@ -58,6 +60,10 @@ Global
++ 		{B3A1D2E4-5F67-4890-AB12-CD34EF56A789}.Debug|Any CPU.Build.0 = Debug|Any CPU
++ 		{B3A1D2E4-5F67-4890-AB12-CD34EF56A789}.Release|Any CPU.ActiveCfg = Release|Any CPU
++ 		{B3A1D2E4-5F67-4890-AB12-CD34EF56A789}.Release|Any CPU.Build.0 = Release|Any CPU
+++		{20F24E9A-831F-46B9-A006-B606A5404E41}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
+++		{20F24E9A-831F-46B9-A006-B606A5404E41}.Debug|Any CPU.Build.0 = Debug|Any CPU
+++		{20F24E9A-831F-46B9-A006-B606A5404E41}.Release|Any CPU.ActiveCfg = Release|Any CPU
+++		{20F24E9A-831F-46B9-A006-B606A5404E41}.Release|Any CPU.Build.0 = Release|Any CPU
++ 	EndGlobalSection
++ 	GlobalSection(NestedProjects) = preSolution
++ 		{15F8FD75-7433-4D26-A091-8B804B50C75C} = {2D97BB8D-A179-4B02-AABE-097A26C8ECFD}
++@@ -67,5 +73,6 @@ Global
++ 		{0EDF88EB-3AA1-4437-A4EF-40AF8F8ABB20} = {4858822B-FBD3-429F-9855-560EA526C9B1}
++ 		{940E6C4F-877B-4CA4-A4F4-2BE9F6FBA5B0} = {2D97BB8D-A179-4B02-AABE-097A26C8ECFD}
++ 		{B3A1D2E4-5F67-4890-AB12-CD34EF56A789} = {2D97BB8D-A179-4B02-AABE-097A26C8ECFD}
+++		{20F24E9A-831F-46B9-A006-B606A5404E41} = {2D97BB8D-A179-4B02-AABE-097A26C8ECFD}
++ 	EndGlobalSection
++ EndGlobal
++diff --git a/arch/active-work.md b/arch/active-work.md
++index 0a881cf..3e28a1a 100644
++--- a/arch/active-work.md
+++++ b/arch/active-work.md
++@@ -6,7 +6,7 @@
++ 
++ | Slug | Status | Started | Description |
++ |------|--------|---------|-------------|
++-| (none) | - | - | - |
+++| 20260212-outbound-service | BUILD_PASS | 2026-02-12 | GR-1.3: Invekto.Outbound broadcast & trigger engine (Port 7107) - Implemented, build PASS, /rev bekliyor |
++ 
++ ---
++ 
++diff --git a/arch/contracts/outbound-broadcast.json b/arch/contracts/outbound-broadcast.json
++new file mode 100644
++index 0000000..e5d714a
++--- /dev/null
+++++ b/arch/contracts/outbound-broadcast.json
++@@ -0,0 +1,200 @@
+++{
+++  "$schema": "outbound-broadcast-contract",
+++  "version": "1.0",
+++  "service": "Invekto.Outbound",
+++  "port": 7107,
+++  "description": "Outbound broadcast, trigger, template, and opt-out API contracts",
+++
+++  "endpoints": {
+++    "broadcast_send": {
+++      "method": "POST",
+++      "path": "/api/v1/broadcast/send",
+++      "auth": "JWT",
+++      "request": {
+++        "template_id": { "type": "integer", "required": true, "desc": "Template ID to use" },
+++        "recipients": {
+++          "type": "array",
+++          "required": true,
+++          "max_items": 1000,
+++          "item": {
+++            "phone": { "type": "string", "required": true, "desc": "E.164 format phone" },
+++            "variables": { "type": "object", "required": false, "desc": "Template variables per recipient" }
+++          }
+++        },
+++        "scheduled_at": { "type": "string", "format": "ISO8601", "required": false, "desc": "One-time scheduled send" }
+++      },
+++      "response_202": {
+++        "broadcast_id": "uuid",
+++        "total_recipients": "integer",
+++        "queued": "integer",
+++        "skipped_optout": "integer"
+++      }
+++    },
+++
+++    "broadcast_status": {
+++      "method": "GET",
+++      "path": "/api/v1/broadcast/{broadcastId}/status",
+++      "auth": "JWT",
+++      "response_200": {
+++        "broadcast_id": "uuid",
+++        "status": "queued|processing|completed|failed",
+++        "total_recipients": "integer",
+++        "queued": "integer",
+++        "sent": "integer",
+++        "delivered": "integer",
+++        "read": "integer",
+++        "failed": "integer",
+++        "created_at": "ISO8601",
+++        "started_at": "ISO8601|null",
+++        "completed_at": "ISO8601|null"
+++      }
+++    },
+++
+++    "webhook_trigger": {
+++      "method": "POST",
+++      "path": "/api/v1/webhook/trigger",
+++      "auth": "JWT",
+++      "request": {
+++        "event": { "type": "string", "required": true, "desc": "new_lead|payment_received|appointment_reminder" },
+++        "phone": { "type": "string", "required": true, "desc": "Recipient phone" },
+++        "variables": { "type": "object", "required": false, "desc": "Template variables" }
+++      },
+++      "response_202": {
+++        "message_id": "bigint",
+++        "template_id": "integer",
+++        "template_name": "string"
+++      },
+++      "response_404": {
+++        "error_code": "INV-OB-008",
+++        "message": "No matching trigger template"
+++      }
+++    },
+++
+++    "webhook_delivery_status": {
+++      "method": "POST",
+++      "path": "/api/v1/webhook/delivery-status",
+++      "auth": "JWT",
+++      "request": {
+++        "external_message_id": { "type": "string", "required": true },
+++        "status": { "type": "string", "required": true, "desc": "sent|delivered|read|failed" },
+++        "failed_reason": { "type": "string", "required": false },
+++        "timestamp": { "type": "string", "format": "ISO8601", "required": false }
+++      },
+++      "response_200": {
+++        "updated": "boolean"
+++      }
+++    },
+++
+++    "webhook_message": {
+++      "method": "POST",
+++      "path": "/api/v1/webhook/message",
+++      "auth": "JWT",
+++      "request": {
+++        "phone": { "type": "string", "required": true },
+++        "message_text": { "type": "string", "required": true }
+++      },
+++      "response_200": {
+++        "opted_out": "boolean",
+++        "keyword_matched": "string|null"
+++      }
+++    },
+++
+++    "templates_list": {
+++      "method": "GET",
+++      "path": "/api/v1/templates",
+++      "auth": "JWT",
+++      "response_200": {
+++        "templates": [{
+++          "id": "integer",
+++          "name": "string",
+++          "trigger_event": "string",
+++          "message_template": "string",
+++          "variables_json": "object|null",
+++          "is_active": "boolean",
+++          "created_at": "ISO8601",
+++          "updated_at": "ISO8601"
+++        }]
+++      }
+++    },
+++
+++    "template_create": {
+++      "method": "POST",
+++      "path": "/api/v1/templates",
+++      "auth": "JWT",
+++      "request": {
+++        "name": { "type": "string", "required": true, "max_length": 200 },
+++        "trigger_event": { "type": "string", "required": false, "default": "manual" },
+++        "message_template": { "type": "string", "required": true },
+++        "variables_json": { "type": "object", "required": false }
+++      },
+++      "response_201": {
+++        "id": "integer",
+++        "name": "string"
+++      }
+++    },
+++
+++    "template_update": {
+++      "method": "PUT",
+++      "path": "/api/v1/templates/{id}",
+++      "auth": "JWT",
+++      "request": {
+++        "name": { "type": "string", "required": false },
+++        "trigger_event": { "type": "string", "required": false },
+++        "message_template": { "type": "string", "required": false },
+++        "variables_json": { "type": "object", "required": false }
+++      },
+++      "response_200": {
+++        "id": "integer",
+++        "updated": true
+++      }
+++    },
+++
+++    "template_delete": {
+++      "method": "DELETE",
+++      "path": "/api/v1/templates/{id}",
+++      "auth": "JWT",
+++      "desc": "Soft delete: sets is_active=false",
+++      "response_200": {
+++        "id": "integer",
+++        "deactivated": true
+++      }
+++    },
+++
+++    "optout_add": {
+++      "method": "POST",
+++      "path": "/api/v1/optout",
+++      "auth": "JWT",
+++      "request": {
+++        "phone": { "type": "string", "required": true },
+++        "reason": { "type": "string", "required": false }
+++      },
+++      "response_200": {
+++        "phone": "string",
+++        "opted_out": true
+++      }
+++    },
+++
+++    "optout_remove": {
+++      "method": "DELETE",
+++      "path": "/api/v1/optout/{phone}",
+++      "auth": "JWT",
+++      "response_200": {
+++        "phone": "string",
+++        "removed": true
+++      }
+++    },
+++
+++    "optout_check": {
+++      "method": "GET",
+++      "path": "/api/v1/optout/check/{phone}",
+++      "auth": "JWT",
+++      "response_200": {
+++        "phone": "string",
+++        "opted_out": "boolean",
+++        "opted_out_at": "ISO8601|null"
+++      }
+++    }
+++  },
+++
+++  "stop_keywords": ["STOP", "DUR", "╬ô├╢├ç╬ô├╗├ªPTAL", "IPTAL", "DURDU", "╬ô├╢┬úΓö£┬║IKI╬ô├╢Γò¥╬ô├⌐┬║", "CIKIS"]
+++}
++diff --git a/arch/db/outbound.sql b/arch/db/outbound.sql
++new file mode 100644
++index 0000000..5e83809
++--- /dev/null
+++++ b/arch/db/outbound.sql
++@@ -0,0 +1,139 @@
+++-- =============================================================
+++-- Invekto.Outbound Database Schema
+++-- Service: Invekto.Outbound (port 7107)
+++-- Database: invekto (PostgreSQL, shared instance)
+++-- Convention: snake_case for all identifiers
+++-- =============================================================
+++
+++-- Depends on: tenant-registry.sql (tenant_registry table)
+++
+++-- =============================================================
+++-- outbound_templates: Message templates for broadcasts & triggers
+++-- =============================================================
+++
+++CREATE TABLE IF NOT EXISTS outbound_templates (
+++    id                      SERIAL PRIMARY KEY,
+++    tenant_id               INTEGER NOT NULL REFERENCES tenant_registry(tenant_id),
+++    name                    VARCHAR(200) NOT NULL,
+++    trigger_event           VARCHAR(50) NOT NULL DEFAULT 'manual',
+++    message_template        TEXT NOT NULL,
+++    variables_json          JSONB,
+++    is_active               BOOLEAN NOT NULL DEFAULT TRUE,
+++    created_at              TIMESTAMPTZ NOT NULL DEFAULT NOW(),
+++    updated_at              TIMESTAMPTZ NOT NULL DEFAULT NOW(),
+++
+++    -- trigger_event values: manual, new_lead, payment_received, appointment_reminder
+++    CONSTRAINT chk_trigger_event CHECK (trigger_event IN ('manual', 'new_lead', 'payment_received', 'appointment_reminder'))
+++);
+++
+++CREATE INDEX IF NOT EXISTS idx_outbound_templates_tenant_active
+++    ON outbound_templates (tenant_id, is_active) WHERE is_active = TRUE;
+++
+++CREATE INDEX IF NOT EXISTS idx_outbound_templates_tenant_trigger
+++    ON outbound_templates (tenant_id, trigger_event) WHERE is_active = TRUE;
+++
+++-- =============================================================
+++-- outbound_broadcasts: Broadcast job records
+++-- =============================================================
+++
+++CREATE TABLE IF NOT EXISTS outbound_broadcasts (
+++    id                      UUID PRIMARY KEY DEFAULT gen_random_uuid(),
+++    tenant_id               INTEGER NOT NULL REFERENCES tenant_registry(tenant_id),
+++    template_id             INTEGER REFERENCES outbound_templates(id),
+++    total_recipients        INTEGER NOT NULL DEFAULT 0,
+++    queued                  INTEGER NOT NULL DEFAULT 0,
+++    sent                    INTEGER NOT NULL DEFAULT 0,
+++    delivered               INTEGER NOT NULL DEFAULT 0,
+++    read                    INTEGER NOT NULL DEFAULT 0,
+++    failed                  INTEGER NOT NULL DEFAULT 0,
+++    status                  VARCHAR(20) NOT NULL DEFAULT 'queued',
+++    scheduled_at            TIMESTAMPTZ,
+++    started_at              TIMESTAMPTZ,
+++    completed_at            TIMESTAMPTZ,
+++    created_at              TIMESTAMPTZ NOT NULL DEFAULT NOW(),
+++
+++    -- status values: queued, processing, completed, failed
+++    CONSTRAINT chk_broadcast_status CHECK (status IN ('queued', 'processing', 'completed', 'failed'))
+++);
+++
+++CREATE INDEX IF NOT EXISTS idx_outbound_broadcasts_tenant_created
+++    ON outbound_broadcasts (tenant_id, created_at DESC);
+++
+++CREATE INDEX IF NOT EXISTS idx_outbound_broadcasts_status
+++    ON outbound_broadcasts (status) WHERE status IN ('queued', 'processing');
+++
+++-- =============================================================
+++-- outbound_messages: Individual message records in a broadcast
+++-- =============================================================
+++
+++CREATE TABLE IF NOT EXISTS outbound_messages (
+++    id                      BIGSERIAL PRIMARY KEY,
+++    tenant_id               INTEGER NOT NULL REFERENCES tenant_registry(tenant_id),
+++    broadcast_id            UUID REFERENCES outbound_broadcasts(id),
+++    template_id             INTEGER REFERENCES outbound_templates(id),
+++    recipient_phone         VARCHAR(20) NOT NULL,
+++    message_text            TEXT NOT NULL,
+++    status                  VARCHAR(20) NOT NULL DEFAULT 'queued',
+++    external_message_id     VARCHAR(100),
+++    sent_at                 TIMESTAMPTZ,
+++    delivered_at            TIMESTAMPTZ,
+++    read_at                 TIMESTAMPTZ,
+++    failed_reason           VARCHAR(500),
+++    created_at              TIMESTAMPTZ NOT NULL DEFAULT NOW(),
+++
+++    -- status values: queued, sending, sent, delivered, read, failed
+++    -- broadcast_id is NULL for trigger-based single messages
+++    CONSTRAINT chk_message_status CHECK (status IN ('queued', 'sending', 'sent', 'delivered', 'read', 'failed'))
+++);
+++
+++CREATE INDEX IF NOT EXISTS idx_outbound_messages_tenant_created
+++    ON outbound_messages (tenant_id, created_at DESC);
+++
+++CREATE INDEX IF NOT EXISTS idx_outbound_messages_broadcast_status
+++    ON outbound_messages (broadcast_id, status);
+++
+++CREATE INDEX IF NOT EXISTS idx_outbound_messages_queued
+++    ON outbound_messages (status, created_at) WHERE status = 'queued';
+++
+++CREATE INDEX IF NOT EXISTS idx_outbound_messages_external_id
+++    ON outbound_messages (external_message_id) WHERE external_message_id IS NOT NULL;
+++
+++-- =============================================================
+++-- outbound_optouts: Opt-out registry per tenant+phone
+++-- =============================================================
+++
+++CREATE TABLE IF NOT EXISTS outbound_optouts (
+++    id                      SERIAL PRIMARY KEY,
+++    tenant_id               INTEGER NOT NULL REFERENCES tenant_registry(tenant_id),
+++    phone                   VARCHAR(20) NOT NULL,
+++    reason                  VARCHAR(200),
+++    created_at              TIMESTAMPTZ NOT NULL DEFAULT NOW(),
+++
+++    -- One opt-out record per phone per tenant
+++    CONSTRAINT uq_optout_tenant_phone UNIQUE (tenant_id, phone)
+++);
+++
+++-- =============================================================
+++-- Grants (run after creating tables)
+++-- =============================================================
+++
+++GRANT SELECT, INSERT, UPDATE, DELETE ON outbound_templates TO invekto;
+++GRANT SELECT, INSERT, UPDATE, DELETE ON outbound_broadcasts TO invekto;
+++GRANT SELECT, INSERT, UPDATE, DELETE ON outbound_messages TO invekto;
+++GRANT SELECT, INSERT, UPDATE, DELETE ON outbound_optouts TO invekto;
+++GRANT USAGE, SELECT ON SEQUENCE outbound_templates_id_seq TO invekto;
+++GRANT USAGE, SELECT ON SEQUENCE outbound_messages_id_seq TO invekto;
+++GRANT USAGE, SELECT ON SEQUENCE outbound_optouts_id_seq TO invekto;
+++
+++-- =============================================================
+++-- Usage Notes
+++-- =============================================================
+++--
+++-- 1. outbound_templates: trigger_event='manual' for broadcast-only templates
+++-- 2. outbound_broadcasts: counter columns (queued/sent/delivered/read/failed)
+++--    are updated atomically via UPDATE ... SET sent = sent + 1
+++-- 3. outbound_messages: broadcast_id is NULL for trigger-based single messages
+++-- 4. outbound_optouts: checked before every message send, UNIQUE prevents duplicates
+++-- 5. Rate limiting is handled in-memory (per tenant msg/minute), not in DB
+++-- 6. external_message_id links to WapCRM/WhatsApp message ID for delivery tracking
+++-- =============================================================
++diff --git a/arch/deploy/appsettings.Production.Backend.json b/arch/deploy/appsettings.Production.Backend.json
++index c09400a..deb0b90 100644
++--- a/arch/deploy/appsettings.Production.Backend.json
+++++ b/arch/deploy/appsettings.Production.Backend.json
++@@ -24,6 +24,11 @@
++       "Url": "http://localhost:7105",
++       "LogPath": "E:\\Invekto\\AgentAI\\logs",
++       "SuggestTimeoutMs": 15000
+++    },
+++    "Outbound": {
+++      "Url": "http://localhost:7107",
+++      "LogPath": "E:\\Invekto\\Outbound\\logs",
+++      "TimeoutMs": 10000
++     }
++   },
++   "Jwt": {
++diff --git a/arch/deploy/deploy-watcher.ps1 b/arch/deploy/deploy-watcher.ps1
++index d057110..736b90d 100644
++--- a/arch/deploy/deploy-watcher.ps1
+++++ b/arch/deploy/deploy-watcher.ps1
++@@ -6,7 +6,7 @@
++ 
++ $watchPath = "E:\Invekto"
++ $nssm = "E:\nssm.exe"
++-$services = @("InvektoBackend", "InvektoChatAnalysis", "InvektoAutomation", "InvektoAgentAI")
+++$services = @("InvektoBackend", "InvektoChatAnalysis", "InvektoAutomation", "InvektoAgentAI", "InvektoOutbound")
++ $logFile = "E:\Invekto\logs\deploy-watcher.log"
++ 
++ # Ensure log directory exists
++diff --git a/arch/deploy/firewall-rules.bat b/arch/deploy/firewall-rules.bat
++index 69315f2..43e993f 100644
++--- a/arch/deploy/firewall-rules.bat
+++++ b/arch/deploy/firewall-rules.bat
++@@ -17,6 +17,9 @@ netsh advfirewall firewall add rule name="Invekto ChatAnalysis (TCP 7101)" dir=i
++ REM AgentAI (port 7105) - Localhost only (Backend proxies, not direct external access)
++ netsh advfirewall firewall add rule name="Invekto AgentAI (TCP 7105)" dir=in action=allow protocol=tcp localport=7105 profile=any remoteip=127.0.0.1
++ 
+++REM Outbound (port 7107) - Localhost only (Backend proxies, not direct external access)
+++netsh advfirewall firewall add rule name="Invekto Outbound (TCP 7107)" dir=in action=allow protocol=tcp localport=7107 profile=any remoteip=127.0.0.1
+++
++ REM Automation (port 7108) - External access (Main App webhooks)
++ netsh advfirewall firewall add rule name="Invekto Automation (TCP 7108)" dir=in action=allow protocol=tcp localport=7108 profile=any
++ 
++@@ -33,6 +36,7 @@ echo    4500  Simulator     (external)
++ echo    5000  Backend       (external)
++ echo    7101  ChatAnalysis  (localhost only)
++ echo    7105  AgentAI       (localhost only)
+++echo    7107  Outbound      (localhost only)
++ echo    7108  Automation    (external)
++ echo    5432  PostgreSQL    (localhost only)
++ echo ============================================
++diff --git a/arch/deploy/install-services.bat b/arch/deploy/install-services.bat
++index 02e28be..c0e9716 100644
++--- a/arch/deploy/install-services.bat
+++++ b/arch/deploy/install-services.bat
++@@ -13,7 +13,7 @@ echo ============================================
++ echo.
++ 
++ REM Backend Service
++-echo [1/4] Installing InvektoBackend...
+++echo [1/5] Installing InvektoBackend...
++ %NSSM% install InvektoBackend "E:\Invekto\Backend\current\Invekto.Backend.exe"
++ %NSSM% set InvektoBackend DisplayName "Invekto Backend"
++ %NSSM% set InvektoBackend Description "Invekto Backend API - Port 5000"
++@@ -32,7 +32,7 @@ echo [OK] InvektoBackend installed
++ echo.
++ 
++ REM ChatAnalysis Service
++-echo [2/4] Installing InvektoChatAnalysis...
+++echo [2/5] Installing InvektoChatAnalysis...
++ %NSSM% install InvektoChatAnalysis "E:\Invekto\ChatAnalysis\current\Invekto.ChatAnalysis.exe"
++ %NSSM% set InvektoChatAnalysis DisplayName "Invekto ChatAnalysis"
++ %NSSM% set InvektoChatAnalysis Description "Invekto Chat Analysis Microservice - Port 7101"
++@@ -51,7 +51,7 @@ echo [OK] InvektoChatAnalysis installed
++ echo.
++ 
++ REM Automation Service
++-echo [3/4] Installing InvektoAutomation...
+++echo [3/5] Installing InvektoAutomation...
++ %NSSM% install InvektoAutomation "E:\Invekto\Automation\current\Invekto.Automation.exe"
++ %NSSM% set InvektoAutomation DisplayName "Invekto Automation"
++ %NSSM% set InvektoAutomation Description "Invekto Automation Chatbot/Flow Builder - Port 7108"
++@@ -70,7 +70,7 @@ echo [OK] InvektoAutomation installed
++ echo.
++ 
++ REM AgentAI Service
++-echo [4/4] Installing InvektoAgentAI...
+++echo [4/5] Installing InvektoAgentAI...
++ %NSSM% install InvektoAgentAI "E:\Invekto\AgentAI\current\Invekto.AgentAI.exe"
++ %NSSM% set InvektoAgentAI DisplayName "Invekto AgentAI"
++ %NSSM% set InvektoAgentAI Description "Invekto AI Agent Assist Microservice - Port 7105"
++@@ -88,11 +88,31 @@ echo [4/4] Installing InvektoAgentAI...
++ echo [OK] InvektoAgentAI installed
++ echo.
++ 
+++REM Outbound Service
+++echo [5/5] Installing InvektoOutbound...
+++%NSSM% install InvektoOutbound "E:\Invekto\Outbound\current\Invekto.Outbound.exe"
+++%NSSM% set InvektoOutbound DisplayName "Invekto Outbound"
+++%NSSM% set InvektoOutbound Description "Invekto Outbound Broadcast Messaging - Port 7107"
+++%NSSM% set InvektoOutbound AppDirectory "E:\Invekto\Outbound\current"
+++%NSSM% set InvektoOutbound AppEnvironmentExtra "ASPNETCORE_ENVIRONMENT=Production"
+++%NSSM% set InvektoOutbound AppStdout "E:\Invekto\Outbound\logs\service-stdout.log"
+++%NSSM% set InvektoOutbound AppStderr "E:\Invekto\Outbound\logs\service-stderr.log"
+++%NSSM% set InvektoOutbound AppStdoutCreationDisposition 4
+++%NSSM% set InvektoOutbound AppStderrCreationDisposition 4
+++%NSSM% set InvektoOutbound AppRotateFiles 1
+++%NSSM% set InvektoOutbound AppRotateBytes 10485760
+++%NSSM% set InvektoOutbound Start SERVICE_AUTO_START
+++%NSSM% set InvektoOutbound AppExit Default Restart
+++%NSSM% set InvektoOutbound AppRestartDelay 5000
+++echo [OK] InvektoOutbound installed
+++echo.
+++
++ REM Create log directories
++ if not exist "E:\Invekto\Backend\logs" mkdir "E:\Invekto\Backend\logs"
++ if not exist "E:\Invekto\ChatAnalysis\logs" mkdir "E:\Invekto\ChatAnalysis\logs"
++ if not exist "E:\Invekto\Automation\logs" mkdir "E:\Invekto\Automation\logs"
++ if not exist "E:\Invekto\AgentAI\logs" mkdir "E:\Invekto\AgentAI\logs"
+++if not exist "E:\Invekto\Outbound\logs" mkdir "E:\Invekto\Outbound\logs"
++ 
++ REM Start services
++ echo Starting services...
++@@ -104,6 +124,8 @@ timeout /t 3 /nobreak >nul
++ timeout /t 3 /nobreak >nul
++ %NSSM% start InvektoAgentAI
++ timeout /t 3 /nobreak >nul
+++%NSSM% start InvektoOutbound
+++timeout /t 3 /nobreak >nul
++ 
++ echo.
++ echo ============================================
++@@ -115,11 +137,13 @@ echo Services:
++ %NSSM% status InvektoChatAnalysis
++ %NSSM% status InvektoAutomation
++ %NSSM% status InvektoAgentAI
+++%NSSM% status InvektoOutbound
++ echo.
++ echo Test:
++ echo   http://localhost:5000/health
++ echo   http://localhost:7101/health
++ echo   http://localhost:7105/health
+++echo   http://localhost:7107/health
++ echo   http://localhost:7108/health
++ echo.
++ echo Manage:
++@@ -127,5 +151,6 @@ echo   %NSSM% edit InvektoBackend
++ echo   %NSSM% edit InvektoChatAnalysis
++ echo   %NSSM% edit InvektoAutomation
++ echo   %NSSM% edit InvektoAgentAI
+++echo   %NSSM% edit InvektoOutbound
++ echo.
++ pause
++diff --git a/arch/deploy/restart-services.bat b/arch/deploy/restart-services.bat
++index 90e6f2b..7bd4dfe 100644
++--- a/arch/deploy/restart-services.bat
+++++ b/arch/deploy/restart-services.bat
++@@ -12,6 +12,7 @@ echo Stopping services...
++ %NSSM% stop InvektoChatAnalysis
++ %NSSM% stop InvektoAutomation
++ %NSSM% stop InvektoAgentAI
+++%NSSM% stop InvektoOutbound
++ timeout /t 3 /nobreak >nul
++ 
++ echo.
++@@ -24,6 +25,8 @@ timeout /t 2 /nobreak >nul
++ timeout /t 2 /nobreak >nul
++ %NSSM% start InvektoAgentAI
++ timeout /t 2 /nobreak >nul
+++%NSSM% start InvektoOutbound
+++timeout /t 2 /nobreak >nul
++ 
++ echo.
++ echo Status:
++@@ -31,10 +34,12 @@ echo Status:
++ %NSSM% status InvektoChatAnalysis
++ %NSSM% status InvektoAutomation
++ %NSSM% status InvektoAgentAI
+++%NSSM% status InvektoOutbound
++ echo.
++ echo Test: http://localhost:5000/health
++ echo Test: http://localhost:7101/health
++-echo Test: http://localhost:7108/health
++ echo Test: http://localhost:7105/health
+++echo Test: http://localhost:7107/health
+++echo Test: http://localhost:7108/health
++ echo.
++ pause
++diff --git a/arch/errors.md b/arch/errors.md
++index 602fb38..9fb5479 100644
++--- a/arch/errors.md
+++++ b/arch/errors.md
++@@ -25,6 +25,7 @@ INV-{SERVICE}-{NUMBER}
++ | INT | Integration | GR-1.9: Entegrasyon k╬ô├╢┬ú╬ô├▓├│pr╬ô├╢┬ú╬ô├▓┬Ñs╬ô├╢┬ú╬ô├▓┬Ñ hatalar╬ô├╢├ç╬ô├╗├å |
++ | DB | Database | Veritaban╬ô├╢├ç╬ô├╗├å hatalar╬ô├╢├ç╬ô├╗├å |
++ | VAL | Validation | Validasyon hatalar╬ô├╢├ç╬ô├╗├å |
+++| OB | Outbound | GR-1.3: Broadcast & trigger engine hatalar╬ô├╢├ç╬ô├╗├å |
++ | EXT | External | D╬ô├╢├ç╬ô├╗├å╬ô├╢Γò¥Γò₧├å servis hatalar╬ô├╢├ç╬ô├╗├å |
++ 
++ ---
++@@ -131,6 +132,23 @@ INV-{SERVICE}-{NUMBER}
++ 
++ ---
++ 
+++## OB - Outbound Errors (GR-1.3)
+++
+++| Code | Description | User Message |
+++|------|-------------|--------------|
+++| INV-OB-001 | Invalid broadcast payload | Gecersiz toplu mesaj istegi. |
+++| INV-OB-002 | Template not found | Mesaj sablonu bulunamadi. |
+++| INV-OB-003 | Rate limit exceeded (queued) | Gonderim limiti asildi, mesajlar kuyrukta bekliyor. |
+++| INV-OB-004 | Recipient opted out | Alici mesaj almak istemiyor (opt-out). |
+++| INV-OB-005 | Broadcast not found | Toplu mesaj kaydi bulunamadi. |
+++| INV-OB-006 | Delivery status update failed | Teslimat durumu guncellenemedi. |
+++| INV-OB-007 | Invalid template payload | Gecersiz sablon formati. |
+++| INV-OB-008 | No matching trigger template | Bu event icin esle&#351;en sablon bulunamadi. |
+++| INV-OB-009 | Message send callback failed | Mesaj gonderim callback'i basarisiz oldu. |
+++| INV-OB-010 | Too many recipients (max 1000) | Alici sayisi siniri asildi (max 1000). |
+++
+++---
+++
++ ## EXT - External Service Errors
++ 
++ | Code | Description | User Message |
++diff --git a/arch/plans/20260212-outbound-service.json b/arch/plans/20260212-outbound-service.json
++new file mode 100644
++index 0000000..1c4c0ed
++--- /dev/null
+++++ b/arch/plans/20260212-outbound-service.json
++@@ -0,0 +1,253 @@
+++{
+++  "slug": "20260212-outbound-service",
+++  "title": "GR-1.3: Invekto.Outbound Broadcast & Trigger Engine",
+++  "status": "PLAN",
+++  "risk": "HIGH",
+++  "iteration": 0,
+++  "created_at": "2026-02-12",
+++  "summary": "Yeni Invekto.Outbound mikroservisi (Port 7107): toplu mesaj g╬ô├╢┬ú╬ô├▓├│nderimi, event-based trigger engine, template engine ({{var}}), tenant-bazl╬ô├╢├ç╬ô├╗├å rate limiting ile kuyruk, opt-out y╬ô├╢┬ú╬ô├▓├│netimi (STOP keyword detection), delivery status tracking. Callback pattern ile mesaj g╬ô├╢┬ú╬ô├▓├│nderimi (Outbound Γò¼├┤Γö£├æΓö£├Ñ Main App Γò¼├┤Γö£├æΓö£├Ñ WapCRM).",
+++
+++  "interview_decisions": {
+++    "send_flow": "Callback pattern: Outbound kuyru╬ô├╢├çΓò₧├åa al╬ô├╢├ç╬ô├╗├år Γò¼├┤Γö£├æΓö£├Ñ Main App'e send_message callback Γò¼├┤Γö£├æΓö£├Ñ Main App WapCRM'e g╬ô├╢┬ú╬ô├▓├│nderir",
+++    "trigger_engine": "Webhook triggers + send_at (one-time scheduled). Full cron engine Phase 2",
+++    "segment_recipient": "Main App telefon listesini g╬ô├╢┬ú╬ô├▓├│nderir (max 1,000 per request). Outbound segment mant╬ô├╢├ç╬ô├╗├å╬ô├╢├çΓò₧├å╬ô├╢├ç╬ô├╗├å bilmez",
+++    "rate_limiting": "Tenant-bazl╬ô├╢├ç╬ô├╗├å rate limit (msg/dakika). Limit a╬ô├╢Γò¥Γò₧├å╬ô├╢├ç╬ô├╗├ål╬ô├╢├ç╬ô├╗├ånca mesaj kuyrukta bekler, reject yok",
+++    "delivery_status": "Main App Γò¼├┤Γö£├æΓö£├Ñ Outbound webhook (POST /delivery-status). Outbound DB g╬ô├╢┬ú╬ô├▓┬Ñnceller",
+++    "template_variables": "Per-recipient variables: {phone, variables: {isim, firma}}",
+++    "optout": "Main App raw mesaj╬ô├╢├ç╬ô├╗├å forward eder Γò¼├┤Γö£├æΓö£├Ñ Outbound STOP/DUR/╬ô├╢├ç╬ô├╗├ªPTAL keyword detect eder ve opt-out kayd╬ô├╢├ç╬ô├╗├å olu╬ô├╢Γò¥Γò₧├åturur",
+++    "trigger_events": "Phase 1: new_lead, payment_received, appointment_reminder",
+++    "batch_size": "Max 1,000 recipients per broadcast request"
+++  },
+++
+++  "architecture": {
+++    "broadcast_flow": [
+++      "Main App Γò¼├┤Γö£├æΓö£├Ñ Backend /api/v1/outbound/broadcast/send (JWT + recipients)",
+++      "Backend Γò¼├┤Γö£├æΓö£├Ñ Outbound /api/v1/broadcast/send (proxy)",
+++      "Outbound: validate Γò¼├┤Γö£├æΓö£├Ñ create broadcast record Γò¼├┤Γö£├æΓö£├Ñ insert messages as 'queued'",
+++      "Return 202 Accepted with broadcast_id",
+++      "Background IHostedService dequeues messages respecting rate limit",
+++      "Per message: send_message callback to Main App via MainAppCallbackClient",
+++      "Main App sends via WapCRM",
+++      "Main App receives delivery status Γò¼├┤Γö£├æΓö£├Ñ forwards to Outbound",
+++      "Outbound updates message status (sent/delivered/read/failed)"
+++    ],
+++    "trigger_flow": [
+++      "Main App event occurs (new_lead, payment, etc.)",
+++      "Main App Γò¼├┤Γö£├æΓö£├Ñ Backend Γò¼├┤Γö£├æΓö£├Ñ Outbound /api/v1/webhook/trigger",
+++      "Outbound checks outbound_templates for matching trigger_event + tenant",
+++      "Applies template variables from webhook data",
+++      "Inserts single message as 'queued' (same rate-limited queue)",
+++      "Background sender processes"
+++    ],
+++    "optout_flow": [
+++      "Customer sends 'STOP' on WhatsApp",
+++      "Main App receives Γò¼├┤Γö£├æΓö£├Ñ forwards to Backend Γò¼├┤Γö£├æΓö£├Ñ Outbound /api/v1/webhook/message",
+++      "Outbound checks for stop keywords (STOP, DUR, ╬ô├╢├ç╬ô├╗├ªPTAL, IPTAL, DURDU, ╬ô├╢┬úΓö£┬║IKI╬ô├╢Γò¥╬ô├⌐┬║, CIKIS)",
+++      "If match: create opt-out record, return {opted_out: true}",
+++      "Future broadcasts skip opted-out phones"
+++    ]
+++  },
+++
+++  "db_tables": {
+++    "outbound_templates": {
+++      "columns": "id SERIAL PK, tenant_id INT FK, name VARCHAR(200), trigger_event VARCHAR(50), message_template TEXT, variables_json JSONB, is_active BOOL, created_at TIMESTAMPTZ, updated_at TIMESTAMPTZ",
+++      "indexes": ["(tenant_id, is_active) WHERE is_active=true", "(tenant_id, trigger_event) WHERE is_active=true"],
+++      "notes": "trigger_event: new_lead, payment_received, appointment_reminder, manual (for broadcast-only templates)"
+++    },
+++    "outbound_broadcasts": {
+++      "columns": "id UUID PK, tenant_id INT FK, template_id INT, total_recipients INT, queued INT, sent INT, delivered INT, read INT, failed INT, status VARCHAR(20), scheduled_at TIMESTAMPTZ, started_at TIMESTAMPTZ, completed_at TIMESTAMPTZ, created_at TIMESTAMPTZ",
+++      "indexes": ["(tenant_id, created_at DESC)", "(status) WHERE status IN ('queued','processing')"],
+++      "notes": "status: queued, processing, completed, failed. Counter columns for fast status queries"
+++    },
+++    "outbound_messages": {
+++      "columns": "id BIGSERIAL PK, tenant_id INT FK, broadcast_id UUID, template_id INT, recipient_phone VARCHAR(20), message_text TEXT, status VARCHAR(20), external_message_id VARCHAR(100), sent_at TIMESTAMPTZ, delivered_at TIMESTAMPTZ, read_at TIMESTAMPTZ, failed_reason VARCHAR(500), created_at TIMESTAMPTZ",
+++      "indexes": ["(tenant_id, created_at DESC)", "(broadcast_id, status)", "(status, created_at) WHERE status='queued'", "(external_message_id) WHERE external_message_id IS NOT NULL"],
+++      "notes": "status: queued, sending, sent, delivered, read, failed. broadcast_id nullable (null for trigger-based single messages)"
+++    },
+++    "outbound_optouts": {
+++      "columns": "id SERIAL PK, tenant_id INT FK, phone VARCHAR(20), reason VARCHAR(200), created_at TIMESTAMPTZ",
+++      "indexes": ["UNIQUE (tenant_id, phone)"],
+++      "notes": "Unique constraint: bir phone bir tenant'ta tek opt-out kayd╬ô├╢├ç╬ô├╗├å"
+++    }
+++  },
+++
+++  "endpoints": {
+++    "outbound_service": [
+++      {"method": "POST", "path": "/api/v1/broadcast/send", "auth": "JWT", "response": "202", "desc": "Submit broadcast (async)"},
+++      {"method": "GET", "path": "/api/v1/broadcast/{broadcastId}/status", "auth": "JWT", "response": "200", "desc": "Get broadcast delivery status"},
+++      {"method": "POST", "path": "/api/v1/webhook/trigger", "auth": "JWT", "response": "202", "desc": "Receive trigger event from Main App"},
+++      {"method": "POST", "path": "/api/v1/webhook/delivery-status", "auth": "JWT", "response": "200", "desc": "Receive delivery status update"},
+++      {"method": "POST", "path": "/api/v1/webhook/message", "auth": "JWT", "response": "200", "desc": "Receive incoming message for opt-out detection"},
+++      {"method": "GET", "path": "/api/v1/templates", "auth": "JWT", "response": "200", "desc": "List active templates"},
+++      {"method": "POST", "path": "/api/v1/templates", "auth": "JWT", "response": "201", "desc": "Create template"},
+++      {"method": "PUT", "path": "/api/v1/templates/{id}", "auth": "JWT", "response": "200", "desc": "Update template"},
+++      {"method": "DELETE", "path": "/api/v1/templates/{id}", "auth": "JWT", "response": "200", "desc": "Deactivate template"},
+++      {"method": "POST", "path": "/api/v1/optout", "auth": "JWT", "response": "200", "desc": "Manual opt-out add"},
+++      {"method": "DELETE", "path": "/api/v1/optout/{phone}", "auth": "JWT", "response": "200", "desc": "Remove opt-out"},
+++      {"method": "GET", "path": "/api/v1/optout/check/{phone}", "auth": "JWT", "response": "200", "desc": "Check if phone opted out"},
+++      {"method": "GET", "path": "/health", "auth": "none", "response": "200", "desc": "Health check"},
+++      {"method": "GET", "path": "/ready", "auth": "none", "response": "200", "desc": "Readiness probe (DB check)"},
+++      {"method": "GET", "path": "/api/ops/endpoints", "auth": "none", "response": "200", "desc": "Endpoint discovery"}
+++    ],
+++    "backend_proxy": [
+++      {"method": "POST", "path": "/api/v1/outbound/broadcast/send", "proxies_to": "/api/v1/broadcast/send"},
+++      {"method": "GET", "path": "/api/v1/outbound/broadcast/{broadcastId}/status", "proxies_to": "/api/v1/broadcast/{broadcastId}/status"},
+++      {"method": "POST", "path": "/api/v1/outbound/webhook/trigger", "proxies_to": "/api/v1/webhook/trigger"},
+++      {"method": "POST", "path": "/api/v1/outbound/webhook/delivery-status", "proxies_to": "/api/v1/webhook/delivery-status"},
+++      {"method": "POST", "path": "/api/v1/outbound/webhook/message", "proxies_to": "/api/v1/webhook/message"},
+++      {"method": "GET", "path": "/api/v1/outbound/templates", "proxies_to": "/api/v1/templates"},
+++      {"method": "POST", "path": "/api/v1/outbound/templates", "proxies_to": "/api/v1/templates"},
+++      {"method": "PUT", "path": "/api/v1/outbound/templates/{id}", "proxies_to": "/api/v1/templates/{id}"},
+++      {"method": "DELETE", "path": "/api/v1/outbound/templates/{id}", "proxies_to": "/api/v1/templates/{id}"},
+++      {"method": "POST", "path": "/api/v1/outbound/optout", "proxies_to": "/api/v1/optout"},
+++      {"method": "DELETE", "path": "/api/v1/outbound/optout/{phone}", "proxies_to": "/api/v1/optout/{phone}"},
+++      {"method": "GET", "path": "/api/v1/outbound/optout/check/{phone}", "proxies_to": "/api/v1/optout/check/{phone}"}
+++    ]
+++  },
+++
+++  "error_codes": {
+++    "INV-OB-001": "Invalid broadcast payload",
+++    "INV-OB-002": "Template not found",
+++    "INV-OB-003": "Rate limit exceeded (queued for later)",
+++    "INV-OB-004": "Recipient opted out",
+++    "INV-OB-005": "Broadcast not found",
+++    "INV-OB-006": "Delivery status update failed",
+++    "INV-OB-007": "Invalid template payload",
+++    "INV-OB-008": "No matching trigger template",
+++    "INV-OB-009": "Message send callback failed",
+++    "INV-OB-010": "Too many recipients (max 1000)"
+++  },
+++
+++  "files_to_create": [
+++    "src/Invekto.Outbound/Invekto.Outbound.csproj",
+++    "src/Invekto.Outbound/Program.cs",
+++    "src/Invekto.Outbound/appsettings.json",
+++    "src/Invekto.Outbound/Data/OutboundRepository.cs",
+++    "src/Invekto.Outbound/Services/TemplateEngine.cs",
+++    "src/Invekto.Outbound/Services/OptOutManager.cs",
+++    "src/Invekto.Outbound/Services/RateLimiter.cs",
+++    "src/Invekto.Outbound/Services/BroadcastOrchestrator.cs",
+++    "src/Invekto.Outbound/Services/TriggerProcessor.cs",
+++    "src/Invekto.Outbound/Services/MessageSenderService.cs",
+++    "src/Invekto.Shared/DTOs/Outbound/BroadcastDtos.cs",
+++    "src/Invekto.Shared/DTOs/Outbound/TemplateDtos.cs",
+++    "src/Invekto.Shared/DTOs/Outbound/WebhookDtos.cs",
+++    "src/Invekto.Backend/Services/OutboundClient.cs",
+++    "arch/db/outbound.sql",
+++    "arch/contracts/outbound-broadcast.json",
+++    "src/Invekto.Outbound/appsettings.Production.json"
+++  ],
+++
+++  "files_to_modify": [
+++    "src/Invekto.Shared/Constants/ErrorCodes.cs",
+++    "src/Invekto.Shared/DTOs/Integration/OutgoingCallback.cs",
+++    "arch/errors.md",
+++    "src/Invekto.Backend/appsettings.json",
+++    "arch/deploy/appsettings.Production.Backend.json",
+++    "src/Invekto.Backend/Program.cs",
+++    "dev-to-invekto-services.bat",
+++    "arch/deploy/install-services.bat",
+++    "arch/deploy/firewall-rules.bat",
+++    "arch/deploy/restart-services.bat",
+++    "arch/deploy/deploy-watcher.ps1",
+++    "arch/session-memory.md",
+++    "arch/active-work.md"
+++  ],
+++
+++  "implementation_steps": [
+++    {
+++      "step": 1,
+++      "name": "Arch files + Error codes",
+++      "files": ["arch/db/outbound.sql", "arch/contracts/outbound-broadcast.json", "arch/errors.md", "src/Invekto.Shared/Constants/ErrorCodes.cs"],
+++      "desc": "DB schema, API contract, error code definitions"
+++    },
+++    {
+++      "step": 2,
+++      "name": "Shared DTOs + CallbackData extension",
+++      "files": ["src/Invekto.Shared/DTOs/Outbound/BroadcastDtos.cs", "src/Invekto.Shared/DTOs/Outbound/TemplateDtos.cs", "src/Invekto.Shared/DTOs/Outbound/WebhookDtos.cs", "src/Invekto.Shared/DTOs/Integration/OutgoingCallback.cs"],
+++      "desc": "Request/response DTOs, extend CallbackData with phone/broadcast_id/message_id"
+++    },
+++    {
+++      "step": 3,
+++      "name": "Outbound project skeleton + health endpoints",
+++      "files": ["src/Invekto.Outbound/Invekto.Outbound.csproj", "src/Invekto.Outbound/Program.cs", "src/Invekto.Outbound/appsettings.json", "src/Invekto.Outbound/appsettings.Production.json"],
+++      "desc": "Project file, Kestrel 7107, WindowsService, JWT, PostgreSQL, health/ready"
+++    },
+++    {
+++      "step": 4,
+++      "name": "Data layer + Services",
+++      "files": ["src/Invekto.Outbound/Data/OutboundRepository.cs", "src/Invekto.Outbound/Services/TemplateEngine.cs", "src/Invekto.Outbound/Services/OptOutManager.cs", "src/Invekto.Outbound/Services/RateLimiter.cs", "src/Invekto.Outbound/Services/BroadcastOrchestrator.cs", "src/Invekto.Outbound/Services/TriggerProcessor.cs", "src/Invekto.Outbound/Services/MessageSenderService.cs"],
+++      "desc": "All business logic: repository, template engine, opt-out, rate limiter, orchestrator, trigger processor, background message sender"
+++    },
+++    {
+++      "step": 5,
+++      "name": "Wire all endpoints in Program.cs",
+++      "files": ["src/Invekto.Outbound/Program.cs"],
+++      "desc": "Complete all API endpoints: broadcast, templates, webhooks, optout"
+++    },
+++    {
+++      "step": 6,
+++      "name": "Backend proxy + deploy scripts",
+++      "files": ["src/Invekto.Backend/Services/OutboundClient.cs", "src/Invekto.Backend/Program.cs", "src/Invekto.Backend/appsettings.json", "arch/deploy/appsettings.Production.Backend.json", "dev-to-invekto-services.bat", "arch/deploy/install-services.bat", "arch/deploy/firewall-rules.bat", "arch/deploy/restart-services.bat", "arch/deploy/deploy-watcher.ps1"],
+++      "desc": "Backend OutboundClient, proxy endpoints, all deploy scripts updated for Outbound"
+++    },
+++    {
+++      "step": 7,
+++      "name": "Build + arch update",
+++      "files": ["arch/session-memory.md", "arch/active-work.md"],
+++      "desc": "Full solution build, update session memory"
+++    }
+++  ],
+++
+++  "verification_questions": [
+++    {"category": "DB_SYNC", "question": "outbound_templates, outbound_broadcasts, outbound_messages, outbound_optouts tablolar╬ô├╢├ç╬ô├╗├å outbound.sql'de do╬ô├╢├çΓò₧├åru tan╬ô├╢├ç╬ô├╗├åml╬ô├╢├ç╬ô├╗├å m╬ô├╢├ç╬ô├╗├å? FK, index, constraint'ler var m╬ô├╢├ç╬ô├╗├å?"},
+++    {"category": "RATE_LIMIT", "question": "RateLimiter tenant-bazl╬ô├╢├ç╬ô├╗├å ╬ô├╢┬úΓö¼Γòæal╬ô├╢├ç╬ô├╗├å╬ô├╢Γò¥Γò₧├å╬ô├╢├ç╬ô├╗├åyor mu? Limit a╬ô├╢Γò¥Γò₧├å╬ô├╢├ç╬ô├╗├ål╬ô├╢├ç╬ô├╗├ånca mesaj reject DE╬ô├╢├ç╬ô├⌐┬║╬ô├╢├ç╬ô├╗├ªL kuyrukta bekliyor mu?"},
+++    {"category": "OPT_OUT", "question": "Broadcast g╬ô├╢┬ú╬ô├▓├│nderiminde opt-out check yap╬ô├╢├ç╬ô├╗├ål╬ô├╢├ç╬ô├╗├åyor mu? Opted-out telefona mesaj g╬ô├╢┬ú╬ô├▓├│nderilmiyor mu?"},
+++    {"category": "CALLBACK", "question": "send_message callback'inde phone alan╬ô├╢├ç╬ô├╗├å var m╬ô├╢├ç╬ô├╗├å? Main App hangi numaraya g╬ô├╢┬ú╬ô├▓├│nderece╬ô├╢├çΓò₧├åini biliyor mu?"},
+++    {"category": "TEMPLATE", "question": "Template {{var}} substitution d╬ô├╢┬ú╬ô├▓┬Ñzg╬ô├╢┬ú╬ô├▓┬Ñn ╬ô├╢┬úΓö¼Γòæal╬ô├╢├ç╬ô├╗├å╬ô├╢Γò¥Γò₧├å╬ô├╢├ç╬ô├╗├åyor mu? Eksik variable handle ediliyor mu?"},
+++    {"category": "TRIGGER", "question": "Trigger webhook'u template e╬ô├╢Γò¥Γò₧├åle╬ô├╢Γò¥Γò₧├åtirmesi yap╬ô├╢├ç╬ô├╗├åyor mu? E╬ô├╢Γò¥Γò₧├åle╬ô├╢Γò¥Γò₧├åen yoksa INV-OB-008 d╬ô├╢┬ú╬ô├▓├│n╬ô├╢┬ú╬ô├▓┬Ñyor mu?"},
+++    {"category": "BACKGROUND", "question": "MessageSenderService IHostedService olarak register edilmi╬ô├╢Γò¥Γò₧├å mi? Graceful shutdown yap╬ô├╢├ç╬ô├╗├åyor mu?"},
+++    {"category": "AUTH", "question": "T╬ô├╢┬ú╬ô├▓┬Ñm /api/v1/ endpoint'leri JWT korumal╬ô├╢├ç╬ô├╗├å m╬ô├╢├ç╬ô├╗├å? Backend proxy JWT forwarding yap╬ô├╢├ç╬ô├╗├åyor mu?"},
+++    {"category": "DEPLOY", "question": "T╬ô├╢┬ú╬ô├▓┬Ñm deploy scriptleri g╬ô├╢┬ú╬ô├▓┬Ñncellendi mi? (7 dosya: deploy-bat, install, firewall, restart, watcher, Backend appsettings dev+prod)"},
+++    {"category": "ERROR_CODES", "question": "INV-OB-001~010 error code'lar╬ô├╢├ç╬ô├╗├å hem errors.md hem ErrorCodes.cs'de tan╬ô├╢├ç╬ô├╗├åml╬ô├╢├ç╬ô├╗├å m╬ô├╢├ç╬ô├╗├å?"}
+++  ],
+++
+++  "aha_moments": [
+++    {
+++      "category": "UX",
+++      "user_pain": "Toplu mesaj g╬ô├╢┬ú╬ô├▓├│nderirken agent tek tek numaralara kopyala-yap╬ô├╢├ç╬ô├╗├å╬ô├╢Γò¥Γò₧├åt╬ô├╢├ç╬ô├╗├år yap╬ô├╢├ç╬ô├╗├åyor",
+++      "suggestion": "Broadcast send'den sonra ger╬ô├╢┬úΓö¼Γòæek zamanl╬ô├╢├ç╬ô├╗├å progress bar g╬ô├╢┬ú╬ô├▓├│ster (queued Γò¼├┤Γö£├æΓö£├Ñ sent Γò¼├┤Γö£├æΓö£├Ñ delivered y╬ô├╢┬ú╬ô├▓┬Ñzdeleri)",
+++      "aha_moment": "Agent 'G╬ô├╢┬ú╬ô├▓├│nder' bas╬ô├╢├ç╬ô├╗├åyor, 500 mesaj╬ô├╢├ç╬ô├╗├ån %'si canl╬ô├╢├ç╬ô├╗├å olarak y╬ô├╢┬ú╬ô├▓┬Ñkseliyor - 'vay, hepsini takip edebiliyorum!'"
+++    },
+++    {
+++      "category": "SPEED",
+++      "user_pain": "Yeni lead geldi╬ô├╢├çΓò₧├åinde kar╬ô├╢Γò¥Γò₧├å╬ô├╢├ç╬ô├╗├ålama mesaj╬ô├╢├ç╬ô├╗├å g╬ô├╢┬ú╬ô├▓├│ndermek i╬ô├╢┬úΓö¼Γòæin birinin online olmas╬ô├╢├ç╬ô├╗├å gerekiyor",
+++      "suggestion": "Trigger engine: new_lead event'i otomatik kar╬ô├╢Γò¥Γò₧├å╬ô├╢├ç╬ô├╗├ålama mesaj╬ô├╢├ç╬ô├╗├å g╬ô├╢┬ú╬ô├▓├│nderir (< 5 saniye)",
+++      "aha_moment": "Lead formu doldurur, 3 saniyede WhatsApp'tan 'Ho╬ô├╢Γò¥Γò₧├å geldiniz Ali!' mesaj╬ô├╢├ç╬ô├╗├å gelir - 'bunlar ╬ô├╢┬úΓö¼Γòæok h╬ô├╢├ç╬ô├╗├åzl╬ô├╢├ç╬ô├╗├å!'"
+++    },
+++    {
+++      "category": "RELIABILITY",
+++      "user_pain": "WhatsApp rate limit'e tak╬ô├╢├ç╬ô├╗├ål╬ô├╢├ç╬ô├╗├åp mesajlar kaybolabilir",
+++      "suggestion": "Rate limiter + queue: hi╬ô├╢┬úΓö¼Γòæbir mesaj kaybolmaz, s╬ô├╢├ç╬ô├╗├åraya al╬ô├╢├ç╬ô├╗├ån╬ô├╢├ç╬ô├╗├år ve g╬ô├╢┬ú╬ô├▓┬Ñvenli h╬ô├╢├ç╬ô├╗├åzda g╬ô├╢┬ú╬ô├▓├│nderilir",
+++      "aha_moment": "1000 mesajl╬ô├╢├ç╬ô├╗├åk kampanya, hepsi teslim edildi, 0 kay╬ô├╢├ç╬ô├╗├åp - 'g╬ô├╢┬ú╬ô├▓┬Ñvenle g╬ô├╢┬ú╬ô├▓├│nderebiliyoruz!'"
+++    },
+++    {
+++      "category": "SALES",
+++      "user_pain": "M╬ô├╢┬ú╬ô├▓┬Ñ╬ô├╢Γò¥Γò₧├återi 'STOP' yaz╬ô├╢├ç╬ô├╗├ånca hala mesaj almaya devam ediyor, ╬ô├╢Γò¥Γò₧├åikayet geliyor",
+++      "suggestion": "Otomatik opt-out: STOP/DUR/╬ô├╢├ç╬ô├╗├ªPTAL alg╬ô├╢├ç╬ô├╗├ålan╬ô├╢├ç╬ô├╗├år, m╬ô├╢┬ú╬ô├▓┬Ñ╬ô├╢Γò¥Γò₧├återi listelendir ve bir daha rahats╬ô├╢├ç╬ô├╗├åz edilmez",
+++      "aha_moment": "M╬ô├╢┬ú╬ô├▓┬Ñ╬ô├╢Γò¥Γò₧├återi 'dur' yazar, an╬ô├╢├ç╬ô├╗├ånda opt-out kayd╬ô├╢├ç╬ô├╗├å olu╬ô├╢Γò¥Γò₧├åur - 'yasal uyumluluk otomatik!'"
+++    },
+++    {
+++      "category": "SUPPORT",
+++      "user_pain": "Template mesajlar╬ô├╢├ç╬ô├╗├ånda m╬ô├╢┬ú╬ô├▓┬Ñ╬ô├╢Γò¥Γò₧├återi ad╬ô├╢├ç╬ô├╗├å yerine {{isim}} gidiyor - utan╬ô├╢┬úΓö¼Γòæ verici",
+++      "suggestion": "Template engine her mesaj╬ô├╢├ç╬ô├╗├å g╬ô├╢┬ú╬ô├▓├│ndermeden ╬ô├╢┬ú╬ô├▓├│nce t╬ô├╢┬ú╬ô├▓┬Ñm de╬ô├╢├çΓò₧├åi╬ô├╢Γò¥Γò₧├åkenleri kontrol eder, eksik varsa bloklar",
+++      "aha_moment": "De╬ô├╢├çΓò₧├åi╬ô├╢Γò¥Γò₧├åken eksik olan mesaj g╬ô├╢┬ú╬ô├▓├│nderilmez, agent uyar╬ô├╢├ç╬ô├╗├ål╬ô├╢├ç╬ô├╗├år - 'hatal╬ô├╢├ç╬ô├╗├å mesaj m╬ô├╢┬ú╬ô├▓┬Ñ╬ô├╢Γò¥Γò₧├återiye gitmedi!'"
+++    }
+++  ],
+++
+++  "codex_review": {
+++    "iteration": 0,
+++    "verdict": null,
+++    "blocking_issues": []
+++  }
+++}
++diff --git a/arch/session-memory.md b/arch/session-memory.md
++index f3808ae..7a14c3f 100644
++--- a/arch/session-memory.md
+++++ b/arch/session-memory.md
++@@ -5,8 +5,8 @@
++ ## Last Update
++ 
++ - **Date:** 2026-02-12
++-- **Status:** Ops tamamland╬ô├╢├ç╬ô├╗├å - t╬ô├╢┬ú╬ô├▓┬Ñm servisler production'da ╬ô├╢┬úΓö¼Γòæal╬ô├╢├ç╬ô├╗├å╬ô├╢Γò¥Γò₧├å╬ô├╢├ç╬ô├╗├åyor
++-- **Last Task:** Production deploy do╬ô├╢├çΓò₧├årulama. Backend:5000 (external OK), Automation:7108 (external OK), ChatAnalysis:7101 (localhost-only OK), AgentAI:7105 (localhost-only OK). Firewall kurallar╬ô├╢├ç╬ô├╗├å tasar╬ô├╢├ç╬ô├╗├åma uygun.
+++- **Status:** GR-1.3 Outbound service implemented - Build PASS, /rev bekliyor
+++- **Last Task:** Invekto.Outbound microservice (Port 7107) full implementation. Backend proxy (12 endpoints), deploy scripts updated, all arch files in sync.
++ 
++ ---
++ 
++@@ -50,6 +50,19 @@
++   - API contract: `arch/contracts/agentai-suggest.json`
++   - Error codes: INV-AA-001 ~ INV-AA-006
++ 
+++- **GR-1.3 Outbound Service (Port 7107):**
+++  - Broadcast/bulk messaging (max 1000 recipients, async queue)
+++  - Event-based trigger engine (webhook -> template -> send)
+++  - Template engine: `{{variable}}` substitution with missing var detection
+++  - Tenant-based sliding window rate limiter (in-memory, configurable msg/min)
+++  - Opt-out management (STOP/DUR/╬ô├╢├ç╬ô├╗├ªPTAL keyword detection)
+++  - Delivery status tracking (sent/delivered/failed/read counters)
+++  - Background IHostedService message sender (batch dequeue, FOR UPDATE SKIP LOCKED)
+++  - Backend proxy pattern (Main App -> Backend:5000 -> Outbound:7107, localhost-only)
+++  - DB schema: `arch/db/outbound.sql` (outbound_templates, outbound_broadcasts, outbound_messages, outbound_optouts)
+++  - API contract: `arch/contracts/outbound-broadcast.json`
+++  - Error codes: INV-OB-001 ~ INV-OB-010
+++
++ ### Tech Stack
++ | Component | Technology |
++ |-----------|------------|
++@@ -65,7 +78,7 @@
++ | ChatAnalysis | 7101 | Active |
++ | AgentAI | 7105 | Implemented (GR-1.11) |
++ | Integrations | 7106 | Reserved (Phase 2+) |
++-| Outbound | 7107 | Reserved (Phase 1) |
+++| Outbound | 7107 | Implemented (GR-1.3) |
++ | Automation | 7108 | Implemented (GR-1.1) |
++ | Simulator | 4500 | Dev-only tool (Node.js) |
++ 
++@@ -73,11 +86,11 @@
++ - **Script:** `dev-to-invekto-services.bat`
++ - **Protokol:** FTPES (explicit TLS)
++ - **FTP Host:** services.invekto.com
++-- **Sunucu Yapi:** `E:\Invekto\Backend\current\`, `E:\Invekto\ChatAnalysis\current\`, `E:\Invekto\Automation\current\`, `E:\Invekto\AgentAI\current\`
+++- **Sunucu Yapi:** `E:\Invekto\Backend\current\`, `E:\Invekto\ChatAnalysis\current\`, `E:\Invekto\Automation\current\`, `E:\Invekto\AgentAI\current\`, `E:\Invekto\Outbound\current\`
++ - **Sunucu Domain:** services.invekto.com
++ - **Sunucu Root:** `E:\Invekto\` (Backend, ChatAnalysis, scripts, logs)
++ - **Service Manager:** NSSM (`E:\nssm.exe`)
++-- **Servisler:** InvektoBackend, InvektoChatAnalysis, InvektoAutomation, InvektoAgentAI, InvektoDeployWatcher (auto-start, auto-restart)
+++- **Servisler:** InvektoBackend, InvektoChatAnalysis, InvektoAutomation, InvektoAgentAI, InvektoOutbound, InvektoDeployWatcher (auto-start, auto-restart)
++ - **Deploy Watcher:** `E:\Invekto\scripts\deploy-watcher.ps1` (flag-based stop/start)
++ - **.NET Runtime:** ASP.NET Core 8.0.23 (`C:\Program Files\dotnet`)
++ - **PostgreSQL:** localhost:5432 / invekto DB (pgAdmin ile yonetim)
++@@ -102,7 +115,7 @@
++ - [x] ~~Q: agentai.sql calistir~~ (Tamamlandi)
++ - [x] ~~Q: AgentAI appsettings.Production.json doldur~~ (Tamamlandi)
++ - [x] ~~Q: AgentAI deploy + Windows Service kurulumu~~ (Tamamlandi - InvektoAgentAI SERVICE_RUNNING)
++-- [ ] **GR-1.3 Outbound Service** (Port 7107) - Broadcast, trigger, template engine, rate limiting
+++- [x] ~~GR-1.3 Outbound Service~~ (Tamamlandi - Port 7107, Build PASS, /rev bekliyor)
++ 
++ ### Known Issues
++ - (Hen╬ô├╢┬ú╬ô├▓┬Ñz yok)
++@@ -131,6 +144,10 @@
++ | 2026-02-11 | Per-agent feedback learning | Son 20 interaction Claude prompt'a enjekte, kisisel oneri |
++ | 2026-02-11 | Async feedback (fire-and-forget) | Agent accept/edit/reject sonrasi POST, response beklenmez |
++ | 2026-02-11 | Backend proxy for simulator | Tum simulator trafigi Backend:5000 uzerinden, internal servisler localhost-only |
+++| 2026-02-12 | Outbound ayri mikroservis | Broadcast + trigger engine, Port 7107, Backend proxy pattern |
+++| 2026-02-12 | In-memory rate limiter | Tenant bazli sliding window, queue (reject degil), configurable msg/min |
+++| 2026-02-12 | FOR UPDATE SKIP LOCKED | Message dequeue icin safe concurrency, batch 10 |
+++| 2026-02-12 | Stop keyword detection | STOP, DUR, IPTAL, CIKIS - exact match on trimmed uppercase |
++ 
++ ---
++ 
++@@ -145,6 +162,7 @@ src/
++ Γò¼├┤Γö£ΓòóΓö£ΓîÉ   Γò¼├┤Γö£ΓòóΓö¼├║Γò¼├┤Γö£ΓòóΓö£├ºΓò¼├┤Γö£ΓòóΓö£├º DTOs/
++ Γò¼├┤Γö£ΓòóΓö£ΓîÉ   Γò¼├┤Γö£ΓòóΓö£ΓîÉ   Γò¼├┤Γö£ΓòóΓö¼├║Γò¼├┤Γö£ΓòóΓö£├ºΓò¼├┤Γö£ΓòóΓö£├º AgentAI/          # GR-1.11: Suggest/Feedback DTOs
++ Γò¼├┤Γö£ΓòóΓö£ΓîÉ   Γò¼├┤Γö£ΓòóΓö£ΓîÉ   Γò¼├┤Γö£ΓòóΓö¼├║Γò¼├┤Γö£ΓòóΓö£├ºΓò¼├┤Γö£ΓòóΓö£├º ChatAnalysis/
+++Γò¼├┤Γö£ΓòóΓö£ΓîÉ   Γò¼├┤Γö£ΓòóΓö£ΓîÉ   Γò¼├┤Γö£ΓòóΓö¼├║Γò¼├┤Γö£ΓòóΓö£├ºΓò¼├┤Γö£ΓòóΓö£├º Outbound/          # GR-1.3: Broadcast/Template/Webhook DTOs
++ Γò¼├┤Γö£ΓòóΓö£ΓîÉ   Γò¼├┤Γö£ΓòóΓö£ΓîÉ   Γò¼├┤Γö£ΓòóΓö£ΓòóΓò¼├┤Γö£ΓòóΓö£├ºΓò¼├┤Γö£ΓòóΓö£├º Integration/      # GR-1.9: Webhook/Callback DTOs
++ Γò¼├┤Γö£ΓòóΓö£ΓîÉ   Γò¼├┤Γö£ΓòóΓö¼├║Γò¼├┤Γö£ΓòóΓö£├ºΓò¼├┤Γö£ΓòóΓö£├º Integration/          # GR-1.9: Callback client
++ Γò¼├┤Γö£ΓòóΓö£ΓîÉ   Γò¼├┤Γö£ΓòóΓö£ΓòóΓò¼├┤Γö£ΓòóΓö£├ºΓò¼├┤Γö£ΓòóΓö£├º Logging/
++@@ -157,10 +175,14 @@ src/
++ Γò¼├┤Γö£ΓòóΓö£ΓîÉ   Γò¼├┤Γö£ΓòóΓö¼├║Γò¼├┤Γö£ΓòóΓö£├ºΓò¼├┤Γö£ΓòóΓö£├º Data/                # AutomationRepository
++ Γò¼├┤Γö£ΓòóΓö£ΓîÉ   Γò¼├┤Γö£ΓòóΓö¼├║Γò¼├┤Γö£ΓòóΓö£├ºΓò¼├┤Γö£ΓòóΓö£├º Middleware/           # Traffic logging + JWT auth
++ Γò¼├┤Γö£ΓòóΓö£ΓîÉ   Γò¼├┤Γö£ΓòóΓö£ΓòóΓò¼├┤Γö£ΓòóΓö£├ºΓò¼├┤Γö£ΓòóΓö£├º Services/            # FlowEngine, IntentDetector, FaqMatcher, WorkingHoursChecker, AutomationOrchestrator
+++Γò¼├┤Γö£ΓòóΓö¼├║Γò¼├┤Γö£ΓòóΓö£├ºΓò¼├┤Γö£ΓòóΓö£├º Invekto.Outbound/         # GR-1.3: Broadcast & Trigger Engine (Port 7107)
+++Γò¼├┤Γö£ΓòóΓö£ΓîÉ   Γò¼├┤Γö£ΓòóΓö¼├║Γò¼├┤Γö£ΓòóΓö£├ºΓò¼├┤Γö£ΓòóΓö£├º Data/                # OutboundRepository
+++Γò¼├┤Γö£ΓòóΓö£ΓîÉ   Γò¼├┤Γö£ΓòóΓö¼├║Γò¼├┤Γö£ΓòóΓö£├ºΓò¼├┤Γö£ΓòóΓö£├º Middleware/           # Traffic logging + JWT auth
+++Γò¼├┤Γö£ΓòóΓö£ΓîÉ   Γò¼├┤Γö£ΓòóΓö£ΓòóΓò¼├┤Γö£ΓòóΓö£├ºΓò¼├┤Γö£ΓòóΓö£├º Services/            # BroadcastOrchestrator, TriggerProcessor, MessageSenderService, TemplateEngine, OptOutManager, RateLimiter
++ Γò¼├┤Γö£ΓòóΓö£ΓòóΓò¼├┤Γö£ΓòóΓö£├ºΓò¼├┤Γö£ΓòóΓö£├º Invekto.Backend/          # Backend API (Port 5000)
++     Γò¼├┤Γö£ΓòóΓö¼├║Γò¼├┤Γö£ΓòóΓö£├ºΓò¼├┤Γö£ΓòóΓö£├º Dashboard/            # React/TS Ops Dashboard
++     Γò¼├┤Γö£ΓòóΓö¼├║Γò¼├┤Γö£ΓòóΓö£├ºΓò¼├┤Γö£ΓòóΓö£├º Middleware/            # Traffic logging + JWT auth
++-    Γò¼├┤Γö£ΓòóΓö£ΓòóΓò¼├┤Γö£ΓòóΓö£├ºΓò¼├┤Γö£ΓòóΓö£├º Services/             # ChatAnalysisClient, AutomationClient, AgentAIClient
+++    Γò¼├┤Γö£ΓòóΓö£ΓòóΓò¼├┤Γö£ΓòóΓö£├ºΓò¼├┤Γö£ΓòóΓö£├º Services/             # ChatAnalysisClient, AutomationClient, AgentAIClient, OutboundClient
++ ```
++ 
++ ---
++@@ -168,13 +190,13 @@ src/
++ ## Context for Next Session
++ 
++ Sonraki session'da:
++-1. **GR-1.3 Invekto.Outbound** mikroservisi (Port 7107) implement et
++-2. Scope: Broadcast/toplu mesaj, trigger engine, template engine, rate limiting, opt-out, delivery tracking
++-3. DB tablolari: outbound_templates, outbound_messages, outbound_optouts (roadmap-phases.md'de tanimli)
++-4. Mimari: Backend proxy pattern (Main App -> Backend:5000 -> Outbound:7107, localhost-only)
++-5. Mevcut pattern'leri takip et: Automation + AgentAI servisleri referans
++-6. Firewall: localhost-only (remoteip=127.0.0.1) - Backend proxy uzerinden erisim
++-7. Deploy sonrasi: outbound.sql calistir, appsettings.Production.json doldur, NSSM servis kur
+++1. **GR-1.3 Outbound /rev tamamla** - Codex review prompt gonder, PASS/FAIL bekle
+++2. Deploy sonrasi Q'nun yapacaklari:
+++   - `outbound.sql` calistir (PostgreSQL'de tablolari olustur)
+++   - `appsettings.Production.json` doldur (JWT key, PostgreSQL connection, callback URL)
+++   - NSSM servis kur: `install-services.bat` (veya manual InvektoOutbound)
+++   - Firewall: Port 7107 localhost-only (zaten firewall-rules.bat'a eklendi)
+++3. Test: `http://localhost:7107/health` (Outbound direkt) veya `http://services.invekto.com:5000/api/v1/outbound/health` (Backend proxy)
++ 
++ ---
++ 
++diff --git a/dev-to-invekto-services.bat b/dev-to-invekto-services.bat
++index 3d91641..54fb911 100644
++--- a/dev-to-invekto-services.bat
+++++ b/dev-to-invekto-services.bat
++@@ -27,6 +27,7 @@ set "REMOTE_BACKEND=/e/Invekto/Backend/current"
++ set "REMOTE_CHATANALYSIS=/e/Invekto/ChatAnalysis/current"
++ set "REMOTE_AUTOMATION=/e/Invekto/Automation/current"
++ set "REMOTE_AGENTAI=/e/Invekto/AgentAI/current"
+++set "REMOTE_OUTBOUND=/e/Invekto/Outbound/current"
++ set "REMOTE_SIMULATOR=/e/Invekto/Simulator"
++ 
++ REM Local paths
++@@ -36,6 +37,7 @@ set "LOCAL_BACKEND=%LOCAL_DEPLOY%\Backend"
++ set "LOCAL_CHATANALYSIS=%LOCAL_DEPLOY%\ChatAnalysis"
++ set "LOCAL_AUTOMATION=%LOCAL_DEPLOY%\Automation"
++ set "LOCAL_AGENTAI=%LOCAL_DEPLOY%\AgentAI"
+++set "LOCAL_OUTBOUND=%LOCAL_DEPLOY%\Outbound"
++ set "LOCAL_SIMULATOR=%~dp0tools\simulator"
++ 
++ REM Check WinSCP exists
++@@ -51,6 +53,7 @@ if not exist "!LOCAL_BACKEND!" mkdir "!LOCAL_BACKEND!"
++ if not exist "!LOCAL_CHATANALYSIS!" mkdir "!LOCAL_CHATANALYSIS!"
++ if not exist "!LOCAL_AUTOMATION!" mkdir "!LOCAL_AUTOMATION!"
++ if not exist "!LOCAL_AGENTAI!" mkdir "!LOCAL_AGENTAI!"
+++if not exist "!LOCAL_OUTBOUND!" mkdir "!LOCAL_OUTBOUND!"
++ 
++ echo ============================================
++ echo [1/5] Building Backend...
++@@ -105,10 +108,23 @@ if errorlevel 1 (
++ echo [OK] AgentAI built to !LOCAL_AGENTAI!
++ echo.
++ 
+++echo ============================================
+++echo [5/5] Building Outbound...
+++echo ============================================
+++echo.
+++
+++dotnet publish src/Invekto.Outbound/Invekto.Outbound.csproj -c Release -o "!LOCAL_OUTBOUND!" --self-contained false
+++if errorlevel 1 (
+++    echo [ERROR] Outbound build failed!
+++    goto :error_exit
+++)
+++echo [OK] Outbound built to !LOCAL_OUTBOUND!
+++echo.
+++
++ REM Q: Create build marker
++ for /f "tokens=*" %%i in ('git rev-parse --short HEAD 2^>nul') do set "GIT_HASH=%%i"
++ for /f "tokens=*" %%i in ('git rev-parse --abbrev-ref HEAD 2^>nul') do set "GIT_BRANCH=%%i"
++-powershell -NoProfile -Command "$marker = @{ timestamp = (Get-Date).ToString('o'); gitHash = '%GIT_HASH%'; gitBranch = '%GIT_BRANCH%'; services = @('Backend','ChatAnalysis','Automation','AgentAI') }; [System.IO.File]::WriteAllText('!LOCAL_DEPLOY!\.build-marker.json', ($marker | ConvertTo-Json))"
+++powershell -NoProfile -Command "$marker = @{ timestamp = (Get-Date).ToString('o'); gitHash = '%GIT_HASH%'; gitBranch = '%GIT_BRANCH%'; services = @('Backend','ChatAnalysis','Automation','AgentAI','Outbound') }; [System.IO.File]::WriteAllText('!LOCAL_DEPLOY!\.build-marker.json', ($marker | ConvertTo-Json))"
++ echo [OK] Build marker created (%GIT_BRANCH%@%GIT_HASH%)
++ echo.
++ 
++@@ -147,10 +163,12 @@ echo Local Backend:      !LOCAL_BACKEND!
++ echo Local ChatAnalysis: !LOCAL_CHATANALYSIS!
++ echo Local Automation:   !LOCAL_AUTOMATION!
++ echo Local AgentAI:      !LOCAL_AGENTAI!
+++echo Local Outbound:     !LOCAL_OUTBOUND!
++ echo Remote Backend:     %REMOTE_BACKEND%
++ echo Remote ChatAnalysis: %REMOTE_CHATANALYSIS%
++ echo Remote Automation:  %REMOTE_AUTOMATION%
++ echo Remote AgentAI:     %REMOTE_AGENTAI%
+++echo Remote Outbound:    %REMOTE_OUTBOUND%
++ echo.
++ echo Mode: Synchronize (only changed files)
++ 
++@@ -167,6 +185,7 @@ set "WINSCP_SCRIPT=%TEMP%\winscp_invekto_deploy.txt"
++     echo mkdir "%REMOTE_CHATANALYSIS%"
++     echo mkdir "%REMOTE_AUTOMATION%"
++     echo mkdir "%REMOTE_AGENTAI%"
+++    echo mkdir "%REMOTE_OUTBOUND%"
++     echo mkdir "%REMOTE_SIMULATOR%"
++     echo option batch abort
++     echo echo Uploading Backend to STAGING...
++@@ -177,6 +196,8 @@ set "WINSCP_SCRIPT=%TEMP%\winscp_invekto_deploy.txt"
++     echo synchronize remote "!LOCAL_AUTOMATION!" "%REMOTE_AUTOMATION%" -mirror -transfer=binary -criteria=size,time -resumesupport=on -filemask="|appsettings.Production.json"
++     echo echo Uploading AgentAI to STAGING...
++     echo synchronize remote "!LOCAL_AGENTAI!" "%REMOTE_AGENTAI%" -mirror -transfer=binary -criteria=size,time -resumesupport=on -filemask="|appsettings.Production.json"
+++    echo echo Uploading Outbound to STAGING...
+++    echo synchronize remote "!LOCAL_OUTBOUND!" "%REMOTE_OUTBOUND%" -mirror -transfer=binary -criteria=size,time -resumesupport=on -filemask="|appsettings.Production.json"
++     echo echo Uploading Simulator to STAGING...
++     echo synchronize remote "!LOCAL_SIMULATOR!" "%REMOTE_SIMULATOR%" -mirror -transfer=binary -criteria=size,time -resumesupport=on -filemask="|node_modules/;.env"
++     echo echo Uploading build marker...
++@@ -246,6 +267,7 @@ echo   Backend:      %REMOTE_BACKEND%
++ echo   ChatAnalysis: %REMOTE_CHATANALYSIS%
++ echo   Automation:   %REMOTE_AUTOMATION%
++ echo   AgentAI:      %REMOTE_AGENTAI%
+++echo   Outbound:     %REMOTE_OUTBOUND%
++ echo   Simulator:    %REMOTE_SIMULATOR%
++ echo.
++ echo ============================================
++diff --git a/src/Invekto.Backend/Program.cs b/src/Invekto.Backend/Program.cs
++index 5e9fc0a..efb6fe7 100644
++--- a/src/Invekto.Backend/Program.cs
+++++ b/src/Invekto.Backend/Program.cs
++@@ -29,6 +29,10 @@ var agentAIUrl = builder.Configuration["Microservice:AgentAI:Url"]
++     ?? $"http://localhost:{ServiceConstants.AgentAIPort}";
++ var agentAILogPath = builder.Configuration["Microservice:AgentAI:LogPath"];
++ var agentAISuggestTimeoutMs = builder.Configuration.GetValue<int>("Microservice:AgentAI:SuggestTimeoutMs", 15000);
+++var outboundUrl = builder.Configuration["Microservice:Outbound:Url"]
+++    ?? $"http://localhost:{ServiceConstants.OutboundPort}";
+++var outboundLogPath = builder.Configuration["Microservice:Outbound:LogPath"];
+++var outboundTimeoutMs = builder.Configuration.GetValue<int>("Microservice:Outbound:TimeoutMs", 10000);
++ 
++ // Register JSON Lines logger
++ builder.Services.AddSingleton(new JsonLinesLogger(ServiceConstants.BackendServiceName, logPath));
++@@ -47,6 +51,10 @@ if (!string.IsNullOrEmpty(agentAILogPath))
++ {
++     logPaths.Add(agentAILogPath);
++ }
+++if (!string.IsNullOrEmpty(outboundLogPath))
+++{
+++    logPaths.Add(outboundLogPath);
+++}
++ builder.Services.AddSingleton(new LogReader(logPaths.ToArray(), slowThresholdMs));
++ 
++ // Register log cleanup service (30 day retention)
++@@ -80,6 +88,13 @@ builder.Services.AddHttpClient<AgentAIClient>(client =>
++     client.Timeout = TimeSpan.FromMilliseconds(agentAISuggestTimeoutMs);
++ });
++ 
+++// Configure Outbound HTTP client (GR-1.3)
+++builder.Services.AddHttpClient<OutboundClient>(client =>
+++{
+++    client.BaseAddress = new Uri(outboundUrl);
+++    client.Timeout = TimeSpan.FromMilliseconds(outboundTimeoutMs);
+++});
+++
++ // ============================================
++ // GR-1.9: INTEGRATION BRIDGE SETUP
++ // ============================================
++@@ -133,7 +148,7 @@ app.UseTrafficLogging();
++ if (jwtValidator != null)
++ {
++     var jwtLogger = app.Services.GetRequiredService<JsonLinesLogger>();
++-    app.UseJwtAuth(jwtValidator, jwtLogger, "/api/v1/webhook/", "/api/v1/automation/");
+++    app.UseJwtAuth(jwtValidator, jwtLogger, "/api/v1/webhook/", "/api/v1/automation/", "/api/v1/outbound/");
++ }
++ 
++ // Enable static file serving for Dashboard UI (wwwroot/)
++@@ -171,7 +186,7 @@ bool ValidateOpsAuth(HttpContext ctx)
++ }
++ 
++ // OPS endpoint - Stage-0 troubleshooting dashboard
++-app.MapGet("/ops", async (HttpContext ctx, ChatAnalysisClient chatClient, AutomationClient automationClient, AgentAIClient agentAIClient, LogReader logReader) =>
+++app.MapGet("/ops", async (HttpContext ctx, ChatAnalysisClient chatClient, AutomationClient automationClient, AgentAIClient agentAIClient, OutboundClient outboundClient, LogReader logReader) =>
++ {
++     if (!ValidateOpsAuth(ctx))
++     {
++@@ -182,6 +197,7 @@ app.MapGet("/ops", async (HttpContext ctx, ChatAnalysisClient chatClient, Automa
++     var chatHealthy = await chatClient.CheckHealthAsync();
++     var autoHealthy = await automationClient.CheckHealthAsync();
++     var agentAIHealthy = await agentAIClient.CheckHealthAsync();
+++    var outboundHealthy = await outboundClient.CheckHealthAsync();
++ 
++     var ops = new
++     {
++@@ -192,7 +208,8 @@ app.MapGet("/ops", async (HttpContext ctx, ChatAnalysisClient chatClient, Automa
++             backend = new { status = "ok" },
++             chatAnalysis = new { status = chatHealthy ? "ok" : "unavailable" },
++             automation = new { status = autoHealthy ? "ok" : "unavailable" },
++-            agentAI = new { status = agentAIHealthy ? "ok" : "unavailable" }
+++            agentAI = new { status = agentAIHealthy ? "ok" : "unavailable" },
+++            outbound = new { status = outboundHealthy ? "ok" : "unavailable" }
++         },
++         info = new
++         {
++@@ -355,7 +372,7 @@ app.MapGet("/ops/search", async (HttpContext ctx, LogReader logReader, string? r
++ // ============================================
++ 
++ // Dashboard: Service health with response times
++-app.MapGet("/api/ops/health", async (HttpContext ctx, ChatAnalysisClient chatClient, AutomationClient automationClient, AgentAIClient agentAIClient) =>
+++app.MapGet("/api/ops/health", async (HttpContext ctx, ChatAnalysisClient chatClient, AutomationClient automationClient, AgentAIClient agentAIClient, OutboundClient outboundClient) =>
++ {
++     if (!ValidateOpsAuth(ctx))
++     {
++@@ -372,7 +389,7 @@ app.MapGet("/api/ops/health", async (HttpContext ctx, ChatAnalysisClient chatCli
++         name = ServiceConstants.BackendServiceName,
++         status = "ok",
++         responseTimeMs = 0,
++-        uptimeSeconds = (long?)null, // Not tracked
+++        uptimeSeconds = (long?)null,
++         lastCheck = now
++     });
++ 
++@@ -386,7 +403,7 @@ app.MapGet("/api/ops/health", async (HttpContext ctx, ChatAnalysisClient chatCli
++         name = ServiceConstants.ChatAnalysisServiceName,
++         status = chatHealthy ? "ok" : "unavailable",
++         responseTimeMs = chatHealthy ? (int?)sw.ElapsedMilliseconds : null,
++-        uptimeSeconds = (long?)null, // Not tracked
+++        uptimeSeconds = (long?)null,
++         lastCheck = now,
++         error = chatHealthy ? null : "Service unreachable"
++     });
++@@ -421,6 +438,21 @@ app.MapGet("/api/ops/health", async (HttpContext ctx, ChatAnalysisClient chatCli
++         error = agentAIHealthy ? null : "Service unreachable"
++     });
++ 
+++    // Outbound - check health with timing (GR-1.3)
+++    var swOutbound = System.Diagnostics.Stopwatch.StartNew();
+++    var outboundHealthy = await outboundClient.CheckHealthAsync();
+++    swOutbound.Stop();
+++
+++    services.Add(new
+++    {
+++        name = ServiceConstants.OutboundServiceName,
+++        status = outboundHealthy ? "ok" : "unavailable",
+++        responseTimeMs = outboundHealthy ? (int?)swOutbound.ElapsedMilliseconds : null,
+++        uptimeSeconds = (long?)null,
+++        lastCheck = now,
+++        error = outboundHealthy ? null : "Service unreachable"
+++    });
+++
++     return Results.Ok(new
++     {
++         timestamp = now,
++@@ -570,6 +602,7 @@ app.MapPost("/api/ops/services/{serviceName}/restart", async (HttpContext ctx, s
++         "Invekto.ChatAnalysis" => "Invekto.Microservice.Chat",
++         "Invekto.Automation" => "InvektoAutomation",
++         "Invekto.AgentAI" => "InvektoAgentAI",
+++        "Invekto.Outbound" => "InvektoOutbound",
++         _ => null
++     };
++ 
++@@ -623,7 +656,7 @@ app.MapPost("/api/ops/services/{serviceName}/restart", async (HttpContext ctx, s
++ });
++ 
++ // Dashboard: Test proxy for external services (avoids CORS issues)
++-app.MapGet("/api/ops/test/{serviceName}/{*path}", async (HttpContext ctx, ChatAnalysisClient chatClient, AutomationClient automationClient, AgentAIClient agentAIClient, string serviceName, string? path) =>
+++app.MapGet("/api/ops/test/{serviceName}/{*path}", async (HttpContext ctx, ChatAnalysisClient chatClient, AutomationClient automationClient, AgentAIClient agentAIClient, OutboundClient outboundClient, string serviceName, string? path) =>
++ {
++     if (!ValidateOpsAuth(ctx))
++     {
++@@ -680,6 +713,21 @@ app.MapGet("/api/ops/test/{serviceName}/{*path}", async (HttpContext ctx, ChatAn
++             });
++         }
++ 
+++        if (serviceName == "outbound")
+++        {
+++            var endpoint = "/" + (path ?? "health");
+++            var result = await outboundClient.TestEndpointAsync(endpoint);
+++            sw.Stop();
+++
+++            return Results.Ok(new
+++            {
+++                success = result.Success,
+++                statusCode = result.StatusCode,
+++                durationMs = sw.ElapsedMilliseconds,
+++                message = result.Message
+++            });
+++        }
+++
++         return Results.BadRequest(new { success = false, message = "Unknown service" });
++     }
++     catch (Exception ex)
++@@ -905,7 +953,7 @@ app.MapPost("/api/v1/chat/analyze", async (
++ });
++ 
++ // Endpoint discovery - returns all services' endpoints (aggregated)
++-app.MapGet("/api/ops/endpoints", async (HttpContext ctx, ChatAnalysisClient chatClient, AutomationClient automationClient, AgentAIClient agentAIClient) =>
+++app.MapGet("/api/ops/endpoints", async (HttpContext ctx, ChatAnalysisClient chatClient, AutomationClient automationClient, AgentAIClient agentAIClient, OutboundClient outboundClient) =>
++ {
++     if (!ValidateOpsAuth(ctx))
++     {
++@@ -929,6 +977,19 @@ app.MapGet("/api/ops/endpoints", async (HttpContext ctx, ChatAnalysisClient chat
++             new() { Method = "POST", Path = "/api/v1/agent-assist/feedback", Description = "Agent feedback proxy (Backend -> AgentAI)", Auth = "Bearer", Category = "API" },
++             // Automation proxy endpoint
++             new() { Method = "POST", Path = "/api/v1/automation/webhook", Description = "Webhook event proxy (Backend -> Automation)", Auth = "Bearer", Category = "API" },
+++            // Outbound proxy endpoints (GR-1.3)
+++            new() { Method = "POST", Path = "/api/v1/outbound/broadcast/send", Description = "Broadcast send proxy (Backend -> Outbound)", Auth = "Bearer", Category = "API" },
+++            new() { Method = "GET", Path = "/api/v1/outbound/broadcast/{broadcastId}/status", Description = "Broadcast status proxy", Auth = "Bearer", Category = "API" },
+++            new() { Method = "POST", Path = "/api/v1/outbound/webhook/trigger", Description = "Trigger event proxy", Auth = "Bearer", Category = "API" },
+++            new() { Method = "POST", Path = "/api/v1/outbound/webhook/delivery-status", Description = "Delivery status proxy", Auth = "Bearer", Category = "API" },
+++            new() { Method = "POST", Path = "/api/v1/outbound/webhook/message", Description = "Incoming message proxy (opt-out)", Auth = "Bearer", Category = "API" },
+++            new() { Method = "GET", Path = "/api/v1/outbound/templates", Description = "List templates proxy", Auth = "Bearer", Category = "API" },
+++            new() { Method = "POST", Path = "/api/v1/outbound/templates", Description = "Create template proxy", Auth = "Bearer", Category = "API" },
+++            new() { Method = "PUT", Path = "/api/v1/outbound/templates/{id}", Description = "Update template proxy", Auth = "Bearer", Category = "API" },
+++            new() { Method = "DELETE", Path = "/api/v1/outbound/templates/{id}", Description = "Deactivate template proxy", Auth = "Bearer", Category = "API" },
+++            new() { Method = "POST", Path = "/api/v1/outbound/optout", Description = "Add opt-out proxy", Auth = "Bearer", Category = "API" },
+++            new() { Method = "DELETE", Path = "/api/v1/outbound/optout/{phone}", Description = "Remove opt-out proxy", Auth = "Bearer", Category = "API" },
+++            new() { Method = "GET", Path = "/api/v1/outbound/optout/check/{phone}", Description = "Check opt-out proxy", Auth = "Bearer", Category = "API" },
++ 
++             // Health
++             new() { Method = "GET", Path = "/health", Description = "Health check", Auth = "none", Category = "Health" },
++@@ -963,6 +1024,9 @@ app.MapGet("/api/ops/endpoints", async (HttpContext ctx, ChatAnalysisClient chat
++     // Fetch AgentAI endpoints (internal call)
++     var agentAIEndpoints = await agentAIClient.GetEndpointsAsync();
++ 
+++    // Fetch Outbound endpoints (internal call, GR-1.3)
+++    var outboundEndpoints = await outboundClient.GetEndpointsAsync();
+++
++     var services = new List<EndpointDiscoveryResponse> { backendEndpoints };
++     if (chatEndpoints != null)
++     {
++@@ -976,6 +1040,10 @@ app.MapGet("/api/ops/endpoints", async (HttpContext ctx, ChatAnalysisClient chat
++     {
++         services.Add(agentAIEndpoints);
++     }
+++    if (outboundEndpoints != null)
+++    {
+++        services.Add(outboundEndpoints);
+++    }
++ 
++     return Results.Ok(new { services });
++ });
++@@ -1275,6 +1343,115 @@ app.MapPost("/api/v1/automation/webhook", async (HttpContext ctx, AutomationClie
++     return Results.Empty;
++ });
++ 
+++// ============================================
+++// OUTBOUND PROXY ENDPOINTS (GR-1.3)
+++// ============================================
+++
+++// Generic outbound proxy helper
+++async Task<IResult> OutboundProxyPost(HttpContext ctx, OutboundClient obClient, JsonLinesLogger jsonLog, string targetPath)
+++{
+++    var requestId = ctx.Request.Headers["X-Request-Id"].FirstOrDefault() ?? Guid.NewGuid().ToString("N");
+++    var authHeader = ctx.Request.Headers.Authorization.FirstOrDefault();
+++
+++    string requestBody;
+++    using (var reader = new StreamReader(ctx.Request.Body))
+++        requestBody = await reader.ReadToEndAsync();
+++
+++    var sw = System.Diagnostics.Stopwatch.StartNew();
+++    var (statusCode, body) = await obClient.ProxyPostAsync(targetPath, requestBody, authHeader, requestId);
+++    sw.Stop();
+++
+++    jsonLog.StepInfo($"Outbound proxy POST {targetPath}: status={statusCode}, time={sw.ElapsedMilliseconds}ms", requestId);
+++
+++    ctx.Response.StatusCode = statusCode;
+++    ctx.Response.ContentType = "application/json";
+++    if (body != null) await ctx.Response.WriteAsync(body);
+++    return Results.Empty;
+++}
+++
+++async Task<IResult> OutboundProxyGet(HttpContext ctx, OutboundClient obClient, JsonLinesLogger jsonLog, string targetPath)
+++{
+++    var requestId = ctx.Request.Headers["X-Request-Id"].FirstOrDefault() ?? Guid.NewGuid().ToString("N");
+++    var authHeader = ctx.Request.Headers.Authorization.FirstOrDefault();
+++
+++    var (statusCode, body) = await obClient.ProxyGetAsync(targetPath, authHeader, requestId);
+++
+++    ctx.Response.StatusCode = statusCode;
+++    ctx.Response.ContentType = "application/json";
+++    if (body != null) await ctx.Response.WriteAsync(body);
+++    return Results.Empty;
+++}
+++
+++async Task<IResult> OutboundProxyPut(HttpContext ctx, OutboundClient obClient, JsonLinesLogger jsonLog, string targetPath)
+++{
+++    var requestId = ctx.Request.Headers["X-Request-Id"].FirstOrDefault() ?? Guid.NewGuid().ToString("N");
+++    var authHeader = ctx.Request.Headers.Authorization.FirstOrDefault();
+++
+++    string requestBody;
+++    using (var reader = new StreamReader(ctx.Request.Body))
+++        requestBody = await reader.ReadToEndAsync();
+++
+++    var (statusCode, body) = await obClient.ProxyPutAsync(targetPath, requestBody, authHeader, requestId);
+++
+++    ctx.Response.StatusCode = statusCode;
+++    ctx.Response.ContentType = "application/json";
+++    if (body != null) await ctx.Response.WriteAsync(body);
+++    return Results.Empty;
+++}
+++
+++async Task<IResult> OutboundProxyDelete(HttpContext ctx, OutboundClient obClient, JsonLinesLogger jsonLog, string targetPath)
+++{
+++    var requestId = ctx.Request.Headers["X-Request-Id"].FirstOrDefault() ?? Guid.NewGuid().ToString("N");
+++    var authHeader = ctx.Request.Headers.Authorization.FirstOrDefault();
+++
+++    var (statusCode, body) = await obClient.ProxyDeleteAsync(targetPath, authHeader, requestId);
+++
+++    ctx.Response.StatusCode = statusCode;
+++    ctx.Response.ContentType = "application/json";
+++    if (body != null) await ctx.Response.WriteAsync(body);
+++    return Results.Empty;
+++}
+++
+++// Broadcast
+++app.MapPost("/api/v1/outbound/broadcast/send", async (HttpContext ctx, OutboundClient obClient, JsonLinesLogger jsonLog) =>
+++    await OutboundProxyPost(ctx, obClient, jsonLog, "/api/v1/broadcast/send"));
+++
+++app.MapGet("/api/v1/outbound/broadcast/{broadcastId}/status", async (HttpContext ctx, OutboundClient obClient, JsonLinesLogger jsonLog, string broadcastId) =>
+++    await OutboundProxyGet(ctx, obClient, jsonLog, $"/api/v1/broadcast/{broadcastId}/status"));
+++
+++// Webhooks
+++app.MapPost("/api/v1/outbound/webhook/trigger", async (HttpContext ctx, OutboundClient obClient, JsonLinesLogger jsonLog) =>
+++    await OutboundProxyPost(ctx, obClient, jsonLog, "/api/v1/webhook/trigger"));
+++
+++app.MapPost("/api/v1/outbound/webhook/delivery-status", async (HttpContext ctx, OutboundClient obClient, JsonLinesLogger jsonLog) =>
+++    await OutboundProxyPost(ctx, obClient, jsonLog, "/api/v1/webhook/delivery-status"));
+++
+++app.MapPost("/api/v1/outbound/webhook/message", async (HttpContext ctx, OutboundClient obClient, JsonLinesLogger jsonLog) =>
+++    await OutboundProxyPost(ctx, obClient, jsonLog, "/api/v1/webhook/message"));
+++
+++// Templates
+++app.MapGet("/api/v1/outbound/templates", async (HttpContext ctx, OutboundClient obClient, JsonLinesLogger jsonLog) =>
+++    await OutboundProxyGet(ctx, obClient, jsonLog, "/api/v1/templates"));
+++
+++app.MapPost("/api/v1/outbound/templates", async (HttpContext ctx, OutboundClient obClient, JsonLinesLogger jsonLog) =>
+++    await OutboundProxyPost(ctx, obClient, jsonLog, "/api/v1/templates"));
+++
+++app.MapPut("/api/v1/outbound/templates/{id:int}", async (HttpContext ctx, OutboundClient obClient, JsonLinesLogger jsonLog, int id) =>
+++    await OutboundProxyPut(ctx, obClient, jsonLog, $"/api/v1/templates/{id}"));
+++
+++app.MapDelete("/api/v1/outbound/templates/{id:int}", async (HttpContext ctx, OutboundClient obClient, JsonLinesLogger jsonLog, int id) =>
+++    await OutboundProxyDelete(ctx, obClient, jsonLog, $"/api/v1/templates/{id}"));
+++
+++// Opt-out
+++app.MapPost("/api/v1/outbound/optout", async (HttpContext ctx, OutboundClient obClient, JsonLinesLogger jsonLog) =>
+++    await OutboundProxyPost(ctx, obClient, jsonLog, "/api/v1/optout"));
+++
+++app.MapDelete("/api/v1/outbound/optout/{phone}", async (HttpContext ctx, OutboundClient obClient, JsonLinesLogger jsonLog, string phone) =>
+++    await OutboundProxyDelete(ctx, obClient, jsonLog, $"/api/v1/optout/{phone}"));
+++
+++app.MapGet("/api/v1/outbound/optout/check/{phone}", async (HttpContext ctx, OutboundClient obClient, JsonLinesLogger jsonLog, string phone) =>
+++    await OutboundProxyGet(ctx, obClient, jsonLog, $"/api/v1/optout/check/{phone}"));
+++
++ // SPA fallback - serve index.html for non-API routes (Dashboard routing)
++ app.MapFallbackToFile("index.html");
++ 
++diff --git a/src/Invekto.Backend/Services/OutboundClient.cs b/src/Invekto.Backend/Services/OutboundClient.cs
++new file mode 100644
++index 0000000..db1af9b
++--- /dev/null
+++++ b/src/Invekto.Backend/Services/OutboundClient.cs
++@@ -0,0 +1,152 @@
+++using System.Text;
+++using System.Text.Json;
+++using Invekto.Shared.DTOs;
+++
+++namespace Invekto.Backend.Services;
+++
+++/// <summary>
+++/// HTTP client for Outbound microservice (Port 7107).
+++/// Health checks, endpoint discovery, and generic HTTP proxy for all Outbound endpoints.
+++/// GR-1.3: Broadcast, trigger, template, opt-out proxy.
+++/// </summary>
+++public sealed class OutboundClient
+++{
+++    private readonly HttpClient _httpClient;
+++    private readonly ILogger<OutboundClient> _logger;
+++
+++    public OutboundClient(HttpClient httpClient, ILogger<OutboundClient> logger)
+++    {
+++        _httpClient = httpClient;
+++        _logger = logger;
+++    }
+++
+++    public async Task<bool> CheckHealthAsync(CancellationToken ct = default)
+++    {
+++        try
+++        {
+++            var response = await _httpClient.GetAsync("/health", ct);
+++            return response.IsSuccessStatusCode;
+++        }
+++        catch (Exception ex)
+++        {
+++            _logger.LogWarning(ex, "Outbound health check failed");
+++            return false;
+++        }
+++    }
+++
+++    public async Task<EndpointDiscoveryResponse?> GetEndpointsAsync(CancellationToken ct = default)
+++    {
+++        try
+++        {
+++            var response = await _httpClient.GetAsync("/api/ops/endpoints", ct);
+++            if (response.IsSuccessStatusCode)
+++            {
+++                return await response.Content.ReadFromJsonAsync<EndpointDiscoveryResponse>(ct);
+++            }
+++            return null;
+++        }
+++        catch (Exception ex)
+++        {
+++            _logger.LogWarning(ex, "Outbound endpoint discovery failed");
+++            return null;
+++        }
+++    }
+++
+++    public async Task<TestEndpointResult> TestEndpointAsync(string endpoint, CancellationToken ct = default)
+++    {
+++        try
+++        {
+++            var response = await _httpClient.GetAsync(endpoint, ct);
+++            return new TestEndpointResult
+++            {
+++                Success = response.IsSuccessStatusCode,
+++                StatusCode = (int)response.StatusCode,
+++                Message = response.IsSuccessStatusCode ? "OK" : $"HTTP {(int)response.StatusCode}"
+++            };
+++        }
+++        catch (TaskCanceledException ex)
+++        {
+++            _logger.LogWarning(ex, "Outbound endpoint test timeout: {Endpoint}", endpoint);
+++            return new TestEndpointResult { Success = false, StatusCode = 0, Message = "Timeout" };
+++        }
+++        catch (HttpRequestException ex)
+++        {
+++            _logger.LogWarning(ex, "Outbound endpoint test failed: {Endpoint}", endpoint);
+++            return new TestEndpointResult { Success = false, StatusCode = 0, Message = ex.Message };
+++        }
+++    }
+++
+++    /// <summary>
+++    /// Generic POST proxy - forwards body + auth + request-id to Outbound.
+++    /// </summary>
+++    public async Task<(int StatusCode, string? Body)> ProxyPostAsync(
+++        string path, string requestBody, string? authHeader, string? requestId,
+++        CancellationToken ct = default)
+++    {
+++        return await ProxyRequestAsync(HttpMethod.Post, path, requestBody, authHeader, requestId, ct);
+++    }
+++
+++    /// <summary>
+++    /// Generic GET proxy - forwards auth + request-id to Outbound.
+++    /// </summary>
+++    public async Task<(int StatusCode, string? Body)> ProxyGetAsync(
+++        string path, string? authHeader, string? requestId,
+++        CancellationToken ct = default)
+++    {
+++        return await ProxyRequestAsync(HttpMethod.Get, path, null, authHeader, requestId, ct);
+++    }
+++
+++    /// <summary>
+++    /// Generic PUT proxy - forwards body + auth + request-id to Outbound.
+++    /// </summary>
+++    public async Task<(int StatusCode, string? Body)> ProxyPutAsync(
+++        string path, string requestBody, string? authHeader, string? requestId,
+++        CancellationToken ct = default)
+++    {
+++        return await ProxyRequestAsync(HttpMethod.Put, path, requestBody, authHeader, requestId, ct);
+++    }
+++
+++    /// <summary>
+++    /// Generic DELETE proxy - forwards auth + request-id to Outbound.
+++    /// </summary>
+++    public async Task<(int StatusCode, string? Body)> ProxyDeleteAsync(
+++        string path, string? authHeader, string? requestId,
+++        CancellationToken ct = default)
+++    {
+++        return await ProxyRequestAsync(HttpMethod.Delete, path, null, authHeader, requestId, ct);
+++    }
+++
+++    private async Task<(int StatusCode, string? Body)> ProxyRequestAsync(
+++        HttpMethod method, string path, string? requestBody, string? authHeader, string? requestId,
+++        CancellationToken ct)
+++    {
+++        try
+++        {
+++            using var request = new HttpRequestMessage(method, path);
+++
+++            if (requestBody != null)
+++                request.Content = new StringContent(requestBody, Encoding.UTF8, "application/json");
+++
+++            if (!string.IsNullOrEmpty(authHeader))
+++                request.Headers.TryAddWithoutValidation("Authorization", authHeader);
+++
+++            if (!string.IsNullOrEmpty(requestId))
+++                request.Headers.TryAddWithoutValidation("X-Request-Id", requestId);
+++
+++            using var response = await _httpClient.SendAsync(request, ct);
+++            var body = await response.Content.ReadAsStringAsync(ct);
+++
+++            return ((int)response.StatusCode, body);
+++        }
+++        catch (TaskCanceledException)
+++        {
+++            _logger.LogWarning("Outbound proxy timeout: {Path}", path);
+++            return (504, JsonSerializer.Serialize(new { error_code = "INV-BE-002", message = "Outbound service timeout" }));
+++        }
+++        catch (Exception ex)
+++        {
+++            _logger.LogWarning(ex, "Outbound proxy failed: {Path}", path);
+++            return (502, JsonSerializer.Serialize(new { error_code = "INV-BE-001", message = $"Outbound service unavailable: {ex.Message}" }));
+++        }
+++    }
+++}
++diff --git a/src/Invekto.Backend/appsettings.json b/src/Invekto.Backend/appsettings.json
++index 7fe5bee..3462235 100644
++--- a/src/Invekto.Backend/appsettings.json
+++++ b/src/Invekto.Backend/appsettings.json
++@@ -25,6 +25,11 @@
++       "Url": "http://localhost:7105",
++       "LogPath": "../Invekto.AgentAI/logs",
++       "SuggestTimeoutMs": 15000
+++    },
+++    "Outbound": {
+++      "Url": "http://localhost:7107",
+++      "LogPath": "../Invekto.Outbound/logs",
+++      "TimeoutMs": 10000
++     }
++   },
++   "Jwt": {
++diff --git a/src/Invekto.Outbound/Data/OutboundRepository.cs b/src/Invekto.Outbound/Data/OutboundRepository.cs
++new file mode 100644
++index 0000000..6c21083
++--- /dev/null
+++++ b/src/Invekto.Outbound/Data/OutboundRepository.cs
++@@ -0,0 +1,521 @@
+++using System.Text.Json;
+++using Invekto.Shared.Data;
+++using Invekto.Shared.DTOs.Outbound;
+++using Invekto.Shared.Logging;
+++using Npgsql;
+++
+++namespace Invekto.Outbound.Data;
+++
+++public sealed class OutboundRepository
+++{
+++    private readonly PostgresConnectionFactory _db;
+++    private readonly JsonLinesLogger _logger;
+++
+++    public OutboundRepository(PostgresConnectionFactory db, JsonLinesLogger logger)
+++    {
+++        _db = db;
+++        _logger = logger;
+++    }
+++
+++    // ================================================================
+++    // Templates
+++    // ================================================================
+++
+++    public async Task<List<TemplateDto>> GetActiveTemplatesAsync(
+++        int tenantId, CancellationToken ct = default)
+++    {
+++        const string sql = @"
+++            SELECT id, name, trigger_event, message_template, variables_json,
+++                   is_active, created_at, updated_at
+++            FROM outbound_templates
+++            WHERE tenant_id = @tid AND is_active = TRUE
+++            ORDER BY created_at DESC";
+++
+++        await using var conn = await _db.OpenConnectionAsync(ct);
+++        await using var cmd = new NpgsqlCommand(sql, conn);
+++        cmd.Parameters.AddWithValue("tid", tenantId);
+++
+++        var templates = new List<TemplateDto>();
+++        await using var reader = await cmd.ExecuteReaderAsync(ct);
+++        while (await reader.ReadAsync(ct))
+++        {
+++            templates.Add(ReadTemplateDto(reader));
+++        }
+++        return templates;
+++    }
+++
+++    public async Task<TemplateDto?> GetTemplateByIdAsync(
+++        int tenantId, int templateId, CancellationToken ct = default)
+++    {
+++        const string sql = @"
+++            SELECT id, name, trigger_event, message_template, variables_json,
+++                   is_active, created_at, updated_at
+++            FROM outbound_templates
+++            WHERE tenant_id = @tid AND id = @id AND is_active = TRUE";
+++
+++        await using var conn = await _db.OpenConnectionAsync(ct);
+++        await using var cmd = new NpgsqlCommand(sql, conn);
+++        cmd.Parameters.AddWithValue("tid", tenantId);
+++        cmd.Parameters.AddWithValue("id", templateId);
+++
+++        await using var reader = await cmd.ExecuteReaderAsync(ct);
+++        if (await reader.ReadAsync(ct))
+++            return ReadTemplateDto(reader);
+++        return null;
+++    }
+++
+++    public async Task<TemplateDto?> GetTriggerTemplateAsync(
+++        int tenantId, string triggerEvent, CancellationToken ct = default)
+++    {
+++        const string sql = @"
+++            SELECT id, name, trigger_event, message_template, variables_json,
+++                   is_active, created_at, updated_at
+++            FROM outbound_templates
+++            WHERE tenant_id = @tid AND trigger_event = @evt AND is_active = TRUE
+++            ORDER BY updated_at DESC
+++            LIMIT 1";
+++
+++        await using var conn = await _db.OpenConnectionAsync(ct);
+++        await using var cmd = new NpgsqlCommand(sql, conn);
+++        cmd.Parameters.AddWithValue("tid", tenantId);
+++        cmd.Parameters.AddWithValue("evt", triggerEvent);
+++
+++        await using var reader = await cmd.ExecuteReaderAsync(ct);
+++        if (await reader.ReadAsync(ct))
+++            return ReadTemplateDto(reader);
+++        return null;
+++    }
+++
+++    public async Task<int> CreateTemplateAsync(
+++        int tenantId, string name, string triggerEvent,
+++        string messageTemplate, Dictionary<string, string>? variablesJson,
+++        CancellationToken ct = default)
+++    {
+++        const string sql = @"
+++            INSERT INTO outbound_templates
+++                (tenant_id, name, trigger_event, message_template, variables_json)
+++            VALUES (@tid, @name, @evt, @tpl, @vars::jsonb)
+++            RETURNING id";
+++
+++        await using var conn = await _db.OpenConnectionAsync(ct);
+++        await using var cmd = new NpgsqlCommand(sql, conn);
+++        cmd.Parameters.AddWithValue("tid", tenantId);
+++        cmd.Parameters.AddWithValue("name", name);
+++        cmd.Parameters.AddWithValue("evt", triggerEvent);
+++        cmd.Parameters.AddWithValue("tpl", messageTemplate);
+++        cmd.Parameters.AddWithValue("vars",
+++            variablesJson != null ? (object)JsonSerializer.Serialize(variablesJson) : DBNull.Value);
+++
+++        var id = await cmd.ExecuteScalarAsync(ct);
+++        return Convert.ToInt32(id);
+++    }
+++
+++    public async Task<bool> UpdateTemplateAsync(
+++        int tenantId, int templateId, TemplateUpdateRequest req,
+++        CancellationToken ct = default)
+++    {
+++        var setClauses = new List<string>();
+++        var parameters = new List<NpgsqlParameter>
+++        {
+++            new("tid", tenantId),
+++            new("id", templateId)
+++        };
+++
+++        if (req.Name != null)
+++        {
+++            setClauses.Add("name = @name");
+++            parameters.Add(new NpgsqlParameter("name", req.Name));
+++        }
+++        if (req.TriggerEvent != null)
+++        {
+++            setClauses.Add("trigger_event = @evt");
+++            parameters.Add(new NpgsqlParameter("evt", req.TriggerEvent));
+++        }
+++        if (req.MessageTemplate != null)
+++        {
+++            setClauses.Add("message_template = @tpl");
+++            parameters.Add(new NpgsqlParameter("tpl", req.MessageTemplate));
+++        }
+++        if (req.VariablesJson != null)
+++        {
+++            setClauses.Add("variables_json = @vars::jsonb");
+++            parameters.Add(new NpgsqlParameter("vars", JsonSerializer.Serialize(req.VariablesJson)));
+++        }
+++
+++        if (setClauses.Count == 0) return false;
+++        setClauses.Add("updated_at = NOW()");
+++
+++        var sql = $"UPDATE outbound_templates SET {string.Join(", ", setClauses)} WHERE tenant_id = @tid AND id = @id AND is_active = TRUE";
+++
+++        await using var conn = await _db.OpenConnectionAsync(ct);
+++        await using var cmd = new NpgsqlCommand(sql, conn);
+++        cmd.Parameters.AddRange(parameters.ToArray());
+++
+++        var rows = await cmd.ExecuteNonQueryAsync(ct);
+++        return rows > 0;
+++    }
+++
+++    public async Task<bool> DeactivateTemplateAsync(
+++        int tenantId, int templateId, CancellationToken ct = default)
+++    {
+++        const string sql = @"
+++            UPDATE outbound_templates
+++            SET is_active = FALSE, updated_at = NOW()
+++            WHERE tenant_id = @tid AND id = @id AND is_active = TRUE";
+++
+++        await using var conn = await _db.OpenConnectionAsync(ct);
+++        await using var cmd = new NpgsqlCommand(sql, conn);
+++        cmd.Parameters.AddWithValue("tid", tenantId);
+++        cmd.Parameters.AddWithValue("id", templateId);
+++
+++        var rows = await cmd.ExecuteNonQueryAsync(ct);
+++        return rows > 0;
+++    }
+++
+++    // ================================================================
+++    // Broadcasts
+++    // ================================================================
+++
+++    public async Task<Guid> CreateBroadcastAsync(
+++        int tenantId, int templateId, int totalRecipients, int queued,
+++        DateTime? scheduledAt, CancellationToken ct = default)
+++    {
+++        const string sql = @"
+++            INSERT INTO outbound_broadcasts
+++                (tenant_id, template_id, total_recipients, queued, status, scheduled_at)
+++            VALUES (@tid, @tmpl, @total, @queued, 'queued', @sched)
+++            RETURNING id";
+++
+++        await using var conn = await _db.OpenConnectionAsync(ct);
+++        await using var cmd = new NpgsqlCommand(sql, conn);
+++        cmd.Parameters.AddWithValue("tid", tenantId);
+++        cmd.Parameters.AddWithValue("tmpl", templateId);
+++        cmd.Parameters.AddWithValue("total", totalRecipients);
+++        cmd.Parameters.AddWithValue("queued", queued);
+++        cmd.Parameters.AddWithValue("sched", scheduledAt.HasValue ? (object)scheduledAt.Value : DBNull.Value);
+++
+++        var id = await cmd.ExecuteScalarAsync(ct);
+++        return (Guid)id!;
+++    }
+++
+++    public async Task<BroadcastStatusResponse?> GetBroadcastStatusAsync(
+++        int tenantId, Guid broadcastId, CancellationToken ct = default)
+++    {
+++        const string sql = @"
+++            SELECT id, status, total_recipients, queued, sent, delivered, read, failed,
+++                   created_at, started_at, completed_at
+++            FROM outbound_broadcasts
+++            WHERE tenant_id = @tid AND id = @bid";
+++
+++        await using var conn = await _db.OpenConnectionAsync(ct);
+++        await using var cmd = new NpgsqlCommand(sql, conn);
+++        cmd.Parameters.AddWithValue("tid", tenantId);
+++        cmd.Parameters.AddWithValue("bid", broadcastId);
+++
+++        await using var reader = await cmd.ExecuteReaderAsync(ct);
+++        if (!await reader.ReadAsync(ct)) return null;
+++
+++        return new BroadcastStatusResponse
+++        {
+++            BroadcastId = reader.GetGuid(0),
+++            Status = reader.GetString(1),
+++            TotalRecipients = reader.GetInt32(2),
+++            Queued = reader.GetInt32(3),
+++            Sent = reader.GetInt32(4),
+++            Delivered = reader.GetInt32(5),
+++            Read = reader.GetInt32(6),
+++            Failed = reader.GetInt32(7),
+++            CreatedAt = reader.GetDateTime(8),
+++            StartedAt = reader.IsDBNull(9) ? null : reader.GetDateTime(9),
+++            CompletedAt = reader.IsDBNull(10) ? null : reader.GetDateTime(10)
+++        };
+++    }
+++
+++    public async Task UpdateBroadcastStatusAsync(
+++        Guid broadcastId, string status, CancellationToken ct = default)
+++    {
+++        var extraSet = status switch
+++        {
+++            "processing" => ", started_at = COALESCE(started_at, NOW())",
+++            "completed" or "failed" => ", completed_at = NOW()",
+++            _ => ""
+++        };
+++
+++        var sql = $"UPDATE outbound_broadcasts SET status = @st{extraSet} WHERE id = @bid";
+++
+++        await using var conn = await _db.OpenConnectionAsync(ct);
+++        await using var cmd = new NpgsqlCommand(sql, conn);
+++        cmd.Parameters.AddWithValue("st", status);
+++        cmd.Parameters.AddWithValue("bid", broadcastId);
+++
+++        await cmd.ExecuteNonQueryAsync(ct);
+++    }
+++
+++    public async Task IncrementBroadcastCounterAsync(
+++        Guid broadcastId, string counterColumn, CancellationToken ct = default)
+++    {
+++        // Whitelist valid columns to prevent SQL injection
+++        if (counterColumn is not ("sent" or "delivered" or "read" or "failed"))
+++            throw new ArgumentException($"Invalid counter column: {counterColumn}");
+++
+++        // Decrement queued when message leaves queue
+++        var queuedDecrement = counterColumn == "sent" || counterColumn == "failed"
+++            ? ", queued = GREATEST(queued - 1, 0)" : "";
+++
+++        var sql = $"UPDATE outbound_broadcasts SET {counterColumn} = {counterColumn} + 1{queuedDecrement} WHERE id = @bid";
+++
+++        await using var conn = await _db.OpenConnectionAsync(ct);
+++        await using var cmd = new NpgsqlCommand(sql, conn);
+++        cmd.Parameters.AddWithValue("bid", broadcastId);
+++
+++        await cmd.ExecuteNonQueryAsync(ct);
+++    }
+++
+++    /// <summary>Check if all messages in a broadcast are processed (no more queued/sending).</summary>
+++    public async Task<bool> IsBroadcastCompleteAsync(
+++        Guid broadcastId, CancellationToken ct = default)
+++    {
+++        const string sql = @"
+++            SELECT COUNT(*) FROM outbound_messages
+++            WHERE broadcast_id = @bid AND status IN ('queued', 'sending')";
+++
+++        await using var conn = await _db.OpenConnectionAsync(ct);
+++        await using var cmd = new NpgsqlCommand(sql, conn);
+++        cmd.Parameters.AddWithValue("bid", broadcastId);
+++
+++        var count = (long)(await cmd.ExecuteScalarAsync(ct))!;
+++        return count == 0;
+++    }
+++
+++    // ================================================================
+++    // Messages
+++    // ================================================================
+++
+++    public async Task<long> InsertMessageAsync(
+++        int tenantId, Guid? broadcastId, int? templateId,
+++        string recipientPhone, string messageText,
+++        CancellationToken ct = default)
+++    {
+++        const string sql = @"
+++            INSERT INTO outbound_messages
+++                (tenant_id, broadcast_id, template_id, recipient_phone, message_text, status)
+++            VALUES (@tid, @bid, @tmpl, @phone, @msg, 'queued')
+++            RETURNING id";
+++
+++        await using var conn = await _db.OpenConnectionAsync(ct);
+++        await using var cmd = new NpgsqlCommand(sql, conn);
+++        cmd.Parameters.AddWithValue("tid", tenantId);
+++        cmd.Parameters.AddWithValue("bid", broadcastId.HasValue ? (object)broadcastId.Value : DBNull.Value);
+++        cmd.Parameters.AddWithValue("tmpl", templateId.HasValue ? (object)templateId.Value : DBNull.Value);
+++        cmd.Parameters.AddWithValue("phone", recipientPhone);
+++        cmd.Parameters.AddWithValue("msg", messageText);
+++
+++        var id = await cmd.ExecuteScalarAsync(ct);
+++        return Convert.ToInt64(id);
+++    }
+++
+++    /// <summary>Dequeue next batch of messages to send, respecting rate limit.</summary>
+++    public async Task<List<QueuedMessage>> DequeueMessagesAsync(
+++        int batchSize, CancellationToken ct = default)
+++    {
+++        const string sql = @"
+++            UPDATE outbound_messages
+++            SET status = 'sending'
+++            WHERE id IN (
+++                SELECT id FROM outbound_messages
+++                WHERE status = 'queued'
+++                ORDER BY created_at
+++                LIMIT @batch
+++                FOR UPDATE SKIP LOCKED
+++            )
+++            RETURNING id, tenant_id, broadcast_id, template_id,
+++                      recipient_phone, message_text";
+++
+++        await using var conn = await _db.OpenConnectionAsync(ct);
+++        await using var cmd = new NpgsqlCommand(sql, conn);
+++        cmd.Parameters.AddWithValue("batch", batchSize);
+++
+++        var messages = new List<QueuedMessage>();
+++        await using var reader = await cmd.ExecuteReaderAsync(ct);
+++        while (await reader.ReadAsync(ct))
+++        {
+++            messages.Add(new QueuedMessage
+++            {
+++                Id = reader.GetInt64(0),
+++                TenantId = reader.GetInt32(1),
+++                BroadcastId = reader.IsDBNull(2) ? null : reader.GetGuid(2),
+++                TemplateId = reader.IsDBNull(3) ? null : reader.GetInt32(3),
+++                RecipientPhone = reader.GetString(4),
+++                MessageText = reader.GetString(5)
+++            });
+++        }
+++        return messages;
+++    }
+++
+++    public async Task UpdateMessageStatusAsync(
+++        long messageId, string status, string? externalMessageId = null,
+++        string? failedReason = null, CancellationToken ct = default)
+++    {
+++        var timestampCol = status switch
+++        {
+++            "sent" => ", sent_at = NOW()",
+++            "delivered" => ", delivered_at = NOW()",
+++            "read" => ", read_at = NOW()",
+++            _ => ""
+++        };
+++
+++        var extIdSet = externalMessageId != null ? ", external_message_id = @eid" : "";
+++        var failSet = failedReason != null ? ", failed_reason = @fail" : "";
+++
+++        var sql = $"UPDATE outbound_messages SET status = @st{timestampCol}{extIdSet}{failSet} WHERE id = @mid";
+++
+++        await using var conn = await _db.OpenConnectionAsync(ct);
+++        await using var cmd = new NpgsqlCommand(sql, conn);
+++        cmd.Parameters.AddWithValue("st", status);
+++        cmd.Parameters.AddWithValue("mid", messageId);
+++
+++        if (externalMessageId != null)
+++            cmd.Parameters.AddWithValue("eid", externalMessageId);
+++        if (failedReason != null)
+++            cmd.Parameters.AddWithValue("fail", failedReason);
+++
+++        await cmd.ExecuteNonQueryAsync(ct);
+++    }
+++
+++    /// <summary>Find message by external_message_id (from WapCRM/WhatsApp).</summary>
+++    public async Task<(long messageId, Guid? broadcastId, int tenantId)?> FindMessageByExternalIdAsync(
+++        string externalMessageId, CancellationToken ct = default)
+++    {
+++        const string sql = @"
+++            SELECT id, broadcast_id, tenant_id
+++            FROM outbound_messages
+++            WHERE external_message_id = @eid
+++            LIMIT 1";
+++
+++        await using var conn = await _db.OpenConnectionAsync(ct);
+++        await using var cmd = new NpgsqlCommand(sql, conn);
+++        cmd.Parameters.AddWithValue("eid", externalMessageId);
+++
+++        await using var reader = await cmd.ExecuteReaderAsync(ct);
+++        if (await reader.ReadAsync(ct))
+++        {
+++            return (
+++                reader.GetInt64(0),
+++                reader.IsDBNull(1) ? null : reader.GetGuid(1),
+++                reader.GetInt32(2)
+++            );
+++        }
+++        return null;
+++    }
+++
+++    // ================================================================
+++    // Opt-outs
+++    // ================================================================
+++
+++    public async Task<bool> IsOptedOutAsync(
+++        int tenantId, string phone, CancellationToken ct = default)
+++    {
+++        const string sql = @"
+++            SELECT 1 FROM outbound_optouts
+++            WHERE tenant_id = @tid AND phone = @phone
+++            LIMIT 1";
+++
+++        await using var conn = await _db.OpenConnectionAsync(ct);
+++        await using var cmd = new NpgsqlCommand(sql, conn);
+++        cmd.Parameters.AddWithValue("tid", tenantId);
+++        cmd.Parameters.AddWithValue("phone", phone);
+++
+++        var result = await cmd.ExecuteScalarAsync(ct);
+++        return result != null;
+++    }
+++
+++    public async Task<DateTime?> GetOptOutDateAsync(
+++        int tenantId, string phone, CancellationToken ct = default)
+++    {
+++        const string sql = @"
+++            SELECT created_at FROM outbound_optouts
+++            WHERE tenant_id = @tid AND phone = @phone
+++            LIMIT 1";
+++
+++        await using var conn = await _db.OpenConnectionAsync(ct);
+++        await using var cmd = new NpgsqlCommand(sql, conn);
+++        cmd.Parameters.AddWithValue("tid", tenantId);
+++        cmd.Parameters.AddWithValue("phone", phone);
+++
+++        var result = await cmd.ExecuteScalarAsync(ct);
+++        return result as DateTime?;
+++    }
+++
+++    public async Task<bool> AddOptOutAsync(
+++        int tenantId, string phone, string? reason,
+++        CancellationToken ct = default)
+++    {
+++        const string sql = @"
+++            INSERT INTO outbound_optouts (tenant_id, phone, reason)
+++            VALUES (@tid, @phone, @reason)
+++            ON CONFLICT (tenant_id, phone) DO NOTHING
+++            RETURNING id";
+++
+++        await using var conn = await _db.OpenConnectionAsync(ct);
+++        await using var cmd = new NpgsqlCommand(sql, conn);
+++        cmd.Parameters.AddWithValue("tid", tenantId);
+++        cmd.Parameters.AddWithValue("phone", phone);
+++        cmd.Parameters.AddWithValue("reason", (object?)reason ?? DBNull.Value);
+++
+++        var id = await cmd.ExecuteScalarAsync(ct);
+++        return id != null;
+++    }
+++
+++    public async Task<bool> RemoveOptOutAsync(
+++        int tenantId, string phone, CancellationToken ct = default)
+++    {
+++        const string sql = @"
+++            DELETE FROM outbound_optouts
+++            WHERE tenant_id = @tid AND phone = @phone";
+++
+++        await using var conn = await _db.OpenConnectionAsync(ct);
+++        await using var cmd = new NpgsqlCommand(sql, conn);
+++        cmd.Parameters.AddWithValue("tid", tenantId);
+++        cmd.Parameters.AddWithValue("phone", phone);
+++
+++        var rows = await cmd.ExecuteNonQueryAsync(ct);
+++        return rows > 0;
+++    }
+++
+++    // ================================================================
+++    // Helpers
+++    // ================================================================
+++
+++    private static TemplateDto ReadTemplateDto(NpgsqlDataReader reader)
+++    {
+++        var variablesStr = reader.IsDBNull(4) ? null : reader.GetString(4);
+++        Dictionary<string, string>? variables = null;
+++        if (variablesStr != null)
+++        {
+++            try { variables = JsonSerializer.Deserialize<Dictionary<string, string>>(variablesStr); }
+++            catch { /* ignore malformed JSON */ }
+++        }
+++
+++        return new TemplateDto
+++        {
+++            Id = reader.GetInt32(0),
+++            Name = reader.GetString(1),
+++            TriggerEvent = reader.GetString(2),
+++            MessageTemplate = reader.GetString(3),
+++            VariablesJson = variables,
+++            IsActive = reader.GetBoolean(5),
+++            CreatedAt = reader.GetDateTime(6),
+++            UpdatedAt = reader.GetDateTime(7)
+++        };
+++    }
+++}
+++
+++public sealed class QueuedMessage
+++{
+++    public long Id { get; set; }
+++    public int TenantId { get; set; }
+++    public Guid? BroadcastId { get; set; }
+++    public int? TemplateId { get; set; }
+++    public string RecipientPhone { get; set; } = "";
+++    public string MessageText { get; set; } = "";
+++}
++diff --git a/src/Invekto.Outbound/Invekto.Outbound.csproj b/src/Invekto.Outbound/Invekto.Outbound.csproj
++new file mode 100644
++index 0000000..263b43f
++--- /dev/null
+++++ b/src/Invekto.Outbound/Invekto.Outbound.csproj
++@@ -0,0 +1,16 @@
+++<Project Sdk="Microsoft.NET.Sdk.Web">
+++  <PropertyGroup>
+++    <TargetFramework>net8.0</TargetFramework>
+++    <Nullable>enable</Nullable>
+++    <ImplicitUsings>enable</ImplicitUsings>
+++    <RootNamespace>Invekto.Outbound</RootNamespace>
+++  </PropertyGroup>
+++
+++  <ItemGroup>
+++    <PackageReference Include="Microsoft.Extensions.Hosting.WindowsServices" Version="8.0.1" />
+++  </ItemGroup>
+++
+++  <ItemGroup>
+++    <ProjectReference Include="..\Invekto.Shared\Invekto.Shared.csproj" />
+++  </ItemGroup>
+++</Project>
++diff --git a/src/Invekto.Outbound/Middleware/JwtAuthMiddleware.cs b/src/Invekto.Outbound/Middleware/JwtAuthMiddleware.cs
++new file mode 100644
++index 0000000..c5b3b4a
++--- /dev/null
+++++ b/src/Invekto.Outbound/Middleware/JwtAuthMiddleware.cs
++@@ -0,0 +1,105 @@
+++using Invekto.Shared.Auth;
+++using Invekto.Shared.Constants;
+++using Invekto.Shared.DTOs;
+++using Invekto.Shared.Logging;
+++
+++namespace Invekto.Outbound.Middleware;
+++
+++public sealed class JwtAuthMiddleware
+++{
+++    private readonly RequestDelegate _next;
+++    private readonly JwtValidator _jwtValidator;
+++    private readonly JsonLinesLogger _logger;
+++    private readonly HashSet<string> _authRequiredPrefixes;
+++
+++    public JwtAuthMiddleware(
+++        RequestDelegate next,
+++        JwtValidator jwtValidator,
+++        JsonLinesLogger logger,
+++        IEnumerable<string> authRequiredPrefixes)
+++    {
+++        _next = next;
+++        _jwtValidator = jwtValidator;
+++        _logger = logger;
+++        _authRequiredPrefixes = new HashSet<string>(authRequiredPrefixes, StringComparer.OrdinalIgnoreCase);
+++    }
+++
+++    public async Task InvokeAsync(HttpContext context)
+++    {
+++        var path = context.Request.Path.Value ?? "";
+++
+++        if (!RequiresAuth(path))
+++        {
+++            await _next(context);
+++            return;
+++        }
+++
+++        var authHeader = context.Request.Headers.Authorization.FirstOrDefault();
+++        if (string.IsNullOrEmpty(authHeader) || !authHeader.StartsWith("Bearer ", StringComparison.OrdinalIgnoreCase))
+++        {
+++            _logger.SystemWarn($"[{ErrorCodes.AuthUnauthorized}] Missing or invalid Authorization header: path={path}");
+++            context.Response.StatusCode = 401;
+++            await context.Response.WriteAsJsonAsync(
+++                ErrorResponse.Create(ErrorCodes.AuthUnauthorized, "Bearer token required", "-"));
+++            return;
+++        }
+++
+++        var token = authHeader["Bearer ".Length..].Trim();
+++        var (tenantContext, error) = _jwtValidator.ValidateToken(token);
+++
+++        if (tenantContext == null)
+++        {
+++            var errorCode = error?.Contains("expired", StringComparison.OrdinalIgnoreCase) == true
+++                ? ErrorCodes.AuthTokenExpired
+++                : ErrorCodes.AuthTokenInvalid;
+++
+++            _logger.SystemWarn($"[{errorCode}] JWT validation failed: path={path}, error={error}");
+++            context.Response.StatusCode = 401;
+++            await context.Response.WriteAsJsonAsync(
+++                ErrorResponse.Create(errorCode, error ?? "Token validation failed", "-"));
+++            return;
+++        }
+++
+++        context.Items["TenantContext"] = tenantContext;
+++
+++        // Validate tenant_id header matches JWT claim (prevent tenant spoofing)
+++        var existingTenantId = context.Request.Headers[HeaderNames.TenantId].FirstOrDefault();
+++        if (!string.IsNullOrEmpty(existingTenantId) && existingTenantId != tenantContext.TenantId.ToString())
+++        {
+++            _logger.SystemWarn($"[{ErrorCodes.AuthUnauthorized}] Tenant ID mismatch: header={existingTenantId}, jwt={tenantContext.TenantId}, path={path}");
+++            context.Response.StatusCode = 403;
+++            await context.Response.WriteAsJsonAsync(
+++                ErrorResponse.Create(ErrorCodes.AuthUnauthorized, "Tenant ID mismatch between header and JWT token", "-"));
+++            return;
+++        }
+++
+++        if (string.IsNullOrEmpty(existingTenantId))
+++        {
+++            context.Request.Headers[HeaderNames.TenantId] = tenantContext.TenantId.ToString();
+++        }
+++
+++        await _next(context);
+++    }
+++
+++    private bool RequiresAuth(string path)
+++    {
+++        foreach (var prefix in _authRequiredPrefixes)
+++        {
+++            if (path.StartsWith(prefix, StringComparison.OrdinalIgnoreCase))
+++                return true;
+++        }
+++        return false;
+++    }
+++}
+++
+++public static class JwtAuthMiddlewareExtensions
+++{
+++    public static IApplicationBuilder UseJwtAuth(
+++        this IApplicationBuilder app,
+++        JwtValidator jwtValidator,
+++        JsonLinesLogger logger,
+++        params string[] authRequiredPrefixes)
+++    {
+++        return app.UseMiddleware<JwtAuthMiddleware>(jwtValidator, logger, (IEnumerable<string>)authRequiredPrefixes);
+++    }
+++}
++diff --git a/src/Invekto.Outbound/Middleware/TrafficLoggingMiddleware.cs b/src/Invekto.Outbound/Middleware/TrafficLoggingMiddleware.cs
++new file mode 100644
++index 0000000..39f7956
++--- /dev/null
+++++ b/src/Invekto.Outbound/Middleware/TrafficLoggingMiddleware.cs
++@@ -0,0 +1,95 @@
+++using System.Diagnostics;
+++using System.Text;
+++using Invekto.Shared.DTOs;
+++using Invekto.Shared.Logging;
+++
+++namespace Invekto.Outbound.Middleware;
+++
+++public sealed class TrafficLoggingMiddleware
+++{
+++    private readonly RequestDelegate _next;
+++    private readonly JsonLinesLogger _logger;
+++
+++    private static readonly string[] SkipPaths = { "/health", "/ready" };
+++
+++    public TrafficLoggingMiddleware(RequestDelegate next, JsonLinesLogger logger)
+++    {
+++        _next = next;
+++        _logger = logger;
+++    }
+++
+++    public async Task InvokeAsync(HttpContext context)
+++    {
+++        var path = context.Request.Path.Value ?? "";
+++
+++        if (SkipPaths.Any(p => path.StartsWith(p, StringComparison.OrdinalIgnoreCase)))
+++        {
+++            await _next(context);
+++            return;
+++        }
+++
+++        var sw = Stopwatch.StartNew();
+++
+++        string? requestBody = null;
+++        if (context.Request.ContentLength > 0 && context.Request.ContentLength < 50000)
+++        {
+++            context.Request.EnableBuffering();
+++            using var reader = new StreamReader(
+++                context.Request.Body, Encoding.UTF8,
+++                detectEncodingFromByteOrderMarks: false, leaveOpen: true);
+++            requestBody = await reader.ReadToEndAsync();
+++            context.Request.Body.Position = 0;
+++        }
+++
+++        var originalBodyStream = context.Response.Body;
+++        using var responseBodyStream = new MemoryStream();
+++        context.Response.Body = responseBodyStream;
+++
+++        try
+++        {
+++            await _next(context);
+++        }
+++        finally
+++        {
+++            sw.Stop();
+++
+++            string? responseBody = null;
+++            if (responseBodyStream.Length > 0 && responseBodyStream.Length < 50000)
+++            {
+++                responseBodyStream.Position = 0;
+++                responseBody = await new StreamReader(responseBodyStream).ReadToEndAsync();
+++            }
+++
+++            responseBodyStream.Position = 0;
+++            await responseBodyStream.CopyToAsync(originalBodyStream);
+++            context.Response.Body = originalBodyStream;
+++
+++            var requestId = context.Request.Headers["X-Request-Id"].FirstOrDefault()
+++                ?? context.TraceIdentifier;
+++            var tenantId = context.Request.Headers["X-Tenant-Id"].FirstOrDefault() ?? "-";
+++            var chatId = context.Request.Headers["X-Chat-Id"].FirstOrDefault() ?? "-";
+++
+++            var logContext = new RequestContext
+++            {
+++                RequestId = requestId,
+++                TenantId = tenantId,
+++                ChatId = chatId
+++            };
+++
+++            var level = context.Response.StatusCode >= 400 ? "WARN" : "INFO";
+++            var message = $"{context.Request.Method} {path} -> {context.Response.StatusCode}";
+++
+++            _logger.LogTraffic(level, message, logContext, path,
+++                context.Request.Method, sw.ElapsedMilliseconds,
+++                context.Response.StatusCode, requestBody, responseBody);
+++        }
+++    }
+++}
+++
+++public static class TrafficLoggingMiddlewareExtensions
+++{
+++    public static IApplicationBuilder UseTrafficLogging(this IApplicationBuilder builder)
+++    {
+++        return builder.UseMiddleware<TrafficLoggingMiddleware>();
+++    }
+++}
++diff --git a/src/Invekto.Outbound/Program.cs b/src/Invekto.Outbound/Program.cs
++new file mode 100644
++index 0000000..ac44e73
++--- /dev/null
+++++ b/src/Invekto.Outbound/Program.cs
++@@ -0,0 +1,587 @@
+++using Invekto.Outbound.Data;
+++using Invekto.Outbound.Middleware;
+++using Invekto.Outbound.Services;
+++using Invekto.Shared.Auth;
+++using Invekto.Shared.Constants;
+++using Invekto.Shared.Data;
+++using Invekto.Shared.DTOs;
+++using Invekto.Shared.DTOs.Outbound;
+++using Invekto.Shared.Integration;
+++using Invekto.Shared.Logging;
+++
+++var builder = WebApplication.CreateBuilder(args);
+++
+++// Windows Service support
+++builder.Host.UseWindowsService();
+++
+++// Read configuration
+++var listenPort = builder.Configuration.GetValue<int>("Service:ListenPort", ServiceConstants.OutboundPort);
+++var logPath = builder.Configuration["Logging:FilePath"] ?? "logs";
+++var pgConnStr = builder.Configuration.GetConnectionString("PostgreSQL") ?? "";
+++var jwtSecretKey = builder.Configuration["Jwt:SecretKey"] ?? "";
+++var defaultMsgPerMin = builder.Configuration.GetValue<int>("RateLimit:DefaultMessagesPerMinute", 30);
+++var senderIntervalMs = builder.Configuration.GetValue<int>("RateLimit:SenderIntervalMs", 1000);
+++var callbackUrl = builder.Configuration["Callback:DefaultCallbackUrl"] ?? "";
+++var callbackMaxRetries = builder.Configuration.GetValue<int>("Callback:MaxRetries", 3);
+++var callbackBaseDelayMs = builder.Configuration.GetValue<int>("Callback:BaseDelayMs", 500);
+++var callbackTimeoutMs = builder.Configuration.GetValue<int>("Callback:TimeoutMs", 5000);
+++
+++// Validate required config
+++if (string.IsNullOrEmpty(pgConnStr))
+++{
+++    Console.Error.WriteLine("FATAL: ConnectionStrings:PostgreSQL is not configured");
+++    Environment.Exit(1);
+++}
+++if (string.IsNullOrEmpty(jwtSecretKey))
+++{
+++    Console.Error.WriteLine("FATAL: Jwt:SecretKey is not configured");
+++    Environment.Exit(1);
+++}
+++
+++// Configure Kestrel
+++builder.WebHost.ConfigureKestrel(options =>
+++{
+++    options.ListenAnyIP(listenPort);
+++});
+++
+++// Register logger
+++var logger = new JsonLinesLogger(ServiceConstants.OutboundServiceName, logPath);
+++builder.Services.AddSingleton(logger);
+++
+++// Register log cleanup
+++builder.Services.AddSingleton<LogCleanupService>(sp =>
+++    new LogCleanupService(logPath, ServiceConstants.LogRetentionDays));
+++
+++// Register JWT validator
+++var jwtSettings = new JwtSettings
+++{
+++    SecretKey = jwtSecretKey,
+++    Issuer = builder.Configuration["Jwt:Issuer"],
+++    Audience = builder.Configuration["Jwt:Audience"],
+++    ClockSkewSeconds = builder.Configuration.GetValue<int>("Jwt:ClockSkewSeconds", 60)
+++};
+++var jwtValidator = new JwtValidator(jwtSettings);
+++builder.Services.AddSingleton(jwtValidator);
+++
+++// Register PostgreSQL connection factory
+++var pgFactory = new PostgresConnectionFactory(pgConnStr);
+++builder.Services.AddSingleton(pgFactory);
+++
+++// Register repository
+++builder.Services.AddSingleton<OutboundRepository>();
+++
+++// Register services
+++builder.Services.AddSingleton<TemplateEngine>();
+++builder.Services.AddSingleton<OptOutManager>();
+++builder.Services.AddSingleton(new RateLimiter(defaultMsgPerMin, logger));
+++builder.Services.AddSingleton<BroadcastOrchestrator>();
+++builder.Services.AddSingleton<TriggerProcessor>();
+++
+++// Register MainAppCallbackClient with HttpClient
+++var callbackSettings = new CallbackSettings
+++{
+++    DefaultCallbackUrl = callbackUrl,
+++    MaxRetries = callbackMaxRetries,
+++    BaseDelayMs = callbackBaseDelayMs,
+++    TimeoutMs = callbackTimeoutMs
+++};
+++builder.Services.AddSingleton(callbackSettings);
+++builder.Services.AddHttpClient<MainAppCallbackClient>()
+++    .AddTypedClient((httpClient, sp) =>
+++    {
+++        return new MainAppCallbackClient(
+++            httpClient,
+++            sp.GetRequiredService<CallbackSettings>(),
+++            sp.GetRequiredService<JsonLinesLogger>());
+++    });
+++
+++// Register background message sender
+++builder.Services.AddSingleton<MessageSenderService>(sp =>
+++    new MessageSenderService(
+++        sp.GetRequiredService<OutboundRepository>(),
+++        sp.GetRequiredService<RateLimiter>(),
+++        sp.GetRequiredService<MainAppCallbackClient>(),
+++        sp.GetRequiredService<JsonLinesLogger>(),
+++        senderIntervalMs));
+++builder.Services.AddHostedService(sp => sp.GetRequiredService<MessageSenderService>());
+++
+++var app = builder.Build();
+++
+++// Enable traffic logging middleware
+++app.UseTrafficLogging();
+++
+++// Enable JWT auth for /api/v1/ prefixed paths
+++app.UseJwtAuth(jwtValidator, logger, "/api/v1/");
+++
+++// Start log cleanup
+++_ = app.Services.GetRequiredService<LogCleanupService>();
+++
+++// ============================================================
+++// Health endpoints
+++// ============================================================
+++
+++app.MapGet("/health", () => Results.Ok(HealthResponse.Ok(ServiceConstants.OutboundServiceName)));
+++app.MapGet("/ready", async (PostgresConnectionFactory db) =>
+++{
+++    var (ok, error) = await db.TestConnectionAsync();
+++    if (!ok)
+++        return Results.Json(new { status = "unhealthy", error }, statusCode: 503);
+++    return Results.Ok(HealthResponse.Ok(ServiceConstants.OutboundServiceName));
+++});
+++
+++// ============================================================
+++// Broadcast endpoints
+++// ============================================================
+++
+++app.MapPost("/api/v1/broadcast/send", async (
+++    HttpContext ctx,
+++    BroadcastOrchestrator orchestrator,
+++    JsonLinesLogger jsonLogger,
+++    BroadcastSendRequest? request) =>
+++{
+++    var requestId = ctx.Request.Headers["X-Request-Id"].FirstOrDefault() ?? Guid.NewGuid().ToString("N");
+++    ctx.Request.Headers["X-Request-Id"] = requestId;
+++
+++    if (request == null)
+++    {
+++        return Results.Json(
+++            ErrorResponse.Create(ErrorCodes.OutboundInvalidBroadcastPayload, "Request body is required", requestId),
+++            statusCode: 400);
+++    }
+++
+++    var tenantContext = ctx.Items["TenantContext"] as TenantContext;
+++    if (tenantContext == null)
+++    {
+++        return Results.Json(
+++            ErrorResponse.Create(ErrorCodes.AuthUnauthorized, "Tenant context not available", requestId),
+++            statusCode: 401);
+++    }
+++
+++    var (response, errorCode, errorMessage) = await orchestrator.CreateBroadcastAsync(
+++        tenantContext.TenantId, request, CancellationToken.None);
+++
+++    if (response == null)
+++    {
+++        var statusCode = errorCode switch
+++        {
+++            ErrorCodes.OutboundTooManyRecipients => 400,
+++            ErrorCodes.OutboundTemplateNotFound => 404,
+++            _ => 400
+++        };
+++        return Results.Json(
+++            ErrorResponse.Create(errorCode!, errorMessage!, requestId),
+++            statusCode: statusCode);
+++    }
+++
+++    jsonLogger.StepInfo(
+++        $"Broadcast submitted: id={response.BroadcastId}, queued={response.Queued}, skipped={response.SkippedOptout}",
+++        requestId);
+++
+++    return Results.Json(response, statusCode: 202);
+++});
+++
+++app.MapGet("/api/v1/broadcast/{broadcastId}/status", async (
+++    HttpContext ctx,
+++    OutboundRepository repository,
+++    string broadcastId) =>
+++{
+++    var requestId = ctx.Request.Headers["X-Request-Id"].FirstOrDefault() ?? Guid.NewGuid().ToString("N");
+++
+++    var tenantContext = ctx.Items["TenantContext"] as TenantContext;
+++    if (tenantContext == null)
+++    {
+++        return Results.Json(
+++            ErrorResponse.Create(ErrorCodes.AuthUnauthorized, "Tenant context not available", requestId),
+++            statusCode: 401);
+++    }
+++
+++    if (!Guid.TryParse(broadcastId, out var bid))
+++    {
+++        return Results.Json(
+++            ErrorResponse.Create(ErrorCodes.OutboundBroadcastNotFound, "Invalid broadcast ID format", requestId),
+++            statusCode: 400);
+++    }
+++
+++    var status = await repository.GetBroadcastStatusAsync(tenantContext.TenantId, bid);
+++    if (status == null)
+++    {
+++        return Results.Json(
+++            ErrorResponse.Create(ErrorCodes.OutboundBroadcastNotFound, $"Broadcast {broadcastId} not found", requestId),
+++            statusCode: 404);
+++    }
+++
+++    return Results.Ok(status);
+++});
+++
+++// ============================================================
+++// Webhook endpoints
+++// ============================================================
+++
+++app.MapPost("/api/v1/webhook/trigger", async (
+++    HttpContext ctx,
+++    TriggerProcessor triggerProcessor,
+++    JsonLinesLogger jsonLogger,
+++    TriggerWebhookRequest? request) =>
+++{
+++    var requestId = ctx.Request.Headers["X-Request-Id"].FirstOrDefault() ?? Guid.NewGuid().ToString("N");
+++    ctx.Request.Headers["X-Request-Id"] = requestId;
+++
+++    if (request == null)
+++    {
+++        return Results.Json(
+++            ErrorResponse.Create(ErrorCodes.OutboundInvalidBroadcastPayload, "Request body is required", requestId),
+++            statusCode: 400);
+++    }
+++
+++    var tenantContext = ctx.Items["TenantContext"] as TenantContext;
+++    if (tenantContext == null)
+++    {
+++        return Results.Json(
+++            ErrorResponse.Create(ErrorCodes.AuthUnauthorized, "Tenant context not available", requestId),
+++            statusCode: 401);
+++    }
+++
+++    var (response, errorCode, errorMessage, statusCode) = await triggerProcessor.ProcessTriggerAsync(
+++        tenantContext.TenantId, request, CancellationToken.None);
+++
+++    if (response == null)
+++    {
+++        return Results.Json(
+++            ErrorResponse.Create(errorCode!, errorMessage!, requestId),
+++            statusCode: statusCode);
+++    }
+++
+++    jsonLogger.StepInfo(
+++        $"Trigger processed: event={request.Event}, message_id={response.MessageId}, template={response.TemplateId}",
+++        requestId);
+++
+++    return Results.Json(response, statusCode: 202);
+++});
+++
+++app.MapPost("/api/v1/webhook/delivery-status", async (
+++    HttpContext ctx,
+++    OutboundRepository repository,
+++    JsonLinesLogger jsonLogger,
+++    DeliveryStatusRequest? request) =>
+++{
+++    var requestId = ctx.Request.Headers["X-Request-Id"].FirstOrDefault() ?? Guid.NewGuid().ToString("N");
+++
+++    if (request == null || string.IsNullOrWhiteSpace(request.ExternalMessageId))
+++    {
+++        return Results.Json(
+++            ErrorResponse.Create(ErrorCodes.OutboundDeliveryStatusFailed, "external_message_id is required", requestId),
+++            statusCode: 400);
+++    }
+++
+++    if (request.Status is not ("sent" or "delivered" or "read" or "failed"))
+++    {
+++        return Results.Json(
+++            ErrorResponse.Create(ErrorCodes.OutboundDeliveryStatusFailed,
+++                "status must be one of: sent, delivered, read, failed", requestId),
+++            statusCode: 400);
+++    }
+++
+++    var found = await repository.FindMessageByExternalIdAsync(request.ExternalMessageId);
+++    if (found == null)
+++    {
+++        return Results.Json(
+++            ErrorResponse.Create(ErrorCodes.OutboundDeliveryStatusFailed,
+++                $"Message not found for external_message_id: {request.ExternalMessageId}", requestId),
+++            statusCode: 404);
+++    }
+++
+++    var (messageId, broadcastId, tenantId) = found.Value;
+++
+++    await repository.UpdateMessageStatusAsync(
+++        messageId, request.Status, failedReason: request.FailedReason);
+++
+++    // Update broadcast counters if applicable
+++    if (broadcastId.HasValue && request.Status is "delivered" or "read" or "failed")
+++    {
+++        await repository.IncrementBroadcastCounterAsync(broadcastId.Value, request.Status);
+++    }
+++
+++    jsonLogger.StepInfo(
+++        $"Delivery status updated: external_id={request.ExternalMessageId}, status={request.Status}", requestId);
+++
+++    return Results.Ok(new { updated = true });
+++});
+++
+++app.MapPost("/api/v1/webhook/message", async (
+++    HttpContext ctx,
+++    OptOutManager optOutManager,
+++    JsonLinesLogger jsonLogger,
+++    IncomingMessageRequest? request) =>
+++{
+++    var requestId = ctx.Request.Headers["X-Request-Id"].FirstOrDefault() ?? Guid.NewGuid().ToString("N");
+++
+++    if (request == null || string.IsNullOrWhiteSpace(request.Phone) || string.IsNullOrWhiteSpace(request.MessageText))
+++    {
+++        return Results.Json(
+++            ErrorResponse.Create(ErrorCodes.OutboundInvalidBroadcastPayload, "phone and message_text are required", requestId),
+++            statusCode: 400);
+++    }
+++
+++    var tenantContext = ctx.Items["TenantContext"] as TenantContext;
+++    if (tenantContext == null)
+++    {
+++        return Results.Json(
+++            ErrorResponse.Create(ErrorCodes.AuthUnauthorized, "Tenant context not available", requestId),
+++            statusCode: 401);
+++    }
+++
+++    var (optedOut, keyword) = await optOutManager.ProcessIncomingMessageAsync(
+++        tenantContext.TenantId, request.Phone, request.MessageText);
+++
+++    if (optedOut)
+++    {
+++        jsonLogger.StepInfo(
+++            $"Opt-out detected: tenant={tenantContext.TenantId}, phone={request.Phone}, keyword={keyword}", requestId);
+++    }
+++
+++    return Results.Ok(new IncomingMessageResponse
+++    {
+++        OptedOut = optedOut,
+++        KeywordMatched = keyword
+++    });
+++});
+++
+++// ============================================================
+++// Template CRUD endpoints
+++// ============================================================
+++
+++app.MapGet("/api/v1/templates", async (
+++    HttpContext ctx,
+++    OutboundRepository repository) =>
+++{
+++    var tenantContext = ctx.Items["TenantContext"] as TenantContext;
+++    if (tenantContext == null)
+++        return Results.Json(ErrorResponse.Create(ErrorCodes.AuthUnauthorized, "Tenant context not available", "-"), statusCode: 401);
+++
+++    var templates = await repository.GetActiveTemplatesAsync(tenantContext.TenantId);
+++    return Results.Ok(new { templates });
+++});
+++
+++app.MapPost("/api/v1/templates", async (
+++    HttpContext ctx,
+++    OutboundRepository repository,
+++    JsonLinesLogger jsonLogger,
+++    TemplateCreateRequest? request) =>
+++{
+++    var requestId = ctx.Request.Headers["X-Request-Id"].FirstOrDefault() ?? Guid.NewGuid().ToString("N");
+++
+++    if (request == null || string.IsNullOrWhiteSpace(request.Name) || string.IsNullOrWhiteSpace(request.MessageTemplate))
+++    {
+++        return Results.Json(
+++            ErrorResponse.Create(ErrorCodes.OutboundInvalidTemplatePayload, "name and message_template are required", requestId),
+++            statusCode: 400);
+++    }
+++
+++    if (request.Name.Length > 200)
+++    {
+++        return Results.Json(
+++            ErrorResponse.Create(ErrorCodes.OutboundInvalidTemplatePayload, "name must be 200 characters or less", requestId),
+++            statusCode: 400);
+++    }
+++
+++    // Validate trigger_event
+++    var validEvents = new[] { "manual", "new_lead", "payment_received", "appointment_reminder" };
+++    if (!validEvents.Contains(request.TriggerEvent))
+++    {
+++        return Results.Json(
+++            ErrorResponse.Create(ErrorCodes.OutboundInvalidTemplatePayload,
+++                $"trigger_event must be one of: {string.Join(", ", validEvents)}", requestId),
+++            statusCode: 400);
+++    }
+++
+++    var tenantContext = ctx.Items["TenantContext"] as TenantContext;
+++    if (tenantContext == null)
+++        return Results.Json(ErrorResponse.Create(ErrorCodes.AuthUnauthorized, "Tenant context not available", requestId), statusCode: 401);
+++
+++    var id = await repository.CreateTemplateAsync(
+++        tenantContext.TenantId, request.Name, request.TriggerEvent,
+++        request.MessageTemplate, request.VariablesJson);
+++
+++    jsonLogger.StepInfo($"Template created: id={id}, name={request.Name}, event={request.TriggerEvent}", requestId);
+++
+++    return Results.Json(new { id, name = request.Name }, statusCode: 201);
+++});
+++
+++app.MapPut("/api/v1/templates/{id:int}", async (
+++    HttpContext ctx,
+++    OutboundRepository repository,
+++    JsonLinesLogger jsonLogger,
+++    int id,
+++    TemplateUpdateRequest? request) =>
+++{
+++    var requestId = ctx.Request.Headers["X-Request-Id"].FirstOrDefault() ?? Guid.NewGuid().ToString("N");
+++
+++    if (request == null)
+++    {
+++        return Results.Json(
+++            ErrorResponse.Create(ErrorCodes.OutboundInvalidTemplatePayload, "Request body is required", requestId),
+++            statusCode: 400);
+++    }
+++
+++    // Validate trigger_event if provided
+++    if (request.TriggerEvent != null)
+++    {
+++        var validEvents = new[] { "manual", "new_lead", "payment_received", "appointment_reminder" };
+++        if (!validEvents.Contains(request.TriggerEvent))
+++        {
+++            return Results.Json(
+++                ErrorResponse.Create(ErrorCodes.OutboundInvalidTemplatePayload,
+++                    $"trigger_event must be one of: {string.Join(", ", validEvents)}", requestId),
+++                statusCode: 400);
+++        }
+++    }
+++
+++    var tenantContext = ctx.Items["TenantContext"] as TenantContext;
+++    if (tenantContext == null)
+++        return Results.Json(ErrorResponse.Create(ErrorCodes.AuthUnauthorized, "Tenant context not available", requestId), statusCode: 401);
+++
+++    var updated = await repository.UpdateTemplateAsync(tenantContext.TenantId, id, request);
+++    if (!updated)
+++    {
+++        return Results.Json(
+++            ErrorResponse.Create(ErrorCodes.OutboundTemplateNotFound, $"Template {id} not found or inactive", requestId),
+++            statusCode: 404);
+++    }
+++
+++    jsonLogger.StepInfo($"Template updated: id={id}", requestId);
+++    return Results.Ok(new { id, updated = true });
+++});
+++
+++app.MapDelete("/api/v1/templates/{id:int}", async (
+++    HttpContext ctx,
+++    OutboundRepository repository,
+++    JsonLinesLogger jsonLogger,
+++    int id) =>
+++{
+++    var requestId = ctx.Request.Headers["X-Request-Id"].FirstOrDefault() ?? Guid.NewGuid().ToString("N");
+++
+++    var tenantContext = ctx.Items["TenantContext"] as TenantContext;
+++    if (tenantContext == null)
+++        return Results.Json(ErrorResponse.Create(ErrorCodes.AuthUnauthorized, "Tenant context not available", requestId), statusCode: 401);
+++
+++    var deactivated = await repository.DeactivateTemplateAsync(tenantContext.TenantId, id);
+++    if (!deactivated)
+++    {
+++        return Results.Json(
+++            ErrorResponse.Create(ErrorCodes.OutboundTemplateNotFound, $"Template {id} not found or already inactive", requestId),
+++            statusCode: 404);
+++    }
+++
+++    jsonLogger.StepInfo($"Template deactivated: id={id}", requestId);
+++    return Results.Ok(new { id, deactivated = true });
+++});
+++
+++// ============================================================
+++// Opt-out endpoints
+++// ============================================================
+++
+++app.MapPost("/api/v1/optout", async (
+++    HttpContext ctx,
+++    OutboundRepository repository,
+++    JsonLinesLogger jsonLogger,
+++    OptOutRequest? request) =>
+++{
+++    var requestId = ctx.Request.Headers["X-Request-Id"].FirstOrDefault() ?? Guid.NewGuid().ToString("N");
+++
+++    if (request == null || string.IsNullOrWhiteSpace(request.Phone))
+++    {
+++        return Results.Json(
+++            ErrorResponse.Create(ErrorCodes.OutboundInvalidBroadcastPayload, "phone is required", requestId),
+++            statusCode: 400);
+++    }
+++
+++    var tenantContext = ctx.Items["TenantContext"] as TenantContext;
+++    if (tenantContext == null)
+++        return Results.Json(ErrorResponse.Create(ErrorCodes.AuthUnauthorized, "Tenant context not available", requestId), statusCode: 401);
+++
+++    await repository.AddOptOutAsync(tenantContext.TenantId, request.Phone, request.Reason);
+++    jsonLogger.StepInfo($"Manual opt-out added: phone={request.Phone}", requestId);
+++
+++    return Results.Ok(new { phone = request.Phone, opted_out = true });
+++});
+++
+++app.MapDelete("/api/v1/optout/{phone}", async (
+++    HttpContext ctx,
+++    OutboundRepository repository,
+++    JsonLinesLogger jsonLogger,
+++    string phone) =>
+++{
+++    var requestId = ctx.Request.Headers["X-Request-Id"].FirstOrDefault() ?? Guid.NewGuid().ToString("N");
+++
+++    var tenantContext = ctx.Items["TenantContext"] as TenantContext;
+++    if (tenantContext == null)
+++        return Results.Json(ErrorResponse.Create(ErrorCodes.AuthUnauthorized, "Tenant context not available", requestId), statusCode: 401);
+++
+++    var removed = await repository.RemoveOptOutAsync(tenantContext.TenantId, phone);
+++    if (!removed)
+++    {
+++        return Results.Json(
+++            ErrorResponse.Create(ErrorCodes.OutboundRecipientOptedOut, $"Opt-out record not found for {phone}", requestId),
+++            statusCode: 404);
+++    }
+++
+++    jsonLogger.StepInfo($"Opt-out removed: phone={phone}", requestId);
+++    return Results.Ok(new { phone, removed = true });
+++});
+++
+++app.MapGet("/api/v1/optout/check/{phone}", async (
+++    HttpContext ctx,
+++    OutboundRepository repository,
+++    string phone) =>
+++{
+++    var tenantContext = ctx.Items["TenantContext"] as TenantContext;
+++    if (tenantContext == null)
+++        return Results.Json(ErrorResponse.Create(ErrorCodes.AuthUnauthorized, "Tenant context not available", "-"), statusCode: 401);
+++
+++    var optOutDate = await repository.GetOptOutDateAsync(tenantContext.TenantId, phone);
+++    return Results.Ok(new OptOutCheckResponse
+++    {
+++        Phone = phone,
+++        OptedOut = optOutDate.HasValue,
+++        OptedOutAt = optOutDate
+++    });
+++});
+++
+++// ============================================================
+++// Endpoint discovery
+++// ============================================================
+++
+++app.MapGet("/api/ops/endpoints", () =>
+++{
+++    var endpoints = new List<EndpointInfo>
+++    {
+++        new() { Method = "POST", Path = "/api/v1/broadcast/send", Description = "Submit broadcast (async, 202)", Auth = "Bearer JWT", Category = "Broadcast" },
+++        new() { Method = "GET", Path = "/api/v1/broadcast/{broadcastId}/status", Description = "Get broadcast delivery status", Auth = "Bearer JWT", Category = "Broadcast" },
+++        new() { Method = "POST", Path = "/api/v1/webhook/trigger", Description = "Receive trigger event from Main App", Auth = "Bearer JWT", Category = "Webhook" },
+++        new() { Method = "POST", Path = "/api/v1/webhook/delivery-status", Description = "Receive delivery status update", Auth = "Bearer JWT", Category = "Webhook" },
+++        new() { Method = "POST", Path = "/api/v1/webhook/message", Description = "Receive incoming message for opt-out detection", Auth = "Bearer JWT", Category = "Webhook" },
+++        new() { Method = "GET", Path = "/api/v1/templates", Description = "List active templates", Auth = "Bearer JWT", Category = "Templates" },
+++        new() { Method = "POST", Path = "/api/v1/templates", Description = "Create template", Auth = "Bearer JWT", Category = "Templates" },
+++        new() { Method = "PUT", Path = "/api/v1/templates/{id}", Description = "Update template", Auth = "Bearer JWT", Category = "Templates" },
+++        new() { Method = "DELETE", Path = "/api/v1/templates/{id}", Description = "Deactivate template", Auth = "Bearer JWT", Category = "Templates" },
+++        new() { Method = "POST", Path = "/api/v1/optout", Description = "Manual opt-out add", Auth = "Bearer JWT", Category = "OptOut" },
+++        new() { Method = "DELETE", Path = "/api/v1/optout/{phone}", Description = "Remove opt-out", Auth = "Bearer JWT", Category = "OptOut" },
+++        new() { Method = "GET", Path = "/api/v1/optout/check/{phone}", Description = "Check if phone opted out", Auth = "Bearer JWT", Category = "OptOut" },
+++        new() { Method = "GET", Path = "/health", Description = "Health check", Auth = "none", Category = "Health" },
+++        new() { Method = "GET", Path = "/ready", Description = "Readiness probe (DB check)", Auth = "none", Category = "Health" },
+++        new() { Method = "GET", Path = "/api/ops/endpoints", Description = "Endpoint discovery (this)", Auth = "none", Category = "Ops" },
+++    };
+++
+++    return Results.Ok(new EndpointDiscoveryResponse
+++    {
+++        Service = ServiceConstants.OutboundServiceName,
+++        Port = ServiceConstants.OutboundPort,
+++        Endpoints = endpoints
+++    });
+++});
+++
+++logger.SystemInfo($"Outbound service starting on port {listenPort}");
+++app.Run();
+++
+++// Required for integration tests
+++public partial class Program { }
++diff --git a/src/Invekto.Outbound/Services/BroadcastOrchestrator.cs b/src/Invekto.Outbound/Services/BroadcastOrchestrator.cs
++new file mode 100644
++index 0000000..29d4282
++--- /dev/null
+++++ b/src/Invekto.Outbound/Services/BroadcastOrchestrator.cs
++@@ -0,0 +1,114 @@
+++using Invekto.Outbound.Data;
+++using Invekto.Shared.Constants;
+++using Invekto.Shared.DTOs.Outbound;
+++using Invekto.Shared.Logging;
+++
+++namespace Invekto.Outbound.Services;
+++
+++/// <summary>
+++/// Orchestrates broadcast creation: validates, checks opt-outs,
+++/// applies template, inserts messages as 'queued'.
+++/// Thread-safe, register as singleton.
+++/// </summary>
+++public sealed class BroadcastOrchestrator
+++{
+++    private readonly OutboundRepository _repository;
+++    private readonly TemplateEngine _templateEngine;
+++    private readonly OptOutManager _optOutManager;
+++    private readonly JsonLinesLogger _logger;
+++
+++    public BroadcastOrchestrator(
+++        OutboundRepository repository,
+++        TemplateEngine templateEngine,
+++        OptOutManager optOutManager,
+++        JsonLinesLogger logger)
+++    {
+++        _repository = repository;
+++        _templateEngine = templateEngine;
+++        _optOutManager = optOutManager;
+++        _logger = logger;
+++    }
+++
+++    /// <summary>
+++    /// Create a broadcast: validate template, filter opt-outs, insert messages.
+++    /// Returns the broadcast response or an error tuple.
+++    /// </summary>
+++    public async Task<(BroadcastSendResponse? response, string? errorCode, string? errorMessage)>
+++        CreateBroadcastAsync(
+++            int tenantId, BroadcastSendRequest request, CancellationToken ct = default)
+++    {
+++        // Validate recipients count
+++        if (request.Recipients == null || request.Recipients.Count == 0)
+++            return (null, ErrorCodes.OutboundInvalidBroadcastPayload, "recipients is required and cannot be empty");
+++
+++        if (request.Recipients.Count > 1000)
+++            return (null, ErrorCodes.OutboundTooManyRecipients, $"Max 1000 recipients per broadcast, got {request.Recipients.Count}");
+++
+++        // Validate template exists
+++        var template = await _repository.GetTemplateByIdAsync(tenantId, request.TemplateId, ct);
+++        if (template == null)
+++            return (null, ErrorCodes.OutboundTemplateNotFound, $"Template {request.TemplateId} not found or inactive");
+++
+++        // Filter opt-outs and prepare messages
+++        var queuedCount = 0;
+++        var skippedOptout = 0;
+++        var messagesToInsert = new List<(string phone, string text)>();
+++
+++        foreach (var recipient in request.Recipients)
+++        {
+++            if (string.IsNullOrWhiteSpace(recipient.Phone))
+++                continue;
+++
+++            // Check opt-out
+++            if (await _optOutManager.IsOptedOutAsync(tenantId, recipient.Phone, ct))
+++            {
+++                skippedOptout++;
+++                continue;
+++            }
+++
+++            // Apply template variables
+++            var (messageText, missingVars) = _templateEngine.Substitute(
+++                template.MessageTemplate, recipient.Variables);
+++
+++            if (missingVars.Count > 0)
+++            {
+++                _logger.SystemWarn(
+++                    $"Broadcast skipping {recipient.Phone}: missing variables [{string.Join(", ", missingVars)}]");
+++                continue;
+++            }
+++
+++            messagesToInsert.Add((recipient.Phone, messageText));
+++        }
+++
+++        if (messagesToInsert.Count == 0)
+++        {
+++            return (null, ErrorCodes.OutboundInvalidBroadcastPayload,
+++                "No valid recipients after opt-out filtering and variable validation");
+++        }
+++
+++        // Create broadcast record
+++        var broadcastId = await _repository.CreateBroadcastAsync(
+++            tenantId, request.TemplateId, request.Recipients.Count,
+++            messagesToInsert.Count, request.ScheduledAt, ct);
+++
+++        // Insert all messages
+++        foreach (var (phone, text) in messagesToInsert)
+++        {
+++            await _repository.InsertMessageAsync(
+++                tenantId, broadcastId, request.TemplateId, phone, text, ct);
+++            queuedCount++;
+++        }
+++
+++        _logger.SystemInfo(
+++            $"Broadcast created: id={broadcastId}, tenant={tenantId}, " +
+++            $"total={request.Recipients.Count}, queued={queuedCount}, skipped_optout={skippedOptout}");
+++
+++        return (new BroadcastSendResponse
+++        {
+++            BroadcastId = broadcastId,
+++            TotalRecipients = request.Recipients.Count,
+++            Queued = queuedCount,
+++            SkippedOptout = skippedOptout
+++        }, null, null);
+++    }
+++}
++diff --git a/src/Invekto.Outbound/Services/MessageSenderService.cs b/src/Invekto.Outbound/Services/MessageSenderService.cs
++new file mode 100644
++index 0000000..1f48791
++--- /dev/null
+++++ b/src/Invekto.Outbound/Services/MessageSenderService.cs
++@@ -0,0 +1,196 @@
+++using Invekto.Outbound.Data;
+++using Invekto.Shared.Constants;
+++using Invekto.Shared.DTOs.Integration;
+++using Invekto.Shared.Integration;
+++using Invekto.Shared.Logging;
+++
+++namespace Invekto.Outbound.Services;
+++
+++/// <summary>
+++/// Background service that dequeues messages and sends them via Main App callback.
+++/// Respects tenant-based rate limits. Graceful shutdown via CancellationToken.
+++/// </summary>
+++public sealed class MessageSenderService : IHostedService, IDisposable
+++{
+++    private readonly OutboundRepository _repository;
+++    private readonly RateLimiter _rateLimiter;
+++    private readonly MainAppCallbackClient _callbackClient;
+++    private readonly JsonLinesLogger _logger;
+++    private readonly int _intervalMs;
+++
+++    private Timer? _timer;
+++    private int _isProcessing; // 0 = idle, 1 = processing (interlocked)
+++    private CancellationTokenSource? _cts;
+++
+++    public MessageSenderService(
+++        OutboundRepository repository,
+++        RateLimiter rateLimiter,
+++        MainAppCallbackClient callbackClient,
+++        JsonLinesLogger logger,
+++        int intervalMs = 1000)
+++    {
+++        _repository = repository;
+++        _rateLimiter = rateLimiter;
+++        _callbackClient = callbackClient;
+++        _logger = logger;
+++        _intervalMs = intervalMs;
+++    }
+++
+++    public Task StartAsync(CancellationToken cancellationToken)
+++    {
+++        _cts = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken);
+++        _logger.SystemInfo($"MessageSenderService starting (interval={_intervalMs}ms)");
+++        _timer = new Timer(ProcessQueue, null, _intervalMs, _intervalMs);
+++        return Task.CompletedTask;
+++    }
+++
+++    public Task StopAsync(CancellationToken cancellationToken)
+++    {
+++        _logger.SystemInfo("MessageSenderService stopping (graceful shutdown)");
+++        _timer?.Change(Timeout.Infinite, 0);
+++        _cts?.Cancel();
+++
+++        // Wait for current processing to finish (max 10s)
+++        var waitCount = 0;
+++        while (Interlocked.CompareExchange(ref _isProcessing, 0, 0) == 1 && waitCount < 100)
+++        {
+++            Thread.Sleep(100);
+++            waitCount++;
+++        }
+++
+++        return Task.CompletedTask;
+++    }
+++
+++    public void Dispose()
+++    {
+++        _timer?.Dispose();
+++        _cts?.Dispose();
+++    }
+++
+++    private async void ProcessQueue(object? state)
+++    {
+++        // Prevent overlapping processing
+++        if (Interlocked.CompareExchange(ref _isProcessing, 1, 0) != 0)
+++            return;
+++
+++        try
+++        {
+++            var ct = _cts?.Token ?? CancellationToken.None;
+++            if (ct.IsCancellationRequested) return;
+++
+++            // Dequeue a small batch
+++            var messages = await _repository.DequeueMessagesAsync(10, ct);
+++            if (messages.Count == 0) return;
+++
+++            foreach (var msg in messages)
+++            {
+++                if (ct.IsCancellationRequested) break;
+++
+++                // Check rate limit per tenant
+++                if (!_rateLimiter.TryAcquire(msg.TenantId))
+++                {
+++                    // Put back to queued (rate limited - will retry next cycle)
+++                    await _repository.UpdateMessageStatusAsync(msg.Id, "queued", ct: ct);
+++                    _logger.SystemInfo($"Rate limited: tenant={msg.TenantId}, message={msg.Id}, requeued");
+++                    continue;
+++                }
+++
+++                await SendMessageAsync(msg, ct);
+++            }
+++        }
+++        catch (OperationCanceledException)
+++        {
+++            // Graceful shutdown
+++        }
+++        catch (Exception ex)
+++        {
+++            _logger.SystemError($"MessageSenderService error: {ex.Message}");
+++        }
+++        finally
+++        {
+++            Interlocked.Exchange(ref _isProcessing, 0);
+++        }
+++    }
+++
+++    private async Task SendMessageAsync(QueuedMessage msg, CancellationToken ct)
+++    {
+++        try
+++        {
+++            var callback = new OutgoingCallback
+++            {
+++                RequestId = Guid.NewGuid().ToString("N"),
+++                Action = CallbackActions.SendMessage,
+++                TenantId = msg.TenantId,
+++                ChatId = 0, // Outbound doesn't have a chat context
+++                SequenceId = msg.Id,
+++                Data = new CallbackData
+++                {
+++                    MessageText = msg.MessageText,
+++                    Phone = msg.RecipientPhone,
+++                    BroadcastId = msg.BroadcastId,
+++                    OutboundMessageId = msg.Id
+++                },
+++                ProcessingTimeMs = 0,
+++                Timestamp = DateTime.UtcNow
+++            };
+++
+++            var success = await _callbackClient.SendCallbackAsync(callback, ct: ct);
+++
+++            if (success)
+++            {
+++                // Mark as sent - delivery status will come via webhook later
+++                await _repository.UpdateMessageStatusAsync(msg.Id, "sent", ct: ct);
+++
+++                if (msg.BroadcastId.HasValue)
+++                    await _repository.IncrementBroadcastCounterAsync(msg.BroadcastId.Value, "sent", ct);
+++
+++                // Check if broadcast is complete
+++                if (msg.BroadcastId.HasValue)
+++                    await TryCompleteBroadcastAsync(msg.BroadcastId.Value, ct);
+++            }
+++            else
+++            {
+++                await _repository.UpdateMessageStatusAsync(
+++                    msg.Id, "failed", failedReason: "Callback to Main App failed after retries", ct: ct);
+++
+++                if (msg.BroadcastId.HasValue)
+++                    await _repository.IncrementBroadcastCounterAsync(msg.BroadcastId.Value, "failed", ct);
+++
+++                if (msg.BroadcastId.HasValue)
+++                    await TryCompleteBroadcastAsync(msg.BroadcastId.Value, ct);
+++
+++                _logger.SystemError(
+++                    $"[{ErrorCodes.OutboundMessageSendCallbackFailed}] Message send failed: " +
+++                    $"id={msg.Id}, tenant={msg.TenantId}, phone={msg.RecipientPhone}");
+++            }
+++        }
+++        catch (Exception ex)
+++        {
+++            _logger.SystemError($"SendMessage exception: id={msg.Id}, error={ex.Message}");
+++            await _repository.UpdateMessageStatusAsync(
+++                msg.Id, "failed", failedReason: $"Exception: {ex.Message}", ct: ct);
+++
+++            if (msg.BroadcastId.HasValue)
+++            {
+++                await _repository.IncrementBroadcastCounterAsync(msg.BroadcastId.Value, "failed", ct);
+++                await TryCompleteBroadcastAsync(msg.BroadcastId.Value, ct);
+++            }
+++        }
+++    }
+++
+++    private async Task TryCompleteBroadcastAsync(Guid broadcastId, CancellationToken ct)
+++    {
+++        try
+++        {
+++            if (await _repository.IsBroadcastCompleteAsync(broadcastId, ct))
+++            {
+++                await _repository.UpdateBroadcastStatusAsync(broadcastId, "completed", ct);
+++                _logger.SystemInfo($"Broadcast completed: {broadcastId}");
+++            }
+++        }
+++        catch (Exception ex)
+++        {
+++            _logger.SystemError($"Error checking broadcast completion: {broadcastId}, {ex.Message}");
+++        }
+++    }
+++}
++diff --git a/src/Invekto.Outbound/Services/OptOutManager.cs b/src/Invekto.Outbound/Services/OptOutManager.cs
++new file mode 100644
++index 0000000..5a72e9a
++--- /dev/null
+++++ b/src/Invekto.Outbound/Services/OptOutManager.cs
++@@ -0,0 +1,74 @@
+++using Invekto.Outbound.Data;
+++using Invekto.Shared.Logging;
+++
+++namespace Invekto.Outbound.Services;
+++
+++/// <summary>
+++/// Manages opt-out registry and stop keyword detection.
+++/// Thread-safe, register as singleton.
+++/// </summary>
+++public sealed class OptOutManager
+++{
+++    private readonly OutboundRepository _repository;
+++    private readonly JsonLinesLogger _logger;
+++
+++    // Stop keywords - normalized to uppercase for comparison
+++    private static readonly string[] StopKeywords =
+++    {
+++        "STOP", "DUR", "╬ô├╢├ç╬ô├╗├ªPTAL", "IPTAL", "DURDU", "╬ô├╢┬úΓö£┬║IKI╬ô├╢Γò¥╬ô├⌐┬║", "CIKIS"
+++    };
+++
+++    public OptOutManager(OutboundRepository repository, JsonLinesLogger logger)
+++    {
+++        _repository = repository;
+++        _logger = logger;
+++    }
+++
+++    /// <summary>
+++    /// Check if a phone number has opted out for a given tenant.
+++    /// </summary>
+++    public Task<bool> IsOptedOutAsync(int tenantId, string phone, CancellationToken ct = default)
+++        => _repository.IsOptedOutAsync(tenantId, phone, ct);
+++
+++    /// <summary>
+++    /// Detect stop keyword in incoming message text.
+++    /// Returns the matched keyword or null.
+++    /// </summary>
+++    public string? DetectStopKeyword(string messageText)
+++    {
+++        if (string.IsNullOrWhiteSpace(messageText))
+++            return null;
+++
+++        var normalized = messageText.Trim().ToUpperInvariant();
+++        foreach (var keyword in StopKeywords)
+++        {
+++            if (normalized == keyword)
+++                return keyword;
+++        }
+++        return null;
+++    }
+++
+++    /// <summary>
+++    /// Process incoming message for opt-out detection.
+++    /// Returns (optedOut, matchedKeyword).
+++    /// </summary>
+++    public async Task<(bool optedOut, string? keyword)> ProcessIncomingMessageAsync(
+++        int tenantId, string phone, string messageText, CancellationToken ct = default)
+++    {
+++        var keyword = DetectStopKeyword(messageText);
+++        if (keyword == null)
+++            return (false, null);
+++
+++        var added = await _repository.AddOptOutAsync(tenantId, phone, $"Keyword: {keyword}", ct);
+++        if (added)
+++        {
+++            _logger.SystemInfo($"Opt-out registered: tenant={tenantId}, phone={phone}, keyword={keyword}");
+++        }
+++        else
+++        {
+++            _logger.SystemInfo($"Opt-out already exists: tenant={tenantId}, phone={phone}");
+++        }
+++
+++        return (true, keyword);
+++    }
+++}
++diff --git a/src/Invekto.Outbound/Services/RateLimiter.cs b/src/Invekto.Outbound/Services/RateLimiter.cs
++new file mode 100644
++index 0000000..e79962d
++--- /dev/null
+++++ b/src/Invekto.Outbound/Services/RateLimiter.cs
++@@ -0,0 +1,79 @@
+++using System.Collections.Concurrent;
+++using Invekto.Shared.Logging;
+++
+++namespace Invekto.Outbound.Services;
+++
+++/// <summary>
+++/// Tenant-based in-memory rate limiter. Tracks messages per minute per tenant.
+++/// When limit is exceeded, messages stay in the DB queue (not rejected).
+++/// Thread-safe, register as singleton.
+++/// </summary>
+++public sealed class RateLimiter
+++{
+++    private readonly int _defaultMessagesPerMinute;
+++    private readonly JsonLinesLogger _logger;
+++
+++    // Track per-tenant send timestamps (sliding window)
+++    private readonly ConcurrentDictionary<int, TenantWindow> _windows = new();
+++
+++    public RateLimiter(int defaultMessagesPerMinute, JsonLinesLogger logger)
+++    {
+++        _defaultMessagesPerMinute = defaultMessagesPerMinute;
+++        _logger = logger;
+++    }
+++
+++    /// <summary>
+++    /// Check if tenant can send a message right now.
+++    /// Returns true if within rate limit, false if should wait.
+++    /// </summary>
+++    public bool TryAcquire(int tenantId)
+++    {
+++        var window = _windows.GetOrAdd(tenantId, _ => new TenantWindow());
+++        return window.TryAcquire(_defaultMessagesPerMinute);
+++    }
+++
+++    /// <summary>
+++    /// Get how many messages tenant has sent in the current minute window.
+++    /// </summary>
+++    public int GetCurrentCount(int tenantId)
+++    {
+++        if (_windows.TryGetValue(tenantId, out var window))
+++            return window.GetCurrentCount();
+++        return 0;
+++    }
+++
+++    private sealed class TenantWindow
+++    {
+++        private readonly object _lock = new();
+++        private readonly Queue<DateTime> _timestamps = new();
+++
+++        public bool TryAcquire(int maxPerMinute)
+++        {
+++            lock (_lock)
+++            {
+++                PurgeOld();
+++                if (_timestamps.Count >= maxPerMinute)
+++                    return false;
+++
+++                _timestamps.Enqueue(DateTime.UtcNow);
+++                return true;
+++            }
+++        }
+++
+++        public int GetCurrentCount()
+++        {
+++            lock (_lock)
+++            {
+++                PurgeOld();
+++                return _timestamps.Count;
+++            }
+++        }
+++
+++        private void PurgeOld()
+++        {
+++            var cutoff = DateTime.UtcNow.AddMinutes(-1);
+++            while (_timestamps.Count > 0 && _timestamps.Peek() < cutoff)
+++                _timestamps.Dequeue();
+++        }
+++    }
+++}
++diff --git a/src/Invekto.Outbound/Services/TemplateEngine.cs b/src/Invekto.Outbound/Services/TemplateEngine.cs
++new file mode 100644
++index 0000000..6bf7a7e
++--- /dev/null
+++++ b/src/Invekto.Outbound/Services/TemplateEngine.cs
++@@ -0,0 +1,59 @@
+++using System.Text.RegularExpressions;
+++using Invekto.Shared.Logging;
+++
+++namespace Invekto.Outbound.Services;
+++
+++/// <summary>
+++/// Substitutes {{variable}} placeholders in message templates.
+++/// Thread-safe, register as singleton.
+++/// </summary>
+++public sealed class TemplateEngine
+++{
+++    private static readonly Regex VariablePattern = new(@"\{\{(\w+)\}\}", RegexOptions.Compiled);
+++
+++    private readonly JsonLinesLogger _logger;
+++
+++    public TemplateEngine(JsonLinesLogger logger)
+++    {
+++        _logger = logger;
+++    }
+++
+++    /// <summary>
+++    /// Apply variables to a template string. Returns (result, missingVars).
+++    /// If any variables are missing, the message is NOT sent (missingVars.Count > 0).
+++    /// </summary>
+++    public (string result, List<string> missingVars) Substitute(
+++        string template, Dictionary<string, string>? variables)
+++    {
+++        var missingVars = new List<string>();
+++
+++        if (string.IsNullOrEmpty(template))
+++            return (template, missingVars);
+++
+++        var result = VariablePattern.Replace(template, match =>
+++        {
+++            var varName = match.Groups[1].Value;
+++            if (variables != null && variables.TryGetValue(varName, out var value))
+++                return value;
+++
+++            missingVars.Add(varName);
+++            return match.Value; // Keep original {{var}} so it's visible what's missing
+++        });
+++
+++        return (result, missingVars);
+++    }
+++
+++    /// <summary>
+++    /// Extract all variable names from a template string.
+++    /// </summary>
+++    public static List<string> ExtractVariables(string template)
+++    {
+++        if (string.IsNullOrEmpty(template))
+++            return new List<string>();
+++
+++        return VariablePattern.Matches(template)
+++            .Select(m => m.Groups[1].Value)
+++            .Distinct()
+++            .ToList();
+++    }
+++}
++diff --git a/src/Invekto.Outbound/Services/TriggerProcessor.cs b/src/Invekto.Outbound/Services/TriggerProcessor.cs
++new file mode 100644
++index 0000000..3019f9b
++--- /dev/null
+++++ b/src/Invekto.Outbound/Services/TriggerProcessor.cs
++@@ -0,0 +1,88 @@
+++using Invekto.Outbound.Data;
+++using Invekto.Shared.Constants;
+++using Invekto.Shared.DTOs.Outbound;
+++using Invekto.Shared.Logging;
+++
+++namespace Invekto.Outbound.Services;
+++
+++/// <summary>
+++/// Processes trigger events from Main App webhooks.
+++/// Finds matching template, applies variables, inserts single message.
+++/// Thread-safe, register as singleton.
+++/// </summary>
+++public sealed class TriggerProcessor
+++{
+++    private readonly OutboundRepository _repository;
+++    private readonly TemplateEngine _templateEngine;
+++    private readonly OptOutManager _optOutManager;
+++    private readonly JsonLinesLogger _logger;
+++
+++    public TriggerProcessor(
+++        OutboundRepository repository,
+++        TemplateEngine templateEngine,
+++        OptOutManager optOutManager,
+++        JsonLinesLogger logger)
+++    {
+++        _repository = repository;
+++        _templateEngine = templateEngine;
+++        _optOutManager = optOutManager;
+++        _logger = logger;
+++    }
+++
+++    /// <summary>
+++    /// Process a trigger event. Returns response or error.
+++    /// </summary>
+++    public async Task<(TriggerWebhookResponse? response, string? errorCode, string? errorMessage, int statusCode)>
+++        ProcessTriggerAsync(
+++            int tenantId, TriggerWebhookRequest request, CancellationToken ct = default)
+++    {
+++        if (string.IsNullOrWhiteSpace(request.Event))
+++            return (null, ErrorCodes.OutboundInvalidBroadcastPayload, "event is required", 400);
+++
+++        if (string.IsNullOrWhiteSpace(request.Phone))
+++            return (null, ErrorCodes.OutboundInvalidBroadcastPayload, "phone is required", 400);
+++
+++        // Check opt-out
+++        if (await _optOutManager.IsOptedOutAsync(tenantId, request.Phone, ct))
+++        {
+++            _logger.SystemInfo($"Trigger skipped (opted out): tenant={tenantId}, phone={request.Phone}, event={request.Event}");
+++            return (null, ErrorCodes.OutboundRecipientOptedOut,
+++                $"Recipient {request.Phone} has opted out of messages", 409);
+++        }
+++
+++        // Find matching trigger template
+++        var template = await _repository.GetTriggerTemplateAsync(tenantId, request.Event, ct);
+++        if (template == null)
+++        {
+++            return (null, ErrorCodes.OutboundNoMatchingTriggerTemplate,
+++                $"No active template found for event '{request.Event}' in tenant {tenantId}", 404);
+++        }
+++
+++        // Apply template variables
+++        var (messageText, missingVars) = _templateEngine.Substitute(
+++            template.MessageTemplate, request.Variables);
+++
+++        if (missingVars.Count > 0)
+++        {
+++            _logger.SystemWarn(
+++                $"Trigger template {template.Id} has missing variables: [{string.Join(", ", missingVars)}]");
+++            return (null, ErrorCodes.OutboundInvalidBroadcastPayload,
+++                $"Template requires variables: {string.Join(", ", missingVars)}", 400);
+++        }
+++
+++        // Insert single message (no broadcast_id)
+++        var messageId = await _repository.InsertMessageAsync(
+++            tenantId, null, template.Id, request.Phone, messageText, ct);
+++
+++        _logger.SystemInfo(
+++            $"Trigger message queued: id={messageId}, tenant={tenantId}, " +
+++            $"event={request.Event}, phone={request.Phone}, template={template.Id}");
+++
+++        return (new TriggerWebhookResponse
+++        {
+++            MessageId = messageId,
+++            TemplateId = template.Id,
+++            TemplateName = template.Name
+++        }, null, null, 202);
+++    }
+++}
++diff --git a/src/Invekto.Outbound/appsettings.json b/src/Invekto.Outbound/appsettings.json
++new file mode 100644
++index 0000000..490e373
++--- /dev/null
+++++ b/src/Invekto.Outbound/appsettings.json
++@@ -0,0 +1,27 @@
+++{
+++  "Service": {
+++    "ListenPort": 7107
+++  },
+++  "Logging": {
+++    "FilePath": "logs"
+++  },
+++  "Jwt": {
+++    "SecretKey": "",
+++    "Issuer": null,
+++    "Audience": null,
+++    "ClockSkewSeconds": 60
+++  },
+++  "ConnectionStrings": {
+++    "PostgreSQL": "Host=localhost;Port=5432;Database=invekto;Username=invekto;Password="
+++  },
+++  "RateLimit": {
+++    "DefaultMessagesPerMinute": 30,
+++    "SenderIntervalMs": 1000
+++  },
+++  "Callback": {
+++    "DefaultCallbackUrl": "",
+++    "MaxRetries": 3,
+++    "BaseDelayMs": 500,
+++    "TimeoutMs": 5000
+++  }
+++}
++diff --git a/src/Invekto.Shared/Constants/ErrorCodes.cs b/src/Invekto.Shared/Constants/ErrorCodes.cs
++index 9c5c16f..cf41acc 100644
++--- a/src/Invekto.Shared/Constants/ErrorCodes.cs
+++++ b/src/Invekto.Shared/Constants/ErrorCodes.cs
++@@ -55,6 +55,18 @@ public static class ErrorCodes
++     public const string AgentAIClaudeTimeout = "INV-AA-005";
++     public const string AgentAIInvalidFeedback = "INV-AA-006";
++ 
+++    // Outbound errors (INV-OB-xxx) -- GR-1.3
+++    public const string OutboundInvalidBroadcastPayload = "INV-OB-001";
+++    public const string OutboundTemplateNotFound = "INV-OB-002";
+++    public const string OutboundRateLimitExceeded = "INV-OB-003";
+++    public const string OutboundRecipientOptedOut = "INV-OB-004";
+++    public const string OutboundBroadcastNotFound = "INV-OB-005";
+++    public const string OutboundDeliveryStatusFailed = "INV-OB-006";
+++    public const string OutboundInvalidTemplatePayload = "INV-OB-007";
+++    public const string OutboundNoMatchingTriggerTemplate = "INV-OB-008";
+++    public const string OutboundMessageSendCallbackFailed = "INV-OB-009";
+++    public const string OutboundTooManyRecipients = "INV-OB-010";
+++
++     // Database errors (INV-DB-xxx)
++     public const string DatabaseConnectionFailed = "INV-DB-001";
++     public const string DatabaseQueryTimeout = "INV-DB-002";
++diff --git a/src/Invekto.Shared/DTOs/Integration/OutgoingCallback.cs b/src/Invekto.Shared/DTOs/Integration/OutgoingCallback.cs
++index fa506e4..991eefa 100644
++--- a/src/Invekto.Shared/DTOs/Integration/OutgoingCallback.cs
+++++ b/src/Invekto.Shared/DTOs/Integration/OutgoingCallback.cs
++@@ -77,6 +77,19 @@ public sealed class CallbackData
++     /// <summary>Error message when processing fails</summary>
++     [JsonPropertyName("error_message")]
++     public string? ErrorMessage { get; init; }
+++
+++    // GR-1.3 Outbound: fields for send_message callback
+++    /// <summary>Recipient phone number (E.164 format) for outbound message delivery</summary>
+++    [JsonPropertyName("phone")]
+++    public string? Phone { get; init; }
+++
+++    /// <summary>Broadcast ID that this message belongs to (null for trigger-based)</summary>
+++    [JsonPropertyName("broadcast_id")]
+++    public Guid? BroadcastId { get; init; }
+++
+++    /// <summary>Outbound message record ID for delivery status correlation</summary>
+++    [JsonPropertyName("outbound_message_id")]
+++    public long? OutboundMessageId { get; init; }
++ }
++ 
++ /// <summary>
++diff --git a/src/Invekto.Shared/DTOs/Outbound/BroadcastDtos.cs b/src/Invekto.Shared/DTOs/Outbound/BroadcastDtos.cs
++new file mode 100644
++index 0000000..2205700
++--- /dev/null
+++++ b/src/Invekto.Shared/DTOs/Outbound/BroadcastDtos.cs
++@@ -0,0 +1,85 @@
+++using System.Text.Json.Serialization;
+++
+++namespace Invekto.Shared.DTOs.Outbound;
+++
+++/// <summary>
+++/// POST /api/v1/broadcast/send request body.
+++/// Main App sends recipients + template_id to start a broadcast.
+++/// </summary>
+++public sealed class BroadcastSendRequest
+++{
+++    [JsonPropertyName("template_id")]
+++    public int TemplateId { get; set; }
+++
+++    [JsonPropertyName("recipients")]
+++    public List<BroadcastRecipient> Recipients { get; set; } = new();
+++
+++    [JsonPropertyName("scheduled_at")]
+++    public DateTime? ScheduledAt { get; set; }
+++}
+++
+++public sealed class BroadcastRecipient
+++{
+++    [JsonPropertyName("phone")]
+++    public string Phone { get; set; } = "";
+++
+++    [JsonPropertyName("variables")]
+++    public Dictionary<string, string>? Variables { get; set; }
+++}
+++
+++/// <summary>
+++/// 202 Accepted response for broadcast send.
+++/// </summary>
+++public sealed class BroadcastSendResponse
+++{
+++    [JsonPropertyName("broadcast_id")]
+++    public Guid BroadcastId { get; set; }
+++
+++    [JsonPropertyName("total_recipients")]
+++    public int TotalRecipients { get; set; }
+++
+++    [JsonPropertyName("queued")]
+++    public int Queued { get; set; }
+++
+++    [JsonPropertyName("skipped_optout")]
+++    public int SkippedOptout { get; set; }
+++}
+++
+++/// <summary>
+++/// GET /api/v1/broadcast/{broadcastId}/status response.
+++/// </summary>
+++public sealed class BroadcastStatusResponse
+++{
+++    [JsonPropertyName("broadcast_id")]
+++    public Guid BroadcastId { get; set; }
+++
+++    [JsonPropertyName("status")]
+++    public string Status { get; set; } = "";
+++
+++    [JsonPropertyName("total_recipients")]
+++    public int TotalRecipients { get; set; }
+++
+++    [JsonPropertyName("queued")]
+++    public int Queued { get; set; }
+++
+++    [JsonPropertyName("sent")]
+++    public int Sent { get; set; }
+++
+++    [JsonPropertyName("delivered")]
+++    public int Delivered { get; set; }
+++
+++    [JsonPropertyName("read")]
+++    public int Read { get; set; }
+++
+++    [JsonPropertyName("failed")]
+++    public int Failed { get; set; }
+++
+++    [JsonPropertyName("created_at")]
+++    public DateTime CreatedAt { get; set; }
+++
+++    [JsonPropertyName("started_at")]
+++    public DateTime? StartedAt { get; set; }
+++
+++    [JsonPropertyName("completed_at")]
+++    public DateTime? CompletedAt { get; set; }
+++}
++diff --git a/src/Invekto.Shared/DTOs/Outbound/TemplateDtos.cs b/src/Invekto.Shared/DTOs/Outbound/TemplateDtos.cs
++new file mode 100644
++index 0000000..972d0c0
++--- /dev/null
+++++ b/src/Invekto.Shared/DTOs/Outbound/TemplateDtos.cs
++@@ -0,0 +1,69 @@
+++using System.Text.Json.Serialization;
+++
+++namespace Invekto.Shared.DTOs.Outbound;
+++
+++/// <summary>
+++/// POST /api/v1/templates request body.
+++/// </summary>
+++public sealed class TemplateCreateRequest
+++{
+++    [JsonPropertyName("name")]
+++    public string Name { get; set; } = "";
+++
+++    [JsonPropertyName("trigger_event")]
+++    public string TriggerEvent { get; set; } = "manual";
+++
+++    [JsonPropertyName("message_template")]
+++    public string MessageTemplate { get; set; } = "";
+++
+++    [JsonPropertyName("variables_json")]
+++    public Dictionary<string, string>? VariablesJson { get; set; }
+++}
+++
+++/// <summary>
+++/// PUT /api/v1/templates/{id} request body. All fields optional.
+++/// </summary>
+++public sealed class TemplateUpdateRequest
+++{
+++    [JsonPropertyName("name")]
+++    public string? Name { get; set; }
+++
+++    [JsonPropertyName("trigger_event")]
+++    public string? TriggerEvent { get; set; }
+++
+++    [JsonPropertyName("message_template")]
+++    public string? MessageTemplate { get; set; }
+++
+++    [JsonPropertyName("variables_json")]
+++    public Dictionary<string, string>? VariablesJson { get; set; }
+++}
+++
+++/// <summary>
+++/// Template list item in GET /api/v1/templates response.
+++/// </summary>
+++public sealed class TemplateDto
+++{
+++    [JsonPropertyName("id")]
+++    public int Id { get; set; }
+++
+++    [JsonPropertyName("name")]
+++    public string Name { get; set; } = "";
+++
+++    [JsonPropertyName("trigger_event")]
+++    public string TriggerEvent { get; set; } = "";
+++
+++    [JsonPropertyName("message_template")]
+++    public string MessageTemplate { get; set; } = "";
+++
+++    [JsonPropertyName("variables_json")]
+++    public Dictionary<string, string>? VariablesJson { get; set; }
+++
+++    [JsonPropertyName("is_active")]
+++    public bool IsActive { get; set; }
+++
+++    [JsonPropertyName("created_at")]
+++    public DateTime CreatedAt { get; set; }
+++
+++    [JsonPropertyName("updated_at")]
+++    public DateTime UpdatedAt { get; set; }
+++}
++diff --git a/src/Invekto.Shared/DTOs/Outbound/WebhookDtos.cs b/src/Invekto.Shared/DTOs/Outbound/WebhookDtos.cs
++new file mode 100644
++index 0000000..03f239f
++--- /dev/null
+++++ b/src/Invekto.Shared/DTOs/Outbound/WebhookDtos.cs
++@@ -0,0 +1,102 @@
+++using System.Text.Json.Serialization;
+++
+++namespace Invekto.Shared.DTOs.Outbound;
+++
+++/// <summary>
+++/// POST /api/v1/webhook/trigger request - event from Main App triggers a template message.
+++/// </summary>
+++public sealed class TriggerWebhookRequest
+++{
+++    [JsonPropertyName("event")]
+++    public string Event { get; set; } = "";
+++
+++    [JsonPropertyName("phone")]
+++    public string Phone { get; set; } = "";
+++
+++    [JsonPropertyName("variables")]
+++    public Dictionary<string, string>? Variables { get; set; }
+++}
+++
+++/// <summary>
+++/// 202 response for trigger webhook.
+++/// </summary>
+++public sealed class TriggerWebhookResponse
+++{
+++    [JsonPropertyName("message_id")]
+++    public long MessageId { get; set; }
+++
+++    [JsonPropertyName("template_id")]
+++    public int TemplateId { get; set; }
+++
+++    [JsonPropertyName("template_name")]
+++    public string TemplateName { get; set; } = "";
+++}
+++
+++/// <summary>
+++/// POST /api/v1/webhook/delivery-status - delivery status from Main App.
+++/// </summary>
+++public sealed class DeliveryStatusRequest
+++{
+++    [JsonPropertyName("external_message_id")]
+++    public string ExternalMessageId { get; set; } = "";
+++
+++    [JsonPropertyName("status")]
+++    public string Status { get; set; } = "";
+++
+++    [JsonPropertyName("failed_reason")]
+++    public string? FailedReason { get; set; }
+++
+++    [JsonPropertyName("timestamp")]
+++    public DateTime? Timestamp { get; set; }
+++}
+++
+++/// <summary>
+++/// POST /api/v1/webhook/message - incoming message for opt-out detection.
+++/// </summary>
+++public sealed class IncomingMessageRequest
+++{
+++    [JsonPropertyName("phone")]
+++    public string Phone { get; set; } = "";
+++
+++    [JsonPropertyName("message_text")]
+++    public string MessageText { get; set; } = "";
+++}
+++
+++/// <summary>
+++/// Response for incoming message opt-out check.
+++/// </summary>
+++public sealed class IncomingMessageResponse
+++{
+++    [JsonPropertyName("opted_out")]
+++    public bool OptedOut { get; set; }
+++
+++    [JsonPropertyName("keyword_matched")]
+++    public string? KeywordMatched { get; set; }
+++}
+++
+++/// <summary>
+++/// POST /api/v1/optout request - manual opt-out add.
+++/// </summary>
+++public sealed class OptOutRequest
+++{
+++    [JsonPropertyName("phone")]
+++    public string Phone { get; set; } = "";
+++
+++    [JsonPropertyName("reason")]
+++    public string? Reason { get; set; }
+++}
+++
+++/// <summary>
+++/// GET /api/v1/optout/check/{phone} response.
+++/// </summary>
+++public sealed class OptOutCheckResponse
+++{
+++    [JsonPropertyName("phone")]
+++    public string Phone { get; set; } = "";
+++
+++    [JsonPropertyName("opted_out")]
+++    public bool OptedOut { get; set; }
+++
+++    [JsonPropertyName("opted_out_at")]
+++    public DateTime? OptedOutAt { get; set; }
+++}
+diff --git a/arch/session-memory.md b/arch/session-memory.md
+index f3808ae..7a14c3f 100644
+--- a/arch/session-memory.md
++++ b/arch/session-memory.md
+@@ -5,8 +5,8 @@
+ ## Last Update
+ 
+ - **Date:** 2026-02-12
+-- **Status:** Ops tamamlandΓöÇΓûÆ - tΓö£Γò¥m servisler production'da Γö£┬║alΓöÇΓûÆΓö╝╞ÆΓöÇΓûÆyor
+-- **Last Task:** Production deploy doΓöÇ╞Ærulama. Backend:5000 (external OK), Automation:7108 (external OK), ChatAnalysis:7101 (localhost-only OK), AgentAI:7105 (localhost-only OK). Firewall kurallarΓöÇΓûÆ tasarΓöÇΓûÆma uygun.
++- **Status:** GR-1.3 Outbound service implemented - Build PASS, /rev bekliyor
++- **Last Task:** Invekto.Outbound microservice (Port 7107) full implementation. Backend proxy (12 endpoints), deploy scripts updated, all arch files in sync.
+ 
+ ---
+ 
+@@ -50,6 +50,19 @@
+   - API contract: `arch/contracts/agentai-suggest.json`
+   - Error codes: INV-AA-001 ~ INV-AA-006
+ 
++- **GR-1.3 Outbound Service (Port 7107):**
++  - Broadcast/bulk messaging (max 1000 recipients, async queue)
++  - Event-based trigger engine (webhook -> template -> send)
++  - Template engine: `{{variable}}` substitution with missing var detection
++  - Tenant-based sliding window rate limiter (in-memory, configurable msg/min)
++  - Opt-out management (STOP/DUR/ΓöÇΓûæPTAL keyword detection)
++  - Delivery status tracking (sent/delivered/failed/read counters)
++  - Background IHostedService message sender (batch dequeue, FOR UPDATE SKIP LOCKED)
++  - Backend proxy pattern (Main App -> Backend:5000 -> Outbound:7107, localhost-only)
++  - DB schema: `arch/db/outbound.sql` (outbound_templates, outbound_broadcasts, outbound_messages, outbound_optouts)
++  - API contract: `arch/contracts/outbound-broadcast.json`
++  - Error codes: INV-OB-001 ~ INV-OB-010
++
+ ### Tech Stack
+ | Component | Technology |
+ |-----------|------------|
+@@ -65,7 +78,7 @@
+ | ChatAnalysis | 7101 | Active |
+ | AgentAI | 7105 | Implemented (GR-1.11) |
+ | Integrations | 7106 | Reserved (Phase 2+) |
+-| Outbound | 7107 | Reserved (Phase 1) |
++| Outbound | 7107 | Implemented (GR-1.3) |
+ | Automation | 7108 | Implemented (GR-1.1) |
+ | Simulator | 4500 | Dev-only tool (Node.js) |
+ 
+@@ -73,11 +86,11 @@
+ - **Script:** `dev-to-invekto-services.bat`
+ - **Protokol:** FTPES (explicit TLS)
+ - **FTP Host:** services.invekto.com
+-- **Sunucu Yapi:** `E:\Invekto\Backend\current\`, `E:\Invekto\ChatAnalysis\current\`, `E:\Invekto\Automation\current\`, `E:\Invekto\AgentAI\current\`
++- **Sunucu Yapi:** `E:\Invekto\Backend\current\`, `E:\Invekto\ChatAnalysis\current\`, `E:\Invekto\Automation\current\`, `E:\Invekto\AgentAI\current\`, `E:\Invekto\Outbound\current\`
+ - **Sunucu Domain:** services.invekto.com
+ - **Sunucu Root:** `E:\Invekto\` (Backend, ChatAnalysis, scripts, logs)
+ - **Service Manager:** NSSM (`E:\nssm.exe`)
+-- **Servisler:** InvektoBackend, InvektoChatAnalysis, InvektoAutomation, InvektoAgentAI, InvektoDeployWatcher (auto-start, auto-restart)
++- **Servisler:** InvektoBackend, InvektoChatAnalysis, InvektoAutomation, InvektoAgentAI, InvektoOutbound, InvektoDeployWatcher (auto-start, auto-restart)
+ - **Deploy Watcher:** `E:\Invekto\scripts\deploy-watcher.ps1` (flag-based stop/start)
+ - **.NET Runtime:** ASP.NET Core 8.0.23 (`C:\Program Files\dotnet`)
+ - **PostgreSQL:** localhost:5432 / invekto DB (pgAdmin ile yonetim)
+@@ -102,7 +115,7 @@
+ - [x] ~~Q: agentai.sql calistir~~ (Tamamlandi)
+ - [x] ~~Q: AgentAI appsettings.Production.json doldur~~ (Tamamlandi)
+ - [x] ~~Q: AgentAI deploy + Windows Service kurulumu~~ (Tamamlandi - InvektoAgentAI SERVICE_RUNNING)
+-- [ ] **GR-1.3 Outbound Service** (Port 7107) - Broadcast, trigger, template engine, rate limiting
++- [x] ~~GR-1.3 Outbound Service~~ (Tamamlandi - Port 7107, Build PASS, /rev bekliyor)
+ 
+ ### Known Issues
+ - (HenΓö£Γò¥z yok)
+@@ -131,6 +144,10 @@
+ | 2026-02-11 | Per-agent feedback learning | Son 20 interaction Claude prompt'a enjekte, kisisel oneri |
+ | 2026-02-11 | Async feedback (fire-and-forget) | Agent accept/edit/reject sonrasi POST, response beklenmez |
+ | 2026-02-11 | Backend proxy for simulator | Tum simulator trafigi Backend:5000 uzerinden, internal servisler localhost-only |
++| 2026-02-12 | Outbound ayri mikroservis | Broadcast + trigger engine, Port 7107, Backend proxy pattern |
++| 2026-02-12 | In-memory rate limiter | Tenant bazli sliding window, queue (reject degil), configurable msg/min |
++| 2026-02-12 | FOR UPDATE SKIP LOCKED | Message dequeue icin safe concurrency, batch 10 |
++| 2026-02-12 | Stop keyword detection | STOP, DUR, IPTAL, CIKIS - exact match on trimmed uppercase |
+ 
+ ---
+ 
+@@ -145,6 +162,7 @@ src/
+ ╬ô├╢├⌐   ╬ô├╢┬ú╬ô├╢├ç╬ô├╢├ç DTOs/
+ ╬ô├╢├⌐   ╬ô├╢├⌐   ╬ô├╢┬ú╬ô├╢├ç╬ô├╢├ç AgentAI/          # GR-1.11: Suggest/Feedback DTOs
+ ╬ô├╢├⌐   ╬ô├╢├⌐   ╬ô├╢┬ú╬ô├╢├ç╬ô├╢├ç ChatAnalysis/
++╬ô├╢├⌐   ╬ô├╢├⌐   ╬ô├╢┬ú╬ô├╢├ç╬ô├╢├ç Outbound/          # GR-1.3: Broadcast/Template/Webhook DTOs
+ ╬ô├╢├⌐   ╬ô├╢├⌐   ╬ô├╢├╢╬ô├╢├ç╬ô├╢├ç Integration/      # GR-1.9: Webhook/Callback DTOs
+ ╬ô├╢├⌐   ╬ô├╢┬ú╬ô├╢├ç╬ô├╢├ç Integration/          # GR-1.9: Callback client
+ ╬ô├╢├⌐   ╬ô├╢├╢╬ô├╢├ç╬ô├╢├ç Logging/
+@@ -157,10 +175,14 @@ src/
+ ╬ô├╢├⌐   ╬ô├╢┬ú╬ô├╢├ç╬ô├╢├ç Data/                # AutomationRepository
+ ╬ô├╢├⌐   ╬ô├╢┬ú╬ô├╢├ç╬ô├╢├ç Middleware/           # Traffic logging + JWT auth
+ ╬ô├╢├⌐   ╬ô├╢├╢╬ô├╢├ç╬ô├╢├ç Services/            # FlowEngine, IntentDetector, FaqMatcher, WorkingHoursChecker, AutomationOrchestrator
++╬ô├╢┬ú╬ô├╢├ç╬ô├╢├ç Invekto.Outbound/         # GR-1.3: Broadcast & Trigger Engine (Port 7107)
++╬ô├╢├⌐   ╬ô├╢┬ú╬ô├╢├ç╬ô├╢├ç Data/                # OutboundRepository
++╬ô├╢├⌐   ╬ô├╢┬ú╬ô├╢├ç╬ô├╢├ç Middleware/           # Traffic logging + JWT auth
++╬ô├╢├⌐   ╬ô├╢├╢╬ô├╢├ç╬ô├╢├ç Services/            # BroadcastOrchestrator, TriggerProcessor, MessageSenderService, TemplateEngine, OptOutManager, RateLimiter
+ ╬ô├╢├╢╬ô├╢├ç╬ô├╢├ç Invekto.Backend/          # Backend API (Port 5000)
+     ╬ô├╢┬ú╬ô├╢├ç╬ô├╢├ç Dashboard/            # React/TS Ops Dashboard
+     ╬ô├╢┬ú╬ô├╢├ç╬ô├╢├ç Middleware/            # Traffic logging + JWT auth
+-    ╬ô├╢├╢╬ô├╢├ç╬ô├╢├ç Services/             # ChatAnalysisClient, AutomationClient, AgentAIClient
++    ╬ô├╢├╢╬ô├╢├ç╬ô├╢├ç Services/             # ChatAnalysisClient, AutomationClient, AgentAIClient, OutboundClient
+ ```
+ 
+ ---
+@@ -168,13 +190,13 @@ src/
+ ## Context for Next Session
+ 
+ Sonraki session'da:
+-1. **GR-1.3 Invekto.Outbound** mikroservisi (Port 7107) implement et
+-2. Scope: Broadcast/toplu mesaj, trigger engine, template engine, rate limiting, opt-out, delivery tracking
+-3. DB tablolari: outbound_templates, outbound_messages, outbound_optouts (roadmap-phases.md'de tanimli)
+-4. Mimari: Backend proxy pattern (Main App -> Backend:5000 -> Outbound:7107, localhost-only)
+-5. Mevcut pattern'leri takip et: Automation + AgentAI servisleri referans
+-6. Firewall: localhost-only (remoteip=127.0.0.1) - Backend proxy uzerinden erisim
+-7. Deploy sonrasi: outbound.sql calistir, appsettings.Production.json doldur, NSSM servis kur
++1. **GR-1.3 Outbound /rev tamamla** - Codex review prompt gonder, PASS/FAIL bekle
++2. Deploy sonrasi Q'nun yapacaklari:
++   - `outbound.sql` calistir (PostgreSQL'de tablolari olustur)
++   - `appsettings.Production.json` doldur (JWT key, PostgreSQL connection, callback URL)
++   - NSSM servis kur: `install-services.bat` (veya manual InvektoOutbound)
++   - Firewall: Port 7107 localhost-only (zaten firewall-rules.bat'a eklendi)
++3. Test: `http://localhost:7107/health` (Outbound direkt) veya `http://services.invekto.com:5000/api/v1/outbound/health` (Backend proxy)
+ 
+ ---
+ 
+diff --git a/dev-to-invekto-services.bat b/dev-to-invekto-services.bat
+index 3d91641..54fb911 100644
+--- a/dev-to-invekto-services.bat
++++ b/dev-to-invekto-services.bat
+@@ -27,6 +27,7 @@ set "REMOTE_BACKEND=/e/Invekto/Backend/current"
+ set "REMOTE_CHATANALYSIS=/e/Invekto/ChatAnalysis/current"
+ set "REMOTE_AUTOMATION=/e/Invekto/Automation/current"
+ set "REMOTE_AGENTAI=/e/Invekto/AgentAI/current"
++set "REMOTE_OUTBOUND=/e/Invekto/Outbound/current"
+ set "REMOTE_SIMULATOR=/e/Invekto/Simulator"
+ 
+ REM Local paths
+@@ -36,6 +37,7 @@ set "LOCAL_BACKEND=%LOCAL_DEPLOY%\Backend"
+ set "LOCAL_CHATANALYSIS=%LOCAL_DEPLOY%\ChatAnalysis"
+ set "LOCAL_AUTOMATION=%LOCAL_DEPLOY%\Automation"
+ set "LOCAL_AGENTAI=%LOCAL_DEPLOY%\AgentAI"
++set "LOCAL_OUTBOUND=%LOCAL_DEPLOY%\Outbound"
+ set "LOCAL_SIMULATOR=%~dp0tools\simulator"
+ 
+ REM Check WinSCP exists
+@@ -51,6 +53,7 @@ if not exist "!LOCAL_BACKEND!" mkdir "!LOCAL_BACKEND!"
+ if not exist "!LOCAL_CHATANALYSIS!" mkdir "!LOCAL_CHATANALYSIS!"
+ if not exist "!LOCAL_AUTOMATION!" mkdir "!LOCAL_AUTOMATION!"
+ if not exist "!LOCAL_AGENTAI!" mkdir "!LOCAL_AGENTAI!"
++if not exist "!LOCAL_OUTBOUND!" mkdir "!LOCAL_OUTBOUND!"
+ 
+ echo ============================================
+ echo [1/5] Building Backend...
+@@ -105,10 +108,23 @@ if errorlevel 1 (
+ echo [OK] AgentAI built to !LOCAL_AGENTAI!
+ echo.
+ 
++echo ============================================
++echo [5/5] Building Outbound...
++echo ============================================
++echo.
++
++dotnet publish src/Invekto.Outbound/Invekto.Outbound.csproj -c Release -o "!LOCAL_OUTBOUND!" --self-contained false
++if errorlevel 1 (
++    echo [ERROR] Outbound build failed!
++    goto :error_exit
++)
++echo [OK] Outbound built to !LOCAL_OUTBOUND!
++echo.
++
+ REM Q: Create build marker
+ for /f "tokens=*" %%i in ('git rev-parse --short HEAD 2^>nul') do set "GIT_HASH=%%i"
+ for /f "tokens=*" %%i in ('git rev-parse --abbrev-ref HEAD 2^>nul') do set "GIT_BRANCH=%%i"
+-powershell -NoProfile -Command "$marker = @{ timestamp = (Get-Date).ToString('o'); gitHash = '%GIT_HASH%'; gitBranch = '%GIT_BRANCH%'; services = @('Backend','ChatAnalysis','Automation','AgentAI') }; [System.IO.File]::WriteAllText('!LOCAL_DEPLOY!\.build-marker.json', ($marker | ConvertTo-Json))"
++powershell -NoProfile -Command "$marker = @{ timestamp = (Get-Date).ToString('o'); gitHash = '%GIT_HASH%'; gitBranch = '%GIT_BRANCH%'; services = @('Backend','ChatAnalysis','Automation','AgentAI','Outbound') }; [System.IO.File]::WriteAllText('!LOCAL_DEPLOY!\.build-marker.json', ($marker | ConvertTo-Json))"
+ echo [OK] Build marker created (%GIT_BRANCH%@%GIT_HASH%)
+ echo.
+ 
+@@ -147,10 +163,12 @@ echo Local Backend:      !LOCAL_BACKEND!
+ echo Local ChatAnalysis: !LOCAL_CHATANALYSIS!
+ echo Local Automation:   !LOCAL_AUTOMATION!
+ echo Local AgentAI:      !LOCAL_AGENTAI!
++echo Local Outbound:     !LOCAL_OUTBOUND!
+ echo Remote Backend:     %REMOTE_BACKEND%
+ echo Remote ChatAnalysis: %REMOTE_CHATANALYSIS%
+ echo Remote Automation:  %REMOTE_AUTOMATION%
+ echo Remote AgentAI:     %REMOTE_AGENTAI%
++echo Remote Outbound:    %REMOTE_OUTBOUND%
+ echo.
+ echo Mode: Synchronize (only changed files)
+ 
+@@ -167,6 +185,7 @@ set "WINSCP_SCRIPT=%TEMP%\winscp_invekto_deploy.txt"
+     echo mkdir "%REMOTE_CHATANALYSIS%"
+     echo mkdir "%REMOTE_AUTOMATION%"
+     echo mkdir "%REMOTE_AGENTAI%"
++    echo mkdir "%REMOTE_OUTBOUND%"
+     echo mkdir "%REMOTE_SIMULATOR%"
+     echo option batch abort
+     echo echo Uploading Backend to STAGING...
+@@ -177,6 +196,8 @@ set "WINSCP_SCRIPT=%TEMP%\winscp_invekto_deploy.txt"
+     echo synchronize remote "!LOCAL_AUTOMATION!" "%REMOTE_AUTOMATION%" -mirror -transfer=binary -criteria=size,time -resumesupport=on -filemask="|appsettings.Production.json"
+     echo echo Uploading AgentAI to STAGING...
+     echo synchronize remote "!LOCAL_AGENTAI!" "%REMOTE_AGENTAI%" -mirror -transfer=binary -criteria=size,time -resumesupport=on -filemask="|appsettings.Production.json"
++    echo echo Uploading Outbound to STAGING...
++    echo synchronize remote "!LOCAL_OUTBOUND!" "%REMOTE_OUTBOUND%" -mirror -transfer=binary -criteria=size,time -resumesupport=on -filemask="|appsettings.Production.json"
+     echo echo Uploading Simulator to STAGING...
+     echo synchronize remote "!LOCAL_SIMULATOR!" "%REMOTE_SIMULATOR%" -mirror -transfer=binary -criteria=size,time -resumesupport=on -filemask="|node_modules/;.env"
+     echo echo Uploading build marker...
+@@ -246,6 +267,7 @@ echo   Backend:      %REMOTE_BACKEND%
+ echo   ChatAnalysis: %REMOTE_CHATANALYSIS%
+ echo   Automation:   %REMOTE_AUTOMATION%
+ echo   AgentAI:      %REMOTE_AGENTAI%
++echo   Outbound:     %REMOTE_OUTBOUND%
+ echo   Simulator:    %REMOTE_SIMULATOR%
+ echo.
+ echo ============================================
+diff --git a/src/Invekto.Backend/Program.cs b/src/Invekto.Backend/Program.cs
+index 5e9fc0a..efb6fe7 100644
+--- a/src/Invekto.Backend/Program.cs
++++ b/src/Invekto.Backend/Program.cs
+@@ -29,6 +29,10 @@ var agentAIUrl = builder.Configuration["Microservice:AgentAI:Url"]
+     ?? $"http://localhost:{ServiceConstants.AgentAIPort}";
+ var agentAILogPath = builder.Configuration["Microservice:AgentAI:LogPath"];
+ var agentAISuggestTimeoutMs = builder.Configuration.GetValue<int>("Microservice:AgentAI:SuggestTimeoutMs", 15000);
++var outboundUrl = builder.Configuration["Microservice:Outbound:Url"]
++    ?? $"http://localhost:{ServiceConstants.OutboundPort}";
++var outboundLogPath = builder.Configuration["Microservice:Outbound:LogPath"];
++var outboundTimeoutMs = builder.Configuration.GetValue<int>("Microservice:Outbound:TimeoutMs", 10000);
+ 
+ // Register JSON Lines logger
+ builder.Services.AddSingleton(new JsonLinesLogger(ServiceConstants.BackendServiceName, logPath));
+@@ -47,6 +51,10 @@ if (!string.IsNullOrEmpty(agentAILogPath))
+ {
+     logPaths.Add(agentAILogPath);
+ }
++if (!string.IsNullOrEmpty(outboundLogPath))
++{
++    logPaths.Add(outboundLogPath);
++}
+ builder.Services.AddSingleton(new LogReader(logPaths.ToArray(), slowThresholdMs));
+ 
+ // Register log cleanup service (30 day retention)
+@@ -80,6 +88,13 @@ builder.Services.AddHttpClient<AgentAIClient>(client =>
+     client.Timeout = TimeSpan.FromMilliseconds(agentAISuggestTimeoutMs);
+ });
+ 
++// Configure Outbound HTTP client (GR-1.3)
++builder.Services.AddHttpClient<OutboundClient>(client =>
++{
++    client.BaseAddress = new Uri(outboundUrl);
++    client.Timeout = TimeSpan.FromMilliseconds(outboundTimeoutMs);
++});
++
+ // ============================================
+ // GR-1.9: INTEGRATION BRIDGE SETUP
+ // ============================================
+@@ -133,7 +148,7 @@ app.UseTrafficLogging();
+ if (jwtValidator != null)
+ {
+     var jwtLogger = app.Services.GetRequiredService<JsonLinesLogger>();
+-    app.UseJwtAuth(jwtValidator, jwtLogger, "/api/v1/webhook/", "/api/v1/automation/");
++    app.UseJwtAuth(jwtValidator, jwtLogger, "/api/v1/webhook/", "/api/v1/automation/", "/api/v1/outbound/");
+ }
+ 
+ // Enable static file serving for Dashboard UI (wwwroot/)
+@@ -171,7 +186,7 @@ bool ValidateOpsAuth(HttpContext ctx)
+ }
+ 
+ // OPS endpoint - Stage-0 troubleshooting dashboard
+-app.MapGet("/ops", async (HttpContext ctx, ChatAnalysisClient chatClient, AutomationClient automationClient, AgentAIClient agentAIClient, LogReader logReader) =>
++app.MapGet("/ops", async (HttpContext ctx, ChatAnalysisClient chatClient, AutomationClient automationClient, AgentAIClient agentAIClient, OutboundClient outboundClient, LogReader logReader) =>
+ {
+     if (!ValidateOpsAuth(ctx))
+     {
+@@ -182,6 +197,7 @@ app.MapGet("/ops", async (HttpContext ctx, ChatAnalysisClient chatClient, Automa
+     var chatHealthy = await chatClient.CheckHealthAsync();
+     var autoHealthy = await automationClient.CheckHealthAsync();
+     var agentAIHealthy = await agentAIClient.CheckHealthAsync();
++    var outboundHealthy = await outboundClient.CheckHealthAsync();
+ 
+     var ops = new
+     {
+@@ -192,7 +208,8 @@ app.MapGet("/ops", async (HttpContext ctx, ChatAnalysisClient chatClient, Automa
+             backend = new { status = "ok" },
+             chatAnalysis = new { status = chatHealthy ? "ok" : "unavailable" },
+             automation = new { status = autoHealthy ? "ok" : "unavailable" },
+-            agentAI = new { status = agentAIHealthy ? "ok" : "unavailable" }
++            agentAI = new { status = agentAIHealthy ? "ok" : "unavailable" },
++            outbound = new { status = outboundHealthy ? "ok" : "unavailable" }
+         },
+         info = new
+         {
+@@ -355,7 +372,7 @@ app.MapGet("/ops/search", async (HttpContext ctx, LogReader logReader, string? r
+ // ============================================
+ 
+ // Dashboard: Service health with response times
+-app.MapGet("/api/ops/health", async (HttpContext ctx, ChatAnalysisClient chatClient, AutomationClient automationClient, AgentAIClient agentAIClient) =>
++app.MapGet("/api/ops/health", async (HttpContext ctx, ChatAnalysisClient chatClient, AutomationClient automationClient, AgentAIClient agentAIClient, OutboundClient outboundClient) =>
+ {
+     if (!ValidateOpsAuth(ctx))
+     {
+@@ -372,7 +389,7 @@ app.MapGet("/api/ops/health", async (HttpContext ctx, ChatAnalysisClient chatCli
+         name = ServiceConstants.BackendServiceName,
+         status = "ok",
+         responseTimeMs = 0,
+-        uptimeSeconds = (long?)null, // Not tracked
++        uptimeSeconds = (long?)null,
+         lastCheck = now
+     });
+ 
+@@ -386,7 +403,7 @@ app.MapGet("/api/ops/health", async (HttpContext ctx, ChatAnalysisClient chatCli
+         name = ServiceConstants.ChatAnalysisServiceName,
+         status = chatHealthy ? "ok" : "unavailable",
+         responseTimeMs = chatHealthy ? (int?)sw.ElapsedMilliseconds : null,
+-        uptimeSeconds = (long?)null, // Not tracked
++        uptimeSeconds = (long?)null,
+         lastCheck = now,
+         error = chatHealthy ? null : "Service unreachable"
+     });
+@@ -421,6 +438,21 @@ app.MapGet("/api/ops/health", async (HttpContext ctx, ChatAnalysisClient chatCli
+         error = agentAIHealthy ? null : "Service unreachable"
+     });
+ 
++    // Outbound - check health with timing (GR-1.3)
++    var swOutbound = System.Diagnostics.Stopwatch.StartNew();
++    var outboundHealthy = await outboundClient.CheckHealthAsync();
++    swOutbound.Stop();
++
++    services.Add(new
++    {
++        name = ServiceConstants.OutboundServiceName,
++        status = outboundHealthy ? "ok" : "unavailable",
++        responseTimeMs = outboundHealthy ? (int?)swOutbound.ElapsedMilliseconds : null,
++        uptimeSeconds = (long?)null,
++        lastCheck = now,
++        error = outboundHealthy ? null : "Service unreachable"
++    });
++
+     return Results.Ok(new
+     {
+         timestamp = now,
+@@ -570,6 +602,7 @@ app.MapPost("/api/ops/services/{serviceName}/restart", async (HttpContext ctx, s
+         "Invekto.ChatAnalysis" => "Invekto.Microservice.Chat",
+         "Invekto.Automation" => "InvektoAutomation",
+         "Invekto.AgentAI" => "InvektoAgentAI",
++        "Invekto.Outbound" => "InvektoOutbound",
+         _ => null
+     };
+ 
+@@ -623,7 +656,7 @@ app.MapPost("/api/ops/services/{serviceName}/restart", async (HttpContext ctx, s
+ });
+ 
+ // Dashboard: Test proxy for external services (avoids CORS issues)
+-app.MapGet("/api/ops/test/{serviceName}/{*path}", async (HttpContext ctx, ChatAnalysisClient chatClient, AutomationClient automationClient, AgentAIClient agentAIClient, string serviceName, string? path) =>
++app.MapGet("/api/ops/test/{serviceName}/{*path}", async (HttpContext ctx, ChatAnalysisClient chatClient, AutomationClient automationClient, AgentAIClient agentAIClient, OutboundClient outboundClient, string serviceName, string? path) =>
+ {
+     if (!ValidateOpsAuth(ctx))
+     {
+@@ -680,6 +713,21 @@ app.MapGet("/api/ops/test/{serviceName}/{*path}", async (HttpContext ctx, ChatAn
+             });
+         }
+ 
++        if (serviceName == "outbound")
++        {
++            var endpoint = "/" + (path ?? "health");
++            var result = await outboundClient.TestEndpointAsync(endpoint);
++            sw.Stop();
++
++            return Results.Ok(new
++            {
++                success = result.Success,
++                statusCode = result.StatusCode,
++                durationMs = sw.ElapsedMilliseconds,
++                message = result.Message
++            });
++        }
++
+         return Results.BadRequest(new { success = false, message = "Unknown service" });
+     }
+     catch (Exception ex)
+@@ -905,7 +953,7 @@ app.MapPost("/api/v1/chat/analyze", async (
+ });
+ 
+ // Endpoint discovery - returns all services' endpoints (aggregated)
+-app.MapGet("/api/ops/endpoints", async (HttpContext ctx, ChatAnalysisClient chatClient, AutomationClient automationClient, AgentAIClient agentAIClient) =>
++app.MapGet("/api/ops/endpoints", async (HttpContext ctx, ChatAnalysisClient chatClient, AutomationClient automationClient, AgentAIClient agentAIClient, OutboundClient outboundClient) =>
+ {
+     if (!ValidateOpsAuth(ctx))
+     {
+@@ -929,6 +977,19 @@ app.MapGet("/api/ops/endpoints", async (HttpContext ctx, ChatAnalysisClient chat
+             new() { Method = "POST", Path = "/api/v1/agent-assist/feedback", Description = "Agent feedback proxy (Backend -> AgentAI)", Auth = "Bearer", Category = "API" },
+             // Automation proxy endpoint
+             new() { Method = "POST", Path = "/api/v1/automation/webhook", Description = "Webhook event proxy (Backend -> Automation)", Auth = "Bearer", Category = "API" },
++            // Outbound proxy endpoints (GR-1.3)
++            new() { Method = "POST", Path = "/api/v1/outbound/broadcast/send", Description = "Broadcast send proxy (Backend -> Outbound)", Auth = "Bearer", Category = "API" },
++            new() { Method = "GET", Path = "/api/v1/outbound/broadcast/{broadcastId}/status", Description = "Broadcast status proxy", Auth = "Bearer", Category = "API" },
++            new() { Method = "POST", Path = "/api/v1/outbound/webhook/trigger", Description = "Trigger event proxy", Auth = "Bearer", Category = "API" },
++            new() { Method = "POST", Path = "/api/v1/outbound/webhook/delivery-status", Description = "Delivery status proxy", Auth = "Bearer", Category = "API" },
++            new() { Method = "POST", Path = "/api/v1/outbound/webhook/message", Description = "Incoming message proxy (opt-out)", Auth = "Bearer", Category = "API" },
++            new() { Method = "GET", Path = "/api/v1/outbound/templates", Description = "List templates proxy", Auth = "Bearer", Category = "API" },
++            new() { Method = "POST", Path = "/api/v1/outbound/templates", Description = "Create template proxy", Auth = "Bearer", Category = "API" },
++            new() { Method = "PUT", Path = "/api/v1/outbound/templates/{id}", Description = "Update template proxy", Auth = "Bearer", Category = "API" },
++            new() { Method = "DELETE", Path = "/api/v1/outbound/templates/{id}", Description = "Deactivate template proxy", Auth = "Bearer", Category = "API" },
++            new() { Method = "POST", Path = "/api/v1/outbound/optout", Description = "Add opt-out proxy", Auth = "Bearer", Category = "API" },
++            new() { Method = "DELETE", Path = "/api/v1/outbound/optout/{phone}", Description = "Remove opt-out proxy", Auth = "Bearer", Category = "API" },
++            new() { Method = "GET", Path = "/api/v1/outbound/optout/check/{phone}", Description = "Check opt-out proxy", Auth = "Bearer", Category = "API" },
+ 
+             // Health
+             new() { Method = "GET", Path = "/health", Description = "Health check", Auth = "none", Category = "Health" },
+@@ -963,6 +1024,9 @@ app.MapGet("/api/ops/endpoints", async (HttpContext ctx, ChatAnalysisClient chat
+     // Fetch AgentAI endpoints (internal call)
+     var agentAIEndpoints = await agentAIClient.GetEndpointsAsync();
+ 
++    // Fetch Outbound endpoints (internal call, GR-1.3)
++    var outboundEndpoints = await outboundClient.GetEndpointsAsync();
++
+     var services = new List<EndpointDiscoveryResponse> { backendEndpoints };
+     if (chatEndpoints != null)
+     {
+@@ -976,6 +1040,10 @@ app.MapGet("/api/ops/endpoints", async (HttpContext ctx, ChatAnalysisClient chat
+     {
+         services.Add(agentAIEndpoints);
+     }
++    if (outboundEndpoints != null)
++    {
++        services.Add(outboundEndpoints);
++    }
+ 
+     return Results.Ok(new { services });
+ });
+@@ -1275,6 +1343,115 @@ app.MapPost("/api/v1/automation/webhook", async (HttpContext ctx, AutomationClie
+     return Results.Empty;
+ });
+ 
++// ============================================
++// OUTBOUND PROXY ENDPOINTS (GR-1.3)
++// ============================================
++
++// Generic outbound proxy helper
++async Task<IResult> OutboundProxyPost(HttpContext ctx, OutboundClient obClient, JsonLinesLogger jsonLog, string targetPath)
++{
++    var requestId = ctx.Request.Headers["X-Request-Id"].FirstOrDefault() ?? Guid.NewGuid().ToString("N");
++    var authHeader = ctx.Request.Headers.Authorization.FirstOrDefault();
++
++    string requestBody;
++    using (var reader = new StreamReader(ctx.Request.Body))
++        requestBody = await reader.ReadToEndAsync();
++
++    var sw = System.Diagnostics.Stopwatch.StartNew();
++    var (statusCode, body) = await obClient.ProxyPostAsync(targetPath, requestBody, authHeader, requestId);
++    sw.Stop();
++
++    jsonLog.StepInfo($"Outbound proxy POST {targetPath}: status={statusCode}, time={sw.ElapsedMilliseconds}ms", requestId);
++
++    ctx.Response.StatusCode = statusCode;
++    ctx.Response.ContentType = "application/json";
++    if (body != null) await ctx.Response.WriteAsync(body);
++    return Results.Empty;
++}
++
++async Task<IResult> OutboundProxyGet(HttpContext ctx, OutboundClient obClient, JsonLinesLogger jsonLog, string targetPath)
++{
++    var requestId = ctx.Request.Headers["X-Request-Id"].FirstOrDefault() ?? Guid.NewGuid().ToString("N");
++    var authHeader = ctx.Request.Headers.Authorization.FirstOrDefault();
++
++    var (statusCode, body) = await obClient.ProxyGetAsync(targetPath, authHeader, requestId);
++
++    ctx.Response.StatusCode = statusCode;
++    ctx.Response.ContentType = "application/json";
++    if (body != null) await ctx.Response.WriteAsync(body);
++    return Results.Empty;
++}
++
++async Task<IResult> OutboundProxyPut(HttpContext ctx, OutboundClient obClient, JsonLinesLogger jsonLog, string targetPath)
++{
++    var requestId = ctx.Request.Headers["X-Request-Id"].FirstOrDefault() ?? Guid.NewGuid().ToString("N");
++    var authHeader = ctx.Request.Headers.Authorization.FirstOrDefault();
++
++    string requestBody;
++    using (var reader = new StreamReader(ctx.Request.Body))
++        requestBody = await reader.ReadToEndAsync();
++
++    var (statusCode, body) = await obClient.ProxyPutAsync(targetPath, requestBody, authHeader, requestId);
++
++    ctx.Response.StatusCode = statusCode;
++    ctx.Response.ContentType = "application/json";
++    if (body != null) await ctx.Response.WriteAsync(body);
++    return Results.Empty;
++}
++
++async Task<IResult> OutboundProxyDelete(HttpContext ctx, OutboundClient obClient, JsonLinesLogger jsonLog, string targetPath)
++{
++    var requestId = ctx.Request.Headers["X-Request-Id"].FirstOrDefault() ?? Guid.NewGuid().ToString("N");
++    var authHeader = ctx.Request.Headers.Authorization.FirstOrDefault();
++
++    var (statusCode, body) = await obClient.ProxyDeleteAsync(targetPath, authHeader, requestId);
++
++    ctx.Response.StatusCode = statusCode;
++    ctx.Response.ContentType = "application/json";
++    if (body != null) await ctx.Response.WriteAsync(body);
++    return Results.Empty;
++}
++
++// Broadcast
++app.MapPost("/api/v1/outbound/broadcast/send", async (HttpContext ctx, OutboundClient obClient, JsonLinesLogger jsonLog) =>
++    await OutboundProxyPost(ctx, obClient, jsonLog, "/api/v1/broadcast/send"));
++
++app.MapGet("/api/v1/outbound/broadcast/{broadcastId}/status", async (HttpContext ctx, OutboundClient obClient, JsonLinesLogger jsonLog, string broadcastId) =>
++    await OutboundProxyGet(ctx, obClient, jsonLog, $"/api/v1/broadcast/{broadcastId}/status"));
++
++// Webhooks
++app.MapPost("/api/v1/outbound/webhook/trigger", async (HttpContext ctx, OutboundClient obClient, JsonLinesLogger jsonLog) =>
++    await OutboundProxyPost(ctx, obClient, jsonLog, "/api/v1/webhook/trigger"));
++
++app.MapPost("/api/v1/outbound/webhook/delivery-status", async (HttpContext ctx, OutboundClient obClient, JsonLinesLogger jsonLog) =>
++    await OutboundProxyPost(ctx, obClient, jsonLog, "/api/v1/webhook/delivery-status"));
++
++app.MapPost("/api/v1/outbound/webhook/message", async (HttpContext ctx, OutboundClient obClient, JsonLinesLogger jsonLog) =>
++    await OutboundProxyPost(ctx, obClient, jsonLog, "/api/v1/webhook/message"));
++
++// Templates
++app.MapGet("/api/v1/outbound/templates", async (HttpContext ctx, OutboundClient obClient, JsonLinesLogger jsonLog) =>
++    await OutboundProxyGet(ctx, obClient, jsonLog, "/api/v1/templates"));
++
++app.MapPost("/api/v1/outbound/templates", async (HttpContext ctx, OutboundClient obClient, JsonLinesLogger jsonLog) =>
++    await OutboundProxyPost(ctx, obClient, jsonLog, "/api/v1/templates"));
++
++app.MapPut("/api/v1/outbound/templates/{id:int}", async (HttpContext ctx, OutboundClient obClient, JsonLinesLogger jsonLog, int id) =>
++    await OutboundProxyPut(ctx, obClient, jsonLog, $"/api/v1/templates/{id}"));
++
++app.MapDelete("/api/v1/outbound/templates/{id:int}", async (HttpContext ctx, OutboundClient obClient, JsonLinesLogger jsonLog, int id) =>
++    await OutboundProxyDelete(ctx, obClient, jsonLog, $"/api/v1/templates/{id}"));
++
++// Opt-out
++app.MapPost("/api/v1/outbound/optout", async (HttpContext ctx, OutboundClient obClient, JsonLinesLogger jsonLog) =>
++    await OutboundProxyPost(ctx, obClient, jsonLog, "/api/v1/optout"));
++
++app.MapDelete("/api/v1/outbound/optout/{phone}", async (HttpContext ctx, OutboundClient obClient, JsonLinesLogger jsonLog, string phone) =>
++    await OutboundProxyDelete(ctx, obClient, jsonLog, $"/api/v1/optout/{phone}"));
++
++app.MapGet("/api/v1/outbound/optout/check/{phone}", async (HttpContext ctx, OutboundClient obClient, JsonLinesLogger jsonLog, string phone) =>
++    await OutboundProxyGet(ctx, obClient, jsonLog, $"/api/v1/optout/check/{phone}"));
++
+ // SPA fallback - serve index.html for non-API routes (Dashboard routing)
+ app.MapFallbackToFile("index.html");
+ 
+diff --git a/src/Invekto.Backend/Services/OutboundClient.cs b/src/Invekto.Backend/Services/OutboundClient.cs
+new file mode 100644
+index 0000000..db1af9b
+--- /dev/null
++++ b/src/Invekto.Backend/Services/OutboundClient.cs
+@@ -0,0 +1,152 @@
++using System.Text;
++using System.Text.Json;
++using Invekto.Shared.DTOs;
++
++namespace Invekto.Backend.Services;
++
++/// <summary>
++/// HTTP client for Outbound microservice (Port 7107).
++/// Health checks, endpoint discovery, and generic HTTP proxy for all Outbound endpoints.
++/// GR-1.3: Broadcast, trigger, template, opt-out proxy.
++/// </summary>
++public sealed class OutboundClient
++{
++    private readonly HttpClient _httpClient;
++    private readonly ILogger<OutboundClient> _logger;
++
++    public OutboundClient(HttpClient httpClient, ILogger<OutboundClient> logger)
++    {
++        _httpClient = httpClient;
++        _logger = logger;
++    }
++
++    public async Task<bool> CheckHealthAsync(CancellationToken ct = default)
++    {
++        try
++        {
++            var response = await _httpClient.GetAsync("/health", ct);
++            return response.IsSuccessStatusCode;
++        }
++        catch (Exception ex)
++        {
++            _logger.LogWarning(ex, "Outbound health check failed");
++            return false;
++        }
++    }
++
++    public async Task<EndpointDiscoveryResponse?> GetEndpointsAsync(CancellationToken ct = default)
++    {
++        try
++        {
++            var response = await _httpClient.GetAsync("/api/ops/endpoints", ct);
++            if (response.IsSuccessStatusCode)
++            {
++                return await response.Content.ReadFromJsonAsync<EndpointDiscoveryResponse>(ct);
++            }
++            return null;
++        }
++        catch (Exception ex)
++        {
++            _logger.LogWarning(ex, "Outbound endpoint discovery failed");
++            return null;
++        }
++    }
++
++    public async Task<TestEndpointResult> TestEndpointAsync(string endpoint, CancellationToken ct = default)
++    {
++        try
++        {
++            var response = await _httpClient.GetAsync(endpoint, ct);
++            return new TestEndpointResult
++            {
++                Success = response.IsSuccessStatusCode,
++                StatusCode = (int)response.StatusCode,
++                Message = response.IsSuccessStatusCode ? "OK" : $"HTTP {(int)response.StatusCode}"
++            };
++        }
++        catch (TaskCanceledException ex)
++        {
++            _logger.LogWarning(ex, "Outbound endpoint test timeout: {Endpoint}", endpoint);
++            return new TestEndpointResult { Success = false, StatusCode = 0, Message = "Timeout" };
++        }
++        catch (HttpRequestException ex)
++        {
++            _logger.LogWarning(ex, "Outbound endpoint test failed: {Endpoint}", endpoint);
++            return new TestEndpointResult { Success = false, StatusCode = 0, Message = ex.Message };
++        }
++    }
++
++    /// <summary>
++    /// Generic POST proxy - forwards body + auth + request-id to Outbound.
++    /// </summary>
++    public async Task<(int StatusCode, string? Body)> ProxyPostAsync(
++        string path, string requestBody, string? authHeader, string? requestId,
++        CancellationToken ct = default)
++    {
++        return await ProxyRequestAsync(HttpMethod.Post, path, requestBody, authHeader, requestId, ct);
++    }
++
++    /// <summary>
++    /// Generic GET proxy - forwards auth + request-id to Outbound.
++    /// </summary>
++    public async Task<(int StatusCode, string? Body)> ProxyGetAsync(
++        string path, string? authHeader, string? requestId,
++        CancellationToken ct = default)
++    {
++        return await ProxyRequestAsync(HttpMethod.Get, path, null, authHeader, requestId, ct);
++    }
++
++    /// <summary>
++    /// Generic PUT proxy - forwards body + auth + request-id to Outbound.
++    /// </summary>
++    public async Task<(int StatusCode, string? Body)> ProxyPutAsync(
++        string path, string requestBody, string? authHeader, string? requestId,
++        CancellationToken ct = default)
++    {
++        return await ProxyRequestAsync(HttpMethod.Put, path, requestBody, authHeader, requestId, ct);
++    }
++
++    /// <summary>
++    /// Generic DELETE proxy - forwards auth + request-id to Outbound.
++    /// </summary>
++    public async Task<(int StatusCode, string? Body)> ProxyDeleteAsync(
++        string path, string? authHeader, string? requestId,
++        CancellationToken ct = default)
++    {
++        return await ProxyRequestAsync(HttpMethod.Delete, path, null, authHeader, requestId, ct);
++    }
++
++    private async Task<(int StatusCode, string? Body)> ProxyRequestAsync(
++        HttpMethod method, string path, string? requestBody, string? authHeader, string? requestId,
++        CancellationToken ct)
++    {
++        try
++        {
++            using var request = new HttpRequestMessage(method, path);
++
++            if (requestBody != null)
++                request.Content = new StringContent(requestBody, Encoding.UTF8, "application/json");
++
++            if (!string.IsNullOrEmpty(authHeader))
++                request.Headers.TryAddWithoutValidation("Authorization", authHeader);
++
++            if (!string.IsNullOrEmpty(requestId))
++                request.Headers.TryAddWithoutValidation("X-Request-Id", requestId);
++
++            using var response = await _httpClient.SendAsync(request, ct);
++            var body = await response.Content.ReadAsStringAsync(ct);
++
++            return ((int)response.StatusCode, body);
++        }
++        catch (TaskCanceledException)
++        {
++            _logger.LogWarning("Outbound proxy timeout: {Path}", path);
++            return (504, JsonSerializer.Serialize(new { error_code = "INV-BE-002", message = "Outbound service timeout" }));
++        }
++        catch (Exception ex)
++        {
++            _logger.LogWarning(ex, "Outbound proxy failed: {Path}", path);
++            return (502, JsonSerializer.Serialize(new { error_code = "INV-BE-001", message = $"Outbound service unavailable: {ex.Message}" }));
++        }
++    }
++}
+diff --git a/src/Invekto.Backend/appsettings.json b/src/Invekto.Backend/appsettings.json
+index 7fe5bee..3462235 100644
+--- a/src/Invekto.Backend/appsettings.json
++++ b/src/Invekto.Backend/appsettings.json
+@@ -25,6 +25,11 @@
+       "Url": "http://localhost:7105",
+       "LogPath": "../Invekto.AgentAI/logs",
+       "SuggestTimeoutMs": 15000
++    },
++    "Outbound": {
++      "Url": "http://localhost:7107",
++      "LogPath": "../Invekto.Outbound/logs",
++      "TimeoutMs": 10000
+     }
+   },
+   "Jwt": {
+diff --git a/src/Invekto.Outbound/Data/OutboundRepository.cs b/src/Invekto.Outbound/Data/OutboundRepository.cs
+new file mode 100644
+index 0000000..3952663
+--- /dev/null
++++ b/src/Invekto.Outbound/Data/OutboundRepository.cs
+@@ -0,0 +1,590 @@
++using System.Text.Json;
++using Invekto.Shared.Data;
++using Invekto.Shared.DTOs.Outbound;
++using Invekto.Shared.Logging;
++using Npgsql;
++
++namespace Invekto.Outbound.Data;
++
++public sealed class OutboundRepository
++{
++    private readonly PostgresConnectionFactory _db;
++    private readonly JsonLinesLogger _logger;
++
++    public OutboundRepository(PostgresConnectionFactory db, JsonLinesLogger logger)
++    {
++        _db = db;
++        _logger = logger;
++    }
++
++    // ================================================================
++    // Templates
++    // ================================================================
++
++    public async Task<List<TemplateDto>> GetActiveTemplatesAsync(
++        int tenantId, CancellationToken ct = default)
++    {
++        const string sql = @"
++            SELECT id, name, trigger_event, message_template, variables_json,
++                   is_active, created_at, updated_at
++            FROM outbound_templates
++            WHERE tenant_id = @tid AND is_active = TRUE
++            ORDER BY created_at DESC";
++
++        await using var conn = await _db.OpenConnectionAsync(ct);
++        await using var cmd = new NpgsqlCommand(sql, conn);
++        cmd.Parameters.AddWithValue("tid", tenantId);
++
++        var templates = new List<TemplateDto>();
++        await using var reader = await cmd.ExecuteReaderAsync(ct);
++        while (await reader.ReadAsync(ct))
++        {
++            templates.Add(ReadTemplateDto(reader));
++        }
++        return templates;
++    }
++
++    public async Task<TemplateDto?> GetTemplateByIdAsync(
++        int tenantId, int templateId, CancellationToken ct = default)
++    {
++        const string sql = @"
++            SELECT id, name, trigger_event, message_template, variables_json,
++                   is_active, created_at, updated_at
++            FROM outbound_templates
++            WHERE tenant_id = @tid AND id = @id AND is_active = TRUE";
++
++        await using var conn = await _db.OpenConnectionAsync(ct);
++        await using var cmd = new NpgsqlCommand(sql, conn);
++        cmd.Parameters.AddWithValue("tid", tenantId);
++        cmd.Parameters.AddWithValue("id", templateId);
++
++        await using var reader = await cmd.ExecuteReaderAsync(ct);
++        if (await reader.ReadAsync(ct))
++            return ReadTemplateDto(reader);
++        return null;
++    }
++
++    public async Task<TemplateDto?> GetTriggerTemplateAsync(
++        int tenantId, string triggerEvent, CancellationToken ct = default)
++    {
++        const string sql = @"
++            SELECT id, name, trigger_event, message_template, variables_json,
++                   is_active, created_at, updated_at
++            FROM outbound_templates
++            WHERE tenant_id = @tid AND trigger_event = @evt AND is_active = TRUE
++            ORDER BY updated_at DESC
++            LIMIT 1";
++
++        await using var conn = await _db.OpenConnectionAsync(ct);
++        await using var cmd = new NpgsqlCommand(sql, conn);
++        cmd.Parameters.AddWithValue("tid", tenantId);
++        cmd.Parameters.AddWithValue("evt", triggerEvent);
++
++        await using var reader = await cmd.ExecuteReaderAsync(ct);
++        if (await reader.ReadAsync(ct))
++            return ReadTemplateDto(reader);
++        return null;
++    }
++
++    public async Task<int> CreateTemplateAsync(
++        int tenantId, string name, string triggerEvent,
++        string messageTemplate, Dictionary<string, string>? variablesJson,
++        CancellationToken ct = default)
++    {
++        const string sql = @"
++            INSERT INTO outbound_templates
++                (tenant_id, name, trigger_event, message_template, variables_json)
++            VALUES (@tid, @name, @evt, @tpl, @vars::jsonb)
++            RETURNING id";
++
++        await using var conn = await _db.OpenConnectionAsync(ct);
++        await using var cmd = new NpgsqlCommand(sql, conn);
++        cmd.Parameters.AddWithValue("tid", tenantId);
++        cmd.Parameters.AddWithValue("name", name);
++        cmd.Parameters.AddWithValue("evt", triggerEvent);
++        cmd.Parameters.AddWithValue("tpl", messageTemplate);
++        cmd.Parameters.AddWithValue("vars",
++            variablesJson != null ? (object)JsonSerializer.Serialize(variablesJson) : DBNull.Value);
++
++        var id = await cmd.ExecuteScalarAsync(ct);
++        return Convert.ToInt32(id);
++    }
++
++    public async Task<bool> UpdateTemplateAsync(
++        int tenantId, int templateId, TemplateUpdateRequest req,
++        CancellationToken ct = default)
++    {
++        var setClauses = new List<string>();
++        var parameters = new List<NpgsqlParameter>
++        {
++            new("tid", tenantId),
++            new("id", templateId)
++        };
++
++        if (req.Name != null)
++        {
++            setClauses.Add("name = @name");
++            parameters.Add(new NpgsqlParameter("name", req.Name));
++        }
++        if (req.TriggerEvent != null)
++        {
++            setClauses.Add("trigger_event = @evt");
++            parameters.Add(new NpgsqlParameter("evt", req.TriggerEvent));
++        }
++        if (req.MessageTemplate != null)
++        {
++            setClauses.Add("message_template = @tpl");
++            parameters.Add(new NpgsqlParameter("tpl", req.MessageTemplate));
++        }
++        if (req.VariablesJson != null)
++        {
++            setClauses.Add("variables_json = @vars::jsonb");
++            parameters.Add(new NpgsqlParameter("vars", JsonSerializer.Serialize(req.VariablesJson)));
++        }
++
++        if (setClauses.Count == 0) return false;
++        setClauses.Add("updated_at = NOW()");
++
++        var sql = $"UPDATE outbound_templates SET {string.Join(", ", setClauses)} WHERE tenant_id = @tid AND id = @id AND is_active = TRUE";
++
++        await using var conn = await _db.OpenConnectionAsync(ct);
++        await using var cmd = new NpgsqlCommand(sql, conn);
++        cmd.Parameters.AddRange(parameters.ToArray());
++
++        var rows = await cmd.ExecuteNonQueryAsync(ct);
++        return rows > 0;
++    }
++
++    public async Task<bool> DeactivateTemplateAsync(
++        int tenantId, int templateId, CancellationToken ct = default)
++    {
++        const string sql = @"
++            UPDATE outbound_templates
++            SET is_active = FALSE, updated_at = NOW()
++            WHERE tenant_id = @tid AND id = @id AND is_active = TRUE";
++
++        await using var conn = await _db.OpenConnectionAsync(ct);
++        await using var cmd = new NpgsqlCommand(sql, conn);
++        cmd.Parameters.AddWithValue("tid", tenantId);
++        cmd.Parameters.AddWithValue("id", templateId);
++
++        var rows = await cmd.ExecuteNonQueryAsync(ct);
++        return rows > 0;
++    }
++
++    // ================================================================
++    // Broadcasts
++    // ================================================================
++
++    public async Task<Guid> CreateBroadcastAsync(
++        int tenantId, int templateId, int totalRecipients, int queued,
++        DateTime? scheduledAt, CancellationToken ct = default)
++    {
++        const string sql = @"
++            INSERT INTO outbound_broadcasts
++                (tenant_id, template_id, total_recipients, queued, status, scheduled_at)
++            VALUES (@tid, @tmpl, @total, @queued, 'queued', @sched)
++            RETURNING id";
++
++        await using var conn = await _db.OpenConnectionAsync(ct);
++        await using var cmd = new NpgsqlCommand(sql, conn);
++        cmd.Parameters.AddWithValue("tid", tenantId);
++        cmd.Parameters.AddWithValue("tmpl", templateId);
++        cmd.Parameters.AddWithValue("total", totalRecipients);
++        cmd.Parameters.AddWithValue("queued", queued);
++        cmd.Parameters.AddWithValue("sched", scheduledAt.HasValue ? (object)scheduledAt.Value : DBNull.Value);
++
++        var id = await cmd.ExecuteScalarAsync(ct);
++        return (Guid)id!;
++    }
++
++    public async Task<BroadcastStatusResponse?> GetBroadcastStatusAsync(
++        int tenantId, Guid broadcastId, CancellationToken ct = default)
++    {
++        const string sql = @"
++            SELECT id, status, total_recipients, queued, sent, delivered, read, failed,
++                   created_at, started_at, completed_at
++            FROM outbound_broadcasts
++            WHERE tenant_id = @tid AND id = @bid";
++
++        await using var conn = await _db.OpenConnectionAsync(ct);
++        await using var cmd = new NpgsqlCommand(sql, conn);
++        cmd.Parameters.AddWithValue("tid", tenantId);
++        cmd.Parameters.AddWithValue("bid", broadcastId);
++
++        await using var reader = await cmd.ExecuteReaderAsync(ct);
++        if (!await reader.ReadAsync(ct)) return null;
++
++        return new BroadcastStatusResponse
++        {
++            BroadcastId = reader.GetGuid(0),
++            Status = reader.GetString(1),
++            TotalRecipients = reader.GetInt32(2),
++            Queued = reader.GetInt32(3),
++            Sent = reader.GetInt32(4),
++            Delivered = reader.GetInt32(5),
++            Read = reader.GetInt32(6),
++            Failed = reader.GetInt32(7),
++            CreatedAt = reader.GetDateTime(8),
++            StartedAt = reader.IsDBNull(9) ? null : reader.GetDateTime(9),
++            CompletedAt = reader.IsDBNull(10) ? null : reader.GetDateTime(10)
++        };
++    }
++
++    public async Task UpdateBroadcastStatusAsync(
++        Guid broadcastId, string status, CancellationToken ct = default)
++    {
++        var extraSet = status switch
++        {
++            "processing" => ", started_at = COALESCE(started_at, NOW())",
++            "completed" or "failed" => ", completed_at = NOW()",
++            _ => ""
++        };
++
++        var sql = $"UPDATE outbound_broadcasts SET status = @st{extraSet} WHERE id = @bid";
++
++        await using var conn = await _db.OpenConnectionAsync(ct);
++        await using var cmd = new NpgsqlCommand(sql, conn);
++        cmd.Parameters.AddWithValue("st", status);
++        cmd.Parameters.AddWithValue("bid", broadcastId);
++
++        await cmd.ExecuteNonQueryAsync(ct);
++    }
++
++    public async Task IncrementBroadcastCounterAsync(
++        Guid broadcastId, string counterColumn, CancellationToken ct = default)
++    {
++        // Whitelist valid columns to prevent SQL injection
++        if (counterColumn is not ("sent" or "delivered" or "read" or "failed"))
++            throw new ArgumentException($"Invalid counter column: {counterColumn}");
++
++        // Decrement queued when message leaves queue
++        var queuedDecrement = counterColumn == "sent" || counterColumn == "failed"
++            ? ", queued = GREATEST(queued - 1, 0)" : "";
++
++        var sql = $"UPDATE outbound_broadcasts SET {counterColumn} = {counterColumn} + 1{queuedDecrement} WHERE id = @bid";
++
++        await using var conn = await _db.OpenConnectionAsync(ct);
++        await using var cmd = new NpgsqlCommand(sql, conn);
++        cmd.Parameters.AddWithValue("bid", broadcastId);
++
++        await cmd.ExecuteNonQueryAsync(ct);
++    }
++
++    /// <summary>Check if all messages in a broadcast are processed (no more queued/sending).</summary>
++    public async Task<bool> IsBroadcastCompleteAsync(
++        Guid broadcastId, CancellationToken ct = default)
++    {
++        const string sql = @"
++            SELECT COUNT(*) FROM outbound_messages
++            WHERE broadcast_id = @bid AND status IN ('queued', 'sending')";
++
++        await using var conn = await _db.OpenConnectionAsync(ct);
++        await using var cmd = new NpgsqlCommand(sql, conn);
++        cmd.Parameters.AddWithValue("bid", broadcastId);
++
++        var count = (long)(await cmd.ExecuteScalarAsync(ct))!;
++        return count == 0;
++    }
++
++    // ================================================================
++    // Messages
++    // ================================================================
++
++    public async Task<long> InsertMessageAsync(
++        int tenantId, Guid? broadcastId, int? templateId,
++        string recipientPhone, string messageText,
++        CancellationToken ct = default)
++    {
++        const string sql = @"
++            INSERT INTO outbound_messages
++                (tenant_id, broadcast_id, template_id, recipient_phone, message_text, status)
++            VALUES (@tid, @bid, @tmpl, @phone, @msg, 'queued')
++            RETURNING id";
++
++        await using var conn = await _db.OpenConnectionAsync(ct);
++        await using var cmd = new NpgsqlCommand(sql, conn);
++        cmd.Parameters.AddWithValue("tid", tenantId);
++        cmd.Parameters.AddWithValue("bid", broadcastId.HasValue ? (object)broadcastId.Value : DBNull.Value);
++        cmd.Parameters.AddWithValue("tmpl", templateId.HasValue ? (object)templateId.Value : DBNull.Value);
++        cmd.Parameters.AddWithValue("phone", recipientPhone);
++        cmd.Parameters.AddWithValue("msg", messageText);
++
++        var id = await cmd.ExecuteScalarAsync(ct);
++        return Convert.ToInt64(id);
++    }
++
++    /// <summary>Dequeue next batch of messages to send, respecting rate limit.</summary>
++    public async Task<List<QueuedMessage>> DequeueMessagesAsync(
++        int batchSize, CancellationToken ct = default)
++    {
++        const string sql = @"
++            UPDATE outbound_messages
++            SET status = 'sending'
++            WHERE id IN (
++                SELECT id FROM outbound_messages
++                WHERE status = 'queued'
++                ORDER BY created_at
++                LIMIT @batch
++                FOR UPDATE SKIP LOCKED
++            )
++            RETURNING id, tenant_id, broadcast_id, template_id,
++                      recipient_phone, message_text";
++
++        await using var conn = await _db.OpenConnectionAsync(ct);
++        await using var cmd = new NpgsqlCommand(sql, conn);
++        cmd.Parameters.AddWithValue("batch", batchSize);
++
++        var messages = new List<QueuedMessage>();
++        await using var reader = await cmd.ExecuteReaderAsync(ct);
++        while (await reader.ReadAsync(ct))
++        {
++            messages.Add(new QueuedMessage
++            {
++                Id = reader.GetInt64(0),
++                TenantId = reader.GetInt32(1),
++                BroadcastId = reader.IsDBNull(2) ? null : reader.GetGuid(2),
++                TemplateId = reader.IsDBNull(3) ? null : reader.GetInt32(3),
++                RecipientPhone = reader.GetString(4),
++                MessageText = reader.GetString(5)
++            });
++        }
++        return messages;
++    }
++
++    public async Task UpdateMessageStatusAsync(
++        long messageId, string status, string? externalMessageId = null,
++        string? failedReason = null, CancellationToken ct = default)
++    {
++        var timestampCol = status switch
++        {
++            "sent" => ", sent_at = NOW()",
++            "delivered" => ", delivered_at = NOW()",
++            "read" => ", read_at = NOW()",
++            _ => ""
++        };
++
++        var extIdSet = externalMessageId != null ? ", external_message_id = @eid" : "";
++        var failSet = failedReason != null ? ", failed_reason = @fail" : "";
++
++        var sql = $"UPDATE outbound_messages SET status = @st{timestampCol}{extIdSet}{failSet} WHERE id = @mid";
++
++        await using var conn = await _db.OpenConnectionAsync(ct);
++        await using var cmd = new NpgsqlCommand(sql, conn);
++        cmd.Parameters.AddWithValue("st", status);
++        cmd.Parameters.AddWithValue("mid", messageId);
++
++        if (externalMessageId != null)
++            cmd.Parameters.AddWithValue("eid", externalMessageId);
++        if (failedReason != null)
++            cmd.Parameters.AddWithValue("fail", failedReason);
++
++        await cmd.ExecuteNonQueryAsync(ct);
++    }
++
++    /// <summary>Find message by external_message_id (from WapCRM/WhatsApp).</summary>
++    public async Task<(long messageId, Guid? broadcastId, int tenantId)?> FindMessageByExternalIdAsync(
++        string externalMessageId, CancellationToken ct = default)
++    {
++        const string sql = @"
++            SELECT id, broadcast_id, tenant_id
++            FROM outbound_messages
++            WHERE external_message_id = @eid
++            LIMIT 1";
++
++        await using var conn = await _db.OpenConnectionAsync(ct);
++        await using var cmd = new NpgsqlCommand(sql, conn);
++        cmd.Parameters.AddWithValue("eid", externalMessageId);
++
++        await using var reader = await cmd.ExecuteReaderAsync(ct);
++        if (await reader.ReadAsync(ct))
++        {
++            return (
++                reader.GetInt64(0),
++                reader.IsDBNull(1) ? null : reader.GetGuid(1),
++                reader.GetInt32(2)
++            );
++        }
++        return null;
++    }
++
++    // ================================================================
++    // Opt-outs
++    // ================================================================
++
++    public async Task<bool> IsOptedOutAsync(
++        int tenantId, string phone, CancellationToken ct = default)
++    {
++        const string sql = @"
++            SELECT 1 FROM outbound_optouts
++            WHERE tenant_id = @tid AND phone = @phone
++            LIMIT 1";
++
++        await using var conn = await _db.OpenConnectionAsync(ct);
++        await using var cmd = new NpgsqlCommand(sql, conn);
++        cmd.Parameters.AddWithValue("tid", tenantId);
++        cmd.Parameters.AddWithValue("phone", phone);
++
++        var result = await cmd.ExecuteScalarAsync(ct);
++        return result != null;
++    }
++
++    public async Task<DateTime?> GetOptOutDateAsync(
++        int tenantId, string phone, CancellationToken ct = default)
++    {
++        const string sql = @"
++            SELECT created_at FROM outbound_optouts
++            WHERE tenant_id = @tid AND phone = @phone
++            LIMIT 1";
++
++        await using var conn = await _db.OpenConnectionAsync(ct);
++        await using var cmd = new NpgsqlCommand(sql, conn);
++        cmd.Parameters.AddWithValue("tid", tenantId);
++        cmd.Parameters.AddWithValue("phone", phone);
++
++        var result = await cmd.ExecuteScalarAsync(ct);
++        return result as DateTime?;
++    }
++
++    public async Task<bool> AddOptOutAsync(
++        int tenantId, string phone, string? reason,
++        CancellationToken ct = default)
++    {
++        const string sql = @"
++            INSERT INTO outbound_optouts (tenant_id, phone, reason)
++            VALUES (@tid, @phone, @reason)
++            ON CONFLICT (tenant_id, phone) DO NOTHING
++            RETURNING id";
++
++        await using var conn = await _db.OpenConnectionAsync(ct);
++        await using var cmd = new NpgsqlCommand(sql, conn);
++        cmd.Parameters.AddWithValue("tid", tenantId);
++        cmd.Parameters.AddWithValue("phone", phone);
++        cmd.Parameters.AddWithValue("reason", (object?)reason ?? DBNull.Value);
++
++        var id = await cmd.ExecuteScalarAsync(ct);
++        return id != null;
++    }
++
++    public async Task<bool> RemoveOptOutAsync(
++        int tenantId, string phone, CancellationToken ct = default)
++    {
++        const string sql = @"
++            DELETE FROM outbound_optouts
++            WHERE tenant_id = @tid AND phone = @phone";
++
++        await using var conn = await _db.OpenConnectionAsync(ct);
++        await using var cmd = new NpgsqlCommand(sql, conn);
++        cmd.Parameters.AddWithValue("tid", tenantId);
++        cmd.Parameters.AddWithValue("phone", phone);
++
++        var rows = await cmd.ExecuteNonQueryAsync(ct);
++        return rows > 0;
++    }
++
++    // ================================================================
++    // Helpers
++    // ================================================================
++
++    /// <summary>Batch check which phones are opted out for a tenant.</summary>
++    public async Task<HashSet<string>> BatchCheckOptOutsAsync(
++        int tenantId, List<string> phones, CancellationToken ct = default)
++    {
++        if (phones.Count == 0) return new HashSet<string>();
++
++        await using var conn = await _db.OpenConnectionAsync(ct);
++        await using var cmd = new NpgsqlCommand(
++            "SELECT phone FROM outbound_optouts WHERE tenant_id = @tid AND phone = ANY(@phones)", conn);
++        cmd.Parameters.AddWithValue("tid", tenantId);
++        cmd.Parameters.AddWithValue("phones", phones.ToArray());
++
++        var optedOut = new HashSet<string>(StringComparer.OrdinalIgnoreCase);
++        await using var reader = await cmd.ExecuteReaderAsync(ct);
++        while (await reader.ReadAsync(ct))
++            optedOut.Add(reader.GetString(0));
++        return optedOut;
++    }
++
++    /// <summary>Batch insert messages in a single multi-row INSERT.</summary>
++    public async Task BatchInsertMessagesAsync(
++        int tenantId, Guid broadcastId, int templateId,
++        List<(string phone, string text)> messages,
++        CancellationToken ct = default)
++    {
++        if (messages.Count == 0) return;
++
++        await using var conn = await _db.OpenConnectionAsync(ct);
++
++        // Build multi-row VALUES clause
++        var valueClauses = new List<string>();
++        await using var cmd = new NpgsqlCommand();
++        cmd.Connection = conn;
++
++        for (var i = 0; i < messages.Count; i++)
++        {
++            valueClauses.Add($"(@tid, @bid, @tmpl, @phone{i}, @msg{i}, 'queued')");
++            cmd.Parameters.AddWithValue($"phone{i}", messages[i].phone);
++            cmd.Parameters.AddWithValue($"msg{i}", messages[i].text);
++        }
++
++        cmd.Parameters.AddWithValue("tid", tenantId);
++        cmd.Parameters.AddWithValue("bid", broadcastId);
++        cmd.Parameters.AddWithValue("tmpl", templateId);
++
++        cmd.CommandText = $@"
++            INSERT INTO outbound_messages
++                (tenant_id, broadcast_id, template_id, recipient_phone, message_text, status)
++            VALUES {string.Join(",\n                   ", valueClauses)}";
++
++        await cmd.ExecuteNonQueryAsync(ct);
++    }
++
++    /// <summary>Reset stale 'sending' messages back to 'queued' on service shutdown.</summary>
++    public async Task ResetSendingMessagesAsync(CancellationToken ct = default)
++    {
++        const string sql = "UPDATE outbound_messages SET status = 'queued' WHERE status = 'sending'";
++
++        await using var conn = await _db.OpenConnectionAsync(ct);
++        await using var cmd = new NpgsqlCommand(sql, conn);
++        var rows = await cmd.ExecuteNonQueryAsync(ct);
++        if (rows > 0)
++            _logger.SystemWarn($"Reset {rows} stale 'sending' messages back to 'queued' on shutdown");
++    }
++
++    private TemplateDto ReadTemplateDto(NpgsqlDataReader reader)
++    {
++        var variablesStr = reader.IsDBNull(4) ? null : reader.GetString(4);
++        Dictionary<string, string>? variables = null;
++        if (variablesStr != null)
++        {
++            try { variables = JsonSerializer.Deserialize<Dictionary<string, string>>(variablesStr); }
++            catch (JsonException ex)
++            {
++                var templateId = reader.GetInt32(0);
++                _logger.SystemWarn($"Malformed variables_json for template {templateId}: {ex.Message}");
++            }
++        }
++
++        return new TemplateDto
++        {
++            Id = reader.GetInt32(0),
++            Name = reader.GetString(1),
++            TriggerEvent = reader.GetString(2),
++            MessageTemplate = reader.GetString(3),
++            VariablesJson = variables,
++            IsActive = reader.GetBoolean(5),
++            CreatedAt = reader.GetDateTime(6),
++            UpdatedAt = reader.GetDateTime(7)
++        };
++    }
++}
++
++public sealed class QueuedMessage
++{
++    public long Id { get; set; }
++    public int TenantId { get; set; }
++    public Guid? BroadcastId { get; set; }
++    public int? TemplateId { get; set; }
++    public string RecipientPhone { get; set; } = "";
++    public string MessageText { get; set; } = "";
++}
+diff --git a/src/Invekto.Outbound/Invekto.Outbound.csproj b/src/Invekto.Outbound/Invekto.Outbound.csproj
+new file mode 100644
+index 0000000..263b43f
+--- /dev/null
++++ b/src/Invekto.Outbound/Invekto.Outbound.csproj
+@@ -0,0 +1,16 @@
++<Project Sdk="Microsoft.NET.Sdk.Web">
++  <PropertyGroup>
++    <TargetFramework>net8.0</TargetFramework>
++    <Nullable>enable</Nullable>
++    <ImplicitUsings>enable</ImplicitUsings>
++    <RootNamespace>Invekto.Outbound</RootNamespace>
++  </PropertyGroup>
++
++  <ItemGroup>
++    <PackageReference Include="Microsoft.Extensions.Hosting.WindowsServices" Version="8.0.1" />
++  </ItemGroup>
++
++  <ItemGroup>
++    <ProjectReference Include="..\Invekto.Shared\Invekto.Shared.csproj" />
++  </ItemGroup>
++</Project>
+diff --git a/src/Invekto.Outbound/Middleware/JwtAuthMiddleware.cs b/src/Invekto.Outbound/Middleware/JwtAuthMiddleware.cs
+new file mode 100644
+index 0000000..c5b3b4a
+--- /dev/null
++++ b/src/Invekto.Outbound/Middleware/JwtAuthMiddleware.cs
+@@ -0,0 +1,105 @@
++using Invekto.Shared.Auth;
++using Invekto.Shared.Constants;
++using Invekto.Shared.DTOs;
++using Invekto.Shared.Logging;
++
++namespace Invekto.Outbound.Middleware;
++
++public sealed class JwtAuthMiddleware
++{
++    private readonly RequestDelegate _next;
++    private readonly JwtValidator _jwtValidator;
++    private readonly JsonLinesLogger _logger;
++    private readonly HashSet<string> _authRequiredPrefixes;
++
++    public JwtAuthMiddleware(
++        RequestDelegate next,
++        JwtValidator jwtValidator,
++        JsonLinesLogger logger,
++        IEnumerable<string> authRequiredPrefixes)
++    {
++        _next = next;
++        _jwtValidator = jwtValidator;
++        _logger = logger;
++        _authRequiredPrefixes = new HashSet<string>(authRequiredPrefixes, StringComparer.OrdinalIgnoreCase);
++    }
++
++    public async Task InvokeAsync(HttpContext context)
++    {
++        var path = context.Request.Path.Value ?? "";
++
++        if (!RequiresAuth(path))
++        {
++            await _next(context);
++            return;
++        }
++
++        var authHeader = context.Request.Headers.Authorization.FirstOrDefault();
++        if (string.IsNullOrEmpty(authHeader) || !authHeader.StartsWith("Bearer ", StringComparison.OrdinalIgnoreCase))
++        {
++            _logger.SystemWarn($"[{ErrorCodes.AuthUnauthorized}] Missing or invalid Authorization header: path={path}");
++            context.Response.StatusCode = 401;
++            await context.Response.WriteAsJsonAsync(
++                ErrorResponse.Create(ErrorCodes.AuthUnauthorized, "Bearer token required", "-"));
++            return;
++        }
++
++        var token = authHeader["Bearer ".Length..].Trim();
++        var (tenantContext, error) = _jwtValidator.ValidateToken(token);
++
++        if (tenantContext == null)
++        {
++            var errorCode = error?.Contains("expired", StringComparison.OrdinalIgnoreCase) == true
++                ? ErrorCodes.AuthTokenExpired
++                : ErrorCodes.AuthTokenInvalid;
++
++            _logger.SystemWarn($"[{errorCode}] JWT validation failed: path={path}, error={error}");
++            context.Response.StatusCode = 401;
++            await context.Response.WriteAsJsonAsync(
++                ErrorResponse.Create(errorCode, error ?? "Token validation failed", "-"));
++            return;
++        }
++
++        context.Items["TenantContext"] = tenantContext;
++
++        // Validate tenant_id header matches JWT claim (prevent tenant spoofing)
++        var existingTenantId = context.Request.Headers[HeaderNames.TenantId].FirstOrDefault();
++        if (!string.IsNullOrEmpty(existingTenantId) && existingTenantId != tenantContext.TenantId.ToString())
++        {
++            _logger.SystemWarn($"[{ErrorCodes.AuthUnauthorized}] Tenant ID mismatch: header={existingTenantId}, jwt={tenantContext.TenantId}, path={path}");
++            context.Response.StatusCode = 403;
++            await context.Response.WriteAsJsonAsync(
++                ErrorResponse.Create(ErrorCodes.AuthUnauthorized, "Tenant ID mismatch between header and JWT token", "-"));
++            return;
++        }
++
++        if (string.IsNullOrEmpty(existingTenantId))
++        {
++            context.Request.Headers[HeaderNames.TenantId] = tenantContext.TenantId.ToString();
++        }
++
++        await _next(context);
++    }
++
++    private bool RequiresAuth(string path)
++    {
++        foreach (var prefix in _authRequiredPrefixes)
++        {
++            if (path.StartsWith(prefix, StringComparison.OrdinalIgnoreCase))
++                return true;
++        }
++        return false;
++    }
++}
++
++public static class JwtAuthMiddlewareExtensions
++{
++    public static IApplicationBuilder UseJwtAuth(
++        this IApplicationBuilder app,
++        JwtValidator jwtValidator,
++        JsonLinesLogger logger,
++        params string[] authRequiredPrefixes)
++    {
++        return app.UseMiddleware<JwtAuthMiddleware>(jwtValidator, logger, (IEnumerable<string>)authRequiredPrefixes);
++    }
++}
+diff --git a/src/Invekto.Outbound/Middleware/TrafficLoggingMiddleware.cs b/src/Invekto.Outbound/Middleware/TrafficLoggingMiddleware.cs
+new file mode 100644
+index 0000000..39f7956
+--- /dev/null
++++ b/src/Invekto.Outbound/Middleware/TrafficLoggingMiddleware.cs
+@@ -0,0 +1,95 @@
++using System.Diagnostics;
++using System.Text;
++using Invekto.Shared.DTOs;
++using Invekto.Shared.Logging;
++
++namespace Invekto.Outbound.Middleware;
++
++public sealed class TrafficLoggingMiddleware
++{
++    private readonly RequestDelegate _next;
++    private readonly JsonLinesLogger _logger;
++
++    private static readonly string[] SkipPaths = { "/health", "/ready" };
++
++    public TrafficLoggingMiddleware(RequestDelegate next, JsonLinesLogger logger)
++    {
++        _next = next;
++        _logger = logger;
++    }
++
++    public async Task InvokeAsync(HttpContext context)
++    {
++        var path = context.Request.Path.Value ?? "";
++
++        if (SkipPaths.Any(p => path.StartsWith(p, StringComparison.OrdinalIgnoreCase)))
++        {
++            await _next(context);
++            return;
++        }
++
++        var sw = Stopwatch.StartNew();
++
++        string? requestBody = null;
++        if (context.Request.ContentLength > 0 && context.Request.ContentLength < 50000)
++        {
++            context.Request.EnableBuffering();
++            using var reader = new StreamReader(
++                context.Request.Body, Encoding.UTF8,
++                detectEncodingFromByteOrderMarks: false, leaveOpen: true);
++            requestBody = await reader.ReadToEndAsync();
++            context.Request.Body.Position = 0;
++        }
++
++        var originalBodyStream = context.Response.Body;
++        using var responseBodyStream = new MemoryStream();
++        context.Response.Body = responseBodyStream;
++
++        try
++        {
++            await _next(context);
++        }
++        finally
++        {
++            sw.Stop();
++
++            string? responseBody = null;
++            if (responseBodyStream.Length > 0 && responseBodyStream.Length < 50000)
++            {
++                responseBodyStream.Position = 0;
++                responseBody = await new StreamReader(responseBodyStream).ReadToEndAsync();
++            }
++
++            responseBodyStream.Position = 0;
++            await responseBodyStream.CopyToAsync(originalBodyStream);
++            context.Response.Body = originalBodyStream;
++
++            var requestId = context.Request.Headers["X-Request-Id"].FirstOrDefault()
++                ?? context.TraceIdentifier;
++            var tenantId = context.Request.Headers["X-Tenant-Id"].FirstOrDefault() ?? "-";
++            var chatId = context.Request.Headers["X-Chat-Id"].FirstOrDefault() ?? "-";
++
++            var logContext = new RequestContext
++            {
++                RequestId = requestId,
++                TenantId = tenantId,
++                ChatId = chatId
++            };
++
++            var level = context.Response.StatusCode >= 400 ? "WARN" : "INFO";
++            var message = $"{context.Request.Method} {path} -> {context.Response.StatusCode}";
++
++            _logger.LogTraffic(level, message, logContext, path,
++                context.Request.Method, sw.ElapsedMilliseconds,
++                context.Response.StatusCode, requestBody, responseBody);
++        }
++    }
++}
++
++public static class TrafficLoggingMiddlewareExtensions
++{
++    public static IApplicationBuilder UseTrafficLogging(this IApplicationBuilder builder)
++    {
++        return builder.UseMiddleware<TrafficLoggingMiddleware>();
++    }
++}
+diff --git a/src/Invekto.Outbound/Program.cs b/src/Invekto.Outbound/Program.cs
+new file mode 100644
+index 0000000..ac44e73
+--- /dev/null
++++ b/src/Invekto.Outbound/Program.cs
+@@ -0,0 +1,587 @@
++using Invekto.Outbound.Data;
++using Invekto.Outbound.Middleware;
++using Invekto.Outbound.Services;
++using Invekto.Shared.Auth;
++using Invekto.Shared.Constants;
++using Invekto.Shared.Data;
++using Invekto.Shared.DTOs;
++using Invekto.Shared.DTOs.Outbound;
++using Invekto.Shared.Integration;
++using Invekto.Shared.Logging;
++
++var builder = WebApplication.CreateBuilder(args);
++
++// Windows Service support
++builder.Host.UseWindowsService();
++
++// Read configuration
++var listenPort = builder.Configuration.GetValue<int>("Service:ListenPort", ServiceConstants.OutboundPort);
++var logPath = builder.Configuration["Logging:FilePath"] ?? "logs";
++var pgConnStr = builder.Configuration.GetConnectionString("PostgreSQL") ?? "";
++var jwtSecretKey = builder.Configuration["Jwt:SecretKey"] ?? "";
++var defaultMsgPerMin = builder.Configuration.GetValue<int>("RateLimit:DefaultMessagesPerMinute", 30);
++var senderIntervalMs = builder.Configuration.GetValue<int>("RateLimit:SenderIntervalMs", 1000);
++var callbackUrl = builder.Configuration["Callback:DefaultCallbackUrl"] ?? "";
++var callbackMaxRetries = builder.Configuration.GetValue<int>("Callback:MaxRetries", 3);
++var callbackBaseDelayMs = builder.Configuration.GetValue<int>("Callback:BaseDelayMs", 500);
++var callbackTimeoutMs = builder.Configuration.GetValue<int>("Callback:TimeoutMs", 5000);
++
++// Validate required config
++if (string.IsNullOrEmpty(pgConnStr))
++{
++    Console.Error.WriteLine("FATAL: ConnectionStrings:PostgreSQL is not configured");
++    Environment.Exit(1);
++}
++if (string.IsNullOrEmpty(jwtSecretKey))
++{
++    Console.Error.WriteLine("FATAL: Jwt:SecretKey is not configured");
++    Environment.Exit(1);
++}
++
++// Configure Kestrel
++builder.WebHost.ConfigureKestrel(options =>
++{
++    options.ListenAnyIP(listenPort);
++});
++
++// Register logger
++var logger = new JsonLinesLogger(ServiceConstants.OutboundServiceName, logPath);
++builder.Services.AddSingleton(logger);
++
++// Register log cleanup
++builder.Services.AddSingleton<LogCleanupService>(sp =>
++    new LogCleanupService(logPath, ServiceConstants.LogRetentionDays));
++
++// Register JWT validator
++var jwtSettings = new JwtSettings
++{
++    SecretKey = jwtSecretKey,
++    Issuer = builder.Configuration["Jwt:Issuer"],
++    Audience = builder.Configuration["Jwt:Audience"],
++    ClockSkewSeconds = builder.Configuration.GetValue<int>("Jwt:ClockSkewSeconds", 60)
++};
++var jwtValidator = new JwtValidator(jwtSettings);
++builder.Services.AddSingleton(jwtValidator);
++
++// Register PostgreSQL connection factory
++var pgFactory = new PostgresConnectionFactory(pgConnStr);
++builder.Services.AddSingleton(pgFactory);
++
++// Register repository
++builder.Services.AddSingleton<OutboundRepository>();
++
++// Register services
++builder.Services.AddSingleton<TemplateEngine>();
++builder.Services.AddSingleton<OptOutManager>();
++builder.Services.AddSingleton(new RateLimiter(defaultMsgPerMin, logger));
++builder.Services.AddSingleton<BroadcastOrchestrator>();
++builder.Services.AddSingleton<TriggerProcessor>();
++
++// Register MainAppCallbackClient with HttpClient
++var callbackSettings = new CallbackSettings
++{
++    DefaultCallbackUrl = callbackUrl,
++    MaxRetries = callbackMaxRetries,
++    BaseDelayMs = callbackBaseDelayMs,
++    TimeoutMs = callbackTimeoutMs
++};
++builder.Services.AddSingleton(callbackSettings);
++builder.Services.AddHttpClient<MainAppCallbackClient>()
++    .AddTypedClient((httpClient, sp) =>
++    {
++        return new MainAppCallbackClient(
++            httpClient,
++            sp.GetRequiredService<CallbackSettings>(),
++            sp.GetRequiredService<JsonLinesLogger>());
++    });
++
++// Register background message sender
++builder.Services.AddSingleton<MessageSenderService>(sp =>
++    new MessageSenderService(
++        sp.GetRequiredService<OutboundRepository>(),
++        sp.GetRequiredService<RateLimiter>(),
++        sp.GetRequiredService<MainAppCallbackClient>(),
++        sp.GetRequiredService<JsonLinesLogger>(),
++        senderIntervalMs));
++builder.Services.AddHostedService(sp => sp.GetRequiredService<MessageSenderService>());
++
++var app = builder.Build();
++
++// Enable traffic logging middleware
++app.UseTrafficLogging();
++
++// Enable JWT auth for /api/v1/ prefixed paths
++app.UseJwtAuth(jwtValidator, logger, "/api/v1/");
++
++// Start log cleanup
++_ = app.Services.GetRequiredService<LogCleanupService>();
++
++// ============================================================
++// Health endpoints
++// ============================================================
++
++app.MapGet("/health", () => Results.Ok(HealthResponse.Ok(ServiceConstants.OutboundServiceName)));
++app.MapGet("/ready", async (PostgresConnectionFactory db) =>
++{
++    var (ok, error) = await db.TestConnectionAsync();
++    if (!ok)
++        return Results.Json(new { status = "unhealthy", error }, statusCode: 503);
++    return Results.Ok(HealthResponse.Ok(ServiceConstants.OutboundServiceName));
++});
++
++// ============================================================
++// Broadcast endpoints
++// ============================================================
++
++app.MapPost("/api/v1/broadcast/send", async (
++    HttpContext ctx,
++    BroadcastOrchestrator orchestrator,
++    JsonLinesLogger jsonLogger,
++    BroadcastSendRequest? request) =>
++{
++    var requestId = ctx.Request.Headers["X-Request-Id"].FirstOrDefault() ?? Guid.NewGuid().ToString("N");
++    ctx.Request.Headers["X-Request-Id"] = requestId;
++
++    if (request == null)
++    {
++        return Results.Json(
++            ErrorResponse.Create(ErrorCodes.OutboundInvalidBroadcastPayload, "Request body is required", requestId),
++            statusCode: 400);
++    }
++
++    var tenantContext = ctx.Items["TenantContext"] as TenantContext;
++    if (tenantContext == null)
++    {
++        return Results.Json(
++            ErrorResponse.Create(ErrorCodes.AuthUnauthorized, "Tenant context not available", requestId),
++            statusCode: 401);
++    }
++
++    var (response, errorCode, errorMessage) = await orchestrator.CreateBroadcastAsync(
++        tenantContext.TenantId, request, CancellationToken.None);
++
++    if (response == null)
++    {
++        var statusCode = errorCode switch
++        {
++            ErrorCodes.OutboundTooManyRecipients => 400,
++            ErrorCodes.OutboundTemplateNotFound => 404,
++            _ => 400
++        };
++        return Results.Json(
++            ErrorResponse.Create(errorCode!, errorMessage!, requestId),
++            statusCode: statusCode);
++    }
++
++    jsonLogger.StepInfo(
++        $"Broadcast submitted: id={response.BroadcastId}, queued={response.Queued}, skipped={response.SkippedOptout}",
++        requestId);
++
++    return Results.Json(response, statusCode: 202);
++});
++
++app.MapGet("/api/v1/broadcast/{broadcastId}/status", async (
++    HttpContext ctx,
++    OutboundRepository repository,
++    string broadcastId) =>
++{
++    var requestId = ctx.Request.Headers["X-Request-Id"].FirstOrDefault() ?? Guid.NewGuid().ToString("N");
++
++    var tenantContext = ctx.Items["TenantContext"] as TenantContext;
++    if (tenantContext == null)
++    {
++        return Results.Json(
++            ErrorResponse.Create(ErrorCodes.AuthUnauthorized, "Tenant context not available", requestId),
++            statusCode: 401);
++    }
++
++    if (!Guid.TryParse(broadcastId, out var bid))
++    {
++        return Results.Json(
++            ErrorResponse.Create(ErrorCodes.OutboundBroadcastNotFound, "Invalid broadcast ID format", requestId),
++            statusCode: 400);
++    }
++
++    var status = await repository.GetBroadcastStatusAsync(tenantContext.TenantId, bid);
++    if (status == null)
++    {
++        return Results.Json(
++            ErrorResponse.Create(ErrorCodes.OutboundBroadcastNotFound, $"Broadcast {broadcastId} not found", requestId),
++            statusCode: 404);
++    }
++
++    return Results.Ok(status);
++});
++
++// ============================================================
++// Webhook endpoints
++// ============================================================
++
++app.MapPost("/api/v1/webhook/trigger", async (
++    HttpContext ctx,
++    TriggerProcessor triggerProcessor,
++    JsonLinesLogger jsonLogger,
++    TriggerWebhookRequest? request) =>
++{
++    var requestId = ctx.Request.Headers["X-Request-Id"].FirstOrDefault() ?? Guid.NewGuid().ToString("N");
++    ctx.Request.Headers["X-Request-Id"] = requestId;
++
++    if (request == null)
++    {
++        return Results.Json(
++            ErrorResponse.Create(ErrorCodes.OutboundInvalidBroadcastPayload, "Request body is required", requestId),
++            statusCode: 400);
++    }
++
++    var tenantContext = ctx.Items["TenantContext"] as TenantContext;
++    if (tenantContext == null)
++    {
++        return Results.Json(
++            ErrorResponse.Create(ErrorCodes.AuthUnauthorized, "Tenant context not available", requestId),
++            statusCode: 401);
++    }
++
++    var (response, errorCode, errorMessage, statusCode) = await triggerProcessor.ProcessTriggerAsync(
++        tenantContext.TenantId, request, CancellationToken.None);
++
++    if (response == null)
++    {
++        return Results.Json(
++            ErrorResponse.Create(errorCode!, errorMessage!, requestId),
++            statusCode: statusCode);
++    }
++
++    jsonLogger.StepInfo(
++        $"Trigger processed: event={request.Event}, message_id={response.MessageId}, template={response.TemplateId}",
++        requestId);
++
++    return Results.Json(response, statusCode: 202);
++});
++
++app.MapPost("/api/v1/webhook/delivery-status", async (
++    HttpContext ctx,
++    OutboundRepository repository,
++    JsonLinesLogger jsonLogger,
++    DeliveryStatusRequest? request) =>
++{
++    var requestId = ctx.Request.Headers["X-Request-Id"].FirstOrDefault() ?? Guid.NewGuid().ToString("N");
++
++    if (request == null || string.IsNullOrWhiteSpace(request.ExternalMessageId))
++    {
++        return Results.Json(
++            ErrorResponse.Create(ErrorCodes.OutboundDeliveryStatusFailed, "external_message_id is required", requestId),
++            statusCode: 400);
++    }
++
++    if (request.Status is not ("sent" or "delivered" or "read" or "failed"))
++    {
++        return Results.Json(
++            ErrorResponse.Create(ErrorCodes.OutboundDeliveryStatusFailed,
++                "status must be one of: sent, delivered, read, failed", requestId),
++            statusCode: 400);
++    }
++
++    var found = await repository.FindMessageByExternalIdAsync(request.ExternalMessageId);
++    if (found == null)
++    {
++        return Results.Json(
++            ErrorResponse.Create(ErrorCodes.OutboundDeliveryStatusFailed,
++                $"Message not found for external_message_id: {request.ExternalMessageId}", requestId),
++            statusCode: 404);
++    }
++
++    var (messageId, broadcastId, tenantId) = found.Value;
++
++    await repository.UpdateMessageStatusAsync(
++        messageId, request.Status, failedReason: request.FailedReason);
++
++    // Update broadcast counters if applicable
++    if (broadcastId.HasValue && request.Status is "delivered" or "read" or "failed")
++    {
++        await repository.IncrementBroadcastCounterAsync(broadcastId.Value, request.Status);
++    }
++
++    jsonLogger.StepInfo(
++        $"Delivery status updated: external_id={request.ExternalMessageId}, status={request.Status}", requestId);
++
++    return Results.Ok(new { updated = true });
++});
++
++app.MapPost("/api/v1/webhook/message", async (
++    HttpContext ctx,
++    OptOutManager optOutManager,
++    JsonLinesLogger jsonLogger,
++    IncomingMessageRequest? request) =>
++{
++    var requestId = ctx.Request.Headers["X-Request-Id"].FirstOrDefault() ?? Guid.NewGuid().ToString("N");
++
++    if (request == null || string.IsNullOrWhiteSpace(request.Phone) || string.IsNullOrWhiteSpace(request.MessageText))
++    {
++        return Results.Json(
++            ErrorResponse.Create(ErrorCodes.OutboundInvalidBroadcastPayload, "phone and message_text are required", requestId),
++            statusCode: 400);
++    }
++
++    var tenantContext = ctx.Items["TenantContext"] as TenantContext;
++    if (tenantContext == null)
++    {
++        return Results.Json(
++            ErrorResponse.Create(ErrorCodes.AuthUnauthorized, "Tenant context not available", requestId),
++            statusCode: 401);
++    }
++
++    var (optedOut, keyword) = await optOutManager.ProcessIncomingMessageAsync(
++        tenantContext.TenantId, request.Phone, request.MessageText);
++
++    if (optedOut)
++    {
++        jsonLogger.StepInfo(
++            $"Opt-out detected: tenant={tenantContext.TenantId}, phone={request.Phone}, keyword={keyword}", requestId);
++    }
++
++    return Results.Ok(new IncomingMessageResponse
++    {
++        OptedOut = optedOut,
++        KeywordMatched = keyword
++    });
++});
++
++// ============================================================
++// Template CRUD endpoints
++// ============================================================
++
++app.MapGet("/api/v1/templates", async (
++    HttpContext ctx,
++    OutboundRepository repository) =>
++{
++    var tenantContext = ctx.Items["TenantContext"] as TenantContext;
++    if (tenantContext == null)
++        return Results.Json(ErrorResponse.Create(ErrorCodes.AuthUnauthorized, "Tenant context not available", "-"), statusCode: 401);
++
++    var templates = await repository.GetActiveTemplatesAsync(tenantContext.TenantId);
++    return Results.Ok(new { templates });
++});
++
++app.MapPost("/api/v1/templates", async (
++    HttpContext ctx,
++    OutboundRepository repository,
++    JsonLinesLogger jsonLogger,
++    TemplateCreateRequest? request) =>
++{
++    var requestId = ctx.Request.Headers["X-Request-Id"].FirstOrDefault() ?? Guid.NewGuid().ToString("N");
++
++    if (request == null || string.IsNullOrWhiteSpace(request.Name) || string.IsNullOrWhiteSpace(request.MessageTemplate))
++    {
++        return Results.Json(
++            ErrorResponse.Create(ErrorCodes.OutboundInvalidTemplatePayload, "name and message_template are required", requestId),
++            statusCode: 400);
++    }
++
++    if (request.Name.Length > 200)
++    {
++        return Results.Json(
++            ErrorResponse.Create(ErrorCodes.OutboundInvalidTemplatePayload, "name must be 200 characters or less", requestId),
++            statusCode: 400);
++    }
++
++    // Validate trigger_event
++    var validEvents = new[] { "manual", "new_lead", "payment_received", "appointment_reminder" };
++    if (!validEvents.Contains(request.TriggerEvent))
++    {
++        return Results.Json(
++            ErrorResponse.Create(ErrorCodes.OutboundInvalidTemplatePayload,
++                $"trigger_event must be one of: {string.Join(", ", validEvents)}", requestId),
++            statusCode: 400);
++    }
++
++    var tenantContext = ctx.Items["TenantContext"] as TenantContext;
++    if (tenantContext == null)
++        return Results.Json(ErrorResponse.Create(ErrorCodes.AuthUnauthorized, "Tenant context not available", requestId), statusCode: 401);
++
++    var id = await repository.CreateTemplateAsync(
++        tenantContext.TenantId, request.Name, request.TriggerEvent,
++        request.MessageTemplate, request.VariablesJson);
++
++    jsonLogger.StepInfo($"Template created: id={id}, name={request.Name}, event={request.TriggerEvent}", requestId);
++
++    return Results.Json(new { id, name = request.Name }, statusCode: 201);
++});
++
++app.MapPut("/api/v1/templates/{id:int}", async (
++    HttpContext ctx,
++    OutboundRepository repository,
++    JsonLinesLogger jsonLogger,
++    int id,
++    TemplateUpdateRequest? request) =>
++{
++    var requestId = ctx.Request.Headers["X-Request-Id"].FirstOrDefault() ?? Guid.NewGuid().ToString("N");
++
++    if (request == null)
++    {
++        return Results.Json(
++            ErrorResponse.Create(ErrorCodes.OutboundInvalidTemplatePayload, "Request body is required", requestId),
++            statusCode: 400);
++    }
++
++    // Validate trigger_event if provided
++    if (request.TriggerEvent != null)
++    {
++        var validEvents = new[] { "manual", "new_lead", "payment_received", "appointment_reminder" };
++        if (!validEvents.Contains(request.TriggerEvent))
++        {
++            return Results.Json(
++                ErrorResponse.Create(ErrorCodes.OutboundInvalidTemplatePayload,
++                    $"trigger_event must be one of: {string.Join(", ", validEvents)}", requestId),
++                statusCode: 400);
++        }
++    }
++
++    var tenantContext = ctx.Items["TenantContext"] as TenantContext;
++    if (tenantContext == null)
++        return Results.Json(ErrorResponse.Create(ErrorCodes.AuthUnauthorized, "Tenant context not available", requestId), statusCode: 401);
++
++    var updated = await repository.UpdateTemplateAsync(tenantContext.TenantId, id, request);
++    if (!updated)
++    {
++        return Results.Json(
++            ErrorResponse.Create(ErrorCodes.OutboundTemplateNotFound, $"Template {id} not found or inactive", requestId),
++            statusCode: 404);
++    }
++
++    jsonLogger.StepInfo($"Template updated: id={id}", requestId);
++    return Results.Ok(new { id, updated = true });
++});
++
++app.MapDelete("/api/v1/templates/{id:int}", async (
++    HttpContext ctx,
++    OutboundRepository repository,
++    JsonLinesLogger jsonLogger,
++    int id) =>
++{
++    var requestId = ctx.Request.Headers["X-Request-Id"].FirstOrDefault() ?? Guid.NewGuid().ToString("N");
++
++    var tenantContext = ctx.Items["TenantContext"] as TenantContext;
++    if (tenantContext == null)
++        return Results.Json(ErrorResponse.Create(ErrorCodes.AuthUnauthorized, "Tenant context not available", requestId), statusCode: 401);
++
++    var deactivated = await repository.DeactivateTemplateAsync(tenantContext.TenantId, id);
++    if (!deactivated)
++    {
++        return Results.Json(
++            ErrorResponse.Create(ErrorCodes.OutboundTemplateNotFound, $"Template {id} not found or already inactive", requestId),
++            statusCode: 404);
++    }
++
++    jsonLogger.StepInfo($"Template deactivated: id={id}", requestId);
++    return Results.Ok(new { id, deactivated = true });
++});
++
++// ============================================================
++// Opt-out endpoints
++// ============================================================
++
++app.MapPost("/api/v1/optout", async (
++    HttpContext ctx,
++    OutboundRepository repository,
++    JsonLinesLogger jsonLogger,
++    OptOutRequest? request) =>
++{
++    var requestId = ctx.Request.Headers["X-Request-Id"].FirstOrDefault() ?? Guid.NewGuid().ToString("N");
++
++    if (request == null || string.IsNullOrWhiteSpace(request.Phone))
++    {
++        return Results.Json(
++            ErrorResponse.Create(ErrorCodes.OutboundInvalidBroadcastPayload, "phone is required", requestId),
++            statusCode: 400);
++    }
++
++    var tenantContext = ctx.Items["TenantContext"] as TenantContext;
++    if (tenantContext == null)
++        return Results.Json(ErrorResponse.Create(ErrorCodes.AuthUnauthorized, "Tenant context not available", requestId), statusCode: 401);
++
++    await repository.AddOptOutAsync(tenantContext.TenantId, request.Phone, request.Reason);
++    jsonLogger.StepInfo($"Manual opt-out added: phone={request.Phone}", requestId);
++
++    return Results.Ok(new { phone = request.Phone, opted_out = true });
++});
++
++app.MapDelete("/api/v1/optout/{phone}", async (
++    HttpContext ctx,
++    OutboundRepository repository,
++    JsonLinesLogger jsonLogger,
++    string phone) =>
++{
++    var requestId = ctx.Request.Headers["X-Request-Id"].FirstOrDefault() ?? Guid.NewGuid().ToString("N");
++
++    var tenantContext = ctx.Items["TenantContext"] as TenantContext;
++    if (tenantContext == null)
++        return Results.Json(ErrorResponse.Create(ErrorCodes.AuthUnauthorized, "Tenant context not available", requestId), statusCode: 401);
++
++    var removed = await repository.RemoveOptOutAsync(tenantContext.TenantId, phone);
++    if (!removed)
++    {
++        return Results.Json(
++            ErrorResponse.Create(ErrorCodes.OutboundRecipientOptedOut, $"Opt-out record not found for {phone}", requestId),
++            statusCode: 404);
++    }
++
++    jsonLogger.StepInfo($"Opt-out removed: phone={phone}", requestId);
++    return Results.Ok(new { phone, removed = true });
++});
++
++app.MapGet("/api/v1/optout/check/{phone}", async (
++    HttpContext ctx,
++    OutboundRepository repository,
++    string phone) =>
++{
++    var tenantContext = ctx.Items["TenantContext"] as TenantContext;
++    if (tenantContext == null)
++        return Results.Json(ErrorResponse.Create(ErrorCodes.AuthUnauthorized, "Tenant context not available", "-"), statusCode: 401);
++
++    var optOutDate = await repository.GetOptOutDateAsync(tenantContext.TenantId, phone);
++    return Results.Ok(new OptOutCheckResponse
++    {
++        Phone = phone,
++        OptedOut = optOutDate.HasValue,
++        OptedOutAt = optOutDate
++    });
++});
++
++// ============================================================
++// Endpoint discovery
++// ============================================================
++
++app.MapGet("/api/ops/endpoints", () =>
++{
++    var endpoints = new List<EndpointInfo>
++    {
++        new() { Method = "POST", Path = "/api/v1/broadcast/send", Description = "Submit broadcast (async, 202)", Auth = "Bearer JWT", Category = "Broadcast" },
++        new() { Method = "GET", Path = "/api/v1/broadcast/{broadcastId}/status", Description = "Get broadcast delivery status", Auth = "Bearer JWT", Category = "Broadcast" },
++        new() { Method = "POST", Path = "/api/v1/webhook/trigger", Description = "Receive trigger event from Main App", Auth = "Bearer JWT", Category = "Webhook" },
++        new() { Method = "POST", Path = "/api/v1/webhook/delivery-status", Description = "Receive delivery status update", Auth = "Bearer JWT", Category = "Webhook" },
++        new() { Method = "POST", Path = "/api/v1/webhook/message", Description = "Receive incoming message for opt-out detection", Auth = "Bearer JWT", Category = "Webhook" },
++        new() { Method = "GET", Path = "/api/v1/templates", Description = "List active templates", Auth = "Bearer JWT", Category = "Templates" },
++        new() { Method = "POST", Path = "/api/v1/templates", Description = "Create template", Auth = "Bearer JWT", Category = "Templates" },
++        new() { Method = "PUT", Path = "/api/v1/templates/{id}", Description = "Update template", Auth = "Bearer JWT", Category = "Templates" },
++        new() { Method = "DELETE", Path = "/api/v1/templates/{id}", Description = "Deactivate template", Auth = "Bearer JWT", Category = "Templates" },
++        new() { Method = "POST", Path = "/api/v1/optout", Description = "Manual opt-out add", Auth = "Bearer JWT", Category = "OptOut" },
++        new() { Method = "DELETE", Path = "/api/v1/optout/{phone}", Description = "Remove opt-out", Auth = "Bearer JWT", Category = "OptOut" },
++        new() { Method = "GET", Path = "/api/v1/optout/check/{phone}", Description = "Check if phone opted out", Auth = "Bearer JWT", Category = "OptOut" },
++        new() { Method = "GET", Path = "/health", Description = "Health check", Auth = "none", Category = "Health" },
++        new() { Method = "GET", Path = "/ready", Description = "Readiness probe (DB check)", Auth = "none", Category = "Health" },
++        new() { Method = "GET", Path = "/api/ops/endpoints", Description = "Endpoint discovery (this)", Auth = "none", Category = "Ops" },
++    };
++
++    return Results.Ok(new EndpointDiscoveryResponse
++    {
++        Service = ServiceConstants.OutboundServiceName,
++        Port = ServiceConstants.OutboundPort,
++        Endpoints = endpoints
++    });
++});
++
++logger.SystemInfo($"Outbound service starting on port {listenPort}");
++app.Run();
++
++// Required for integration tests
++public partial class Program { }
+diff --git a/src/Invekto.Outbound/Services/BroadcastOrchestrator.cs b/src/Invekto.Outbound/Services/BroadcastOrchestrator.cs
+new file mode 100644
+index 0000000..bbb0c23
+--- /dev/null
++++ b/src/Invekto.Outbound/Services/BroadcastOrchestrator.cs
+@@ -0,0 +1,115 @@
++using Invekto.Outbound.Data;
++using Invekto.Shared.Constants;
++using Invekto.Shared.DTOs.Outbound;
++using Invekto.Shared.Logging;
++
++namespace Invekto.Outbound.Services;
++
++/// <summary>
++/// Orchestrates broadcast creation: validates, checks opt-outs,
++/// applies template, inserts messages as 'queued'.
++/// Thread-safe, register as singleton.
++/// </summary>
++public sealed class BroadcastOrchestrator
++{
++    private readonly OutboundRepository _repository;
++    private readonly TemplateEngine _templateEngine;
++    private readonly OptOutManager _optOutManager;
++    private readonly JsonLinesLogger _logger;
++
++    public BroadcastOrchestrator(
++        OutboundRepository repository,
++        TemplateEngine templateEngine,
++        OptOutManager optOutManager,
++        JsonLinesLogger logger)
++    {
++        _repository = repository;
++        _templateEngine = templateEngine;
++        _optOutManager = optOutManager;
++        _logger = logger;
++    }
++
++    /// <summary>
++    /// Create a broadcast: validate template, filter opt-outs, insert messages.
++    /// Returns the broadcast response or an error tuple.
++    /// </summary>
++    public async Task<(BroadcastSendResponse? response, string? errorCode, string? errorMessage)>
++        CreateBroadcastAsync(
++            int tenantId, BroadcastSendRequest request, CancellationToken ct = default)
++    {
++        // Validate recipients count
++        if (request.Recipients == null || request.Recipients.Count == 0)
++            return (null, ErrorCodes.OutboundInvalidBroadcastPayload, "recipients is required and cannot be empty");
++
++        if (request.Recipients.Count > 1000)
++            return (null, ErrorCodes.OutboundTooManyRecipients, $"Max 1000 recipients per broadcast, got {request.Recipients.Count}");
++
++        // Validate template exists
++        var template = await _repository.GetTemplateByIdAsync(tenantId, request.TemplateId, ct);
++        if (template == null)
++            return (null, ErrorCodes.OutboundTemplateNotFound, $"Template {request.TemplateId} not found or inactive");
++
++        // Collect valid phones for batch opt-out check
++        var validRecipients = request.Recipients
++            .Where(r => !string.IsNullOrWhiteSpace(r.Phone))
++            .ToList();
++
++        // Batch opt-out check (single query instead of N queries)
++        var phones = validRecipients.Select(r => r.Phone).ToList();
++        var optedOutPhones = await _repository.BatchCheckOptOutsAsync(tenantId, phones, ct);
++
++        // Filter and prepare messages
++        var skippedOptout = 0;
++        var messagesToInsert = new List<(string phone, string text)>();
++
++        foreach (var recipient in validRecipients)
++        {
++            if (optedOutPhones.Contains(recipient.Phone))
++            {
++                skippedOptout++;
++                continue;
++            }
++
++            // Apply template variables
++            var (messageText, missingVars) = _templateEngine.Substitute(
++                template.MessageTemplate, recipient.Variables);
++
++            if (missingVars.Count > 0)
++            {
++                _logger.SystemWarn(
++                    $"Broadcast skipping {recipient.Phone}: missing variables [{string.Join(", ", missingVars)}]");
++                continue;
++            }
++
++            messagesToInsert.Add((recipient.Phone, messageText));
++        }
++
++        if (messagesToInsert.Count == 0)
++        {
++            return (null, ErrorCodes.OutboundInvalidBroadcastPayload,
++                "No valid recipients after opt-out filtering and variable validation");
++        }
++
++        // Create broadcast record
++        var broadcastId = await _repository.CreateBroadcastAsync(
++            tenantId, request.TemplateId, request.Recipients.Count,
++            messagesToInsert.Count, request.ScheduledAt, ct);
++
++        // Batch insert all messages (single multi-row INSERT)
++        await _repository.BatchInsertMessagesAsync(
++            tenantId, broadcastId, request.TemplateId, messagesToInsert, ct);
++        var queuedCount = messagesToInsert.Count;
++
++        _logger.SystemInfo(
++            $"Broadcast created: id={broadcastId}, tenant={tenantId}, " +
++            $"total={request.Recipients.Count}, queued={queuedCount}, skipped_optout={skippedOptout}");
++
++        return (new BroadcastSendResponse
++        {
++            BroadcastId = broadcastId,
++            TotalRecipients = request.Recipients.Count,
++            Queued = queuedCount,
++            SkippedOptout = skippedOptout
++        }, null, null);
++    }
++}
+diff --git a/src/Invekto.Outbound/Services/MessageSenderService.cs b/src/Invekto.Outbound/Services/MessageSenderService.cs
+new file mode 100644
+index 0000000..389f18c
+--- /dev/null
++++ b/src/Invekto.Outbound/Services/MessageSenderService.cs
+@@ -0,0 +1,204 @@
++using Invekto.Outbound.Data;
++using Invekto.Shared.Constants;
++using Invekto.Shared.DTOs.Integration;
++using Invekto.Shared.Integration;
++using Invekto.Shared.Logging;
++
++namespace Invekto.Outbound.Services;
++
++/// <summary>
++/// Background service that dequeues messages and sends them via Main App callback.
++/// Respects tenant-based rate limits. Graceful shutdown via CancellationToken.
++/// </summary>
++public sealed class MessageSenderService : IHostedService, IDisposable
++{
++    private readonly OutboundRepository _repository;
++    private readonly RateLimiter _rateLimiter;
++    private readonly MainAppCallbackClient _callbackClient;
++    private readonly JsonLinesLogger _logger;
++    private readonly int _intervalMs;
++
++    private Timer? _timer;
++    private int _isProcessing; // 0 = idle, 1 = processing (interlocked)
++    private CancellationTokenSource? _cts;
++
++    public MessageSenderService(
++        OutboundRepository repository,
++        RateLimiter rateLimiter,
++        MainAppCallbackClient callbackClient,
++        JsonLinesLogger logger,
++        int intervalMs = 1000)
++    {
++        _repository = repository;
++        _rateLimiter = rateLimiter;
++        _callbackClient = callbackClient;
++        _logger = logger;
++        _intervalMs = intervalMs;
++    }
++
++    public Task StartAsync(CancellationToken cancellationToken)
++    {
++        _cts = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken);
++        _logger.SystemInfo($"MessageSenderService starting (interval={_intervalMs}ms)");
++        _timer = new Timer(ProcessQueue, null, _intervalMs, _intervalMs);
++        return Task.CompletedTask;
++    }
++
++    public async Task StopAsync(CancellationToken cancellationToken)
++    {
++        _logger.SystemInfo("MessageSenderService stopping (graceful shutdown)");
++        _timer?.Change(Timeout.Infinite, 0);
++        _cts?.Cancel();
++
++        // Wait for current processing to finish (max 10s)
++        var waitCount = 0;
++        while (Interlocked.CompareExchange(ref _isProcessing, 0, 0) == 1 && waitCount < 100)
++        {
++            Thread.Sleep(100);
++            waitCount++;
++        }
++
++        // Reset any messages stuck in 'sending' back to 'queued'
++        try
++        {
++            await _repository.ResetSendingMessagesAsync(cancellationToken);
++        }
++        catch (Exception ex)
++        {
++            _logger.SystemError($"Failed to reset stale sending messages: {ex.Message}");
++        }
++    }
++
++    public void Dispose()
++    {
++        _timer?.Dispose();
++        _cts?.Dispose();
++    }
++
++    private async void ProcessQueue(object? state)
++    {
++        // Prevent overlapping processing
++        if (Interlocked.CompareExchange(ref _isProcessing, 1, 0) != 0)
++            return;
++
++        try
++        {
++            var ct = _cts?.Token ?? CancellationToken.None;
++            if (ct.IsCancellationRequested) return;
++
++            // Dequeue a small batch
++            var messages = await _repository.DequeueMessagesAsync(10, ct);
++            if (messages.Count == 0) return;
++
++            foreach (var msg in messages)
++            {
++                if (ct.IsCancellationRequested) break;
++
++                // Check rate limit per tenant
++                if (!_rateLimiter.TryAcquire(msg.TenantId))
++                {
++                    // Put back to queued (rate limited - will retry next cycle)
++                    await _repository.UpdateMessageStatusAsync(msg.Id, "queued", ct: ct);
++                    _logger.SystemInfo($"Rate limited: tenant={msg.TenantId}, message={msg.Id}, requeued");
++                    continue;
++                }
++
++                await SendMessageAsync(msg, ct);
++            }
++        }
++        catch (OperationCanceledException)
++        {
++            // Graceful shutdown
++        }
++        catch (Exception ex)
++        {
++            _logger.SystemError($"MessageSenderService error: {ex.Message}");
++        }
++        finally
++        {
++            Interlocked.Exchange(ref _isProcessing, 0);
++        }
++    }
++
++    private async Task SendMessageAsync(QueuedMessage msg, CancellationToken ct)
++    {
++        try
++        {
++            var callback = new OutgoingCallback
++            {
++                RequestId = Guid.NewGuid().ToString("N"),
++                Action = CallbackActions.SendMessage,
++                TenantId = msg.TenantId,
++                ChatId = 0, // Outbound doesn't have a chat context
++                SequenceId = msg.Id,
++                Data = new CallbackData
++                {
++                    MessageText = msg.MessageText,
++                    Phone = msg.RecipientPhone,
++                    BroadcastId = msg.BroadcastId,
++                    OutboundMessageId = msg.Id
++                },
++                ProcessingTimeMs = 0,
++                Timestamp = DateTime.UtcNow
++            };
++
++            var success = await _callbackClient.SendCallbackAsync(callback, ct: ct);
++
++            if (success)
++            {
++                // Mark as sent - delivery status will come via webhook later
++                await _repository.UpdateMessageStatusAsync(msg.Id, "sent", ct: ct);
++
++                if (msg.BroadcastId.HasValue)
++                    await _repository.IncrementBroadcastCounterAsync(msg.BroadcastId.Value, "sent", ct);
++
++                // Check if broadcast is complete
++                if (msg.BroadcastId.HasValue)
++                    await TryCompleteBroadcastAsync(msg.BroadcastId.Value, ct);
++            }
++            else
++            {
++                await _repository.UpdateMessageStatusAsync(
++                    msg.Id, "failed", failedReason: "Callback to Main App failed after retries", ct: ct);
++
++                if (msg.BroadcastId.HasValue)
++                    await _repository.IncrementBroadcastCounterAsync(msg.BroadcastId.Value, "failed", ct);
++
++                if (msg.BroadcastId.HasValue)
++                    await TryCompleteBroadcastAsync(msg.BroadcastId.Value, ct);
++
++                _logger.SystemError(
++                    $"[{ErrorCodes.OutboundMessageSendCallbackFailed}] Message send failed: " +
++                    $"id={msg.Id}, tenant={msg.TenantId}, phone={msg.RecipientPhone}");
++            }
++        }
++        catch (Exception ex)
++        {
++            _logger.SystemError($"SendMessage exception: id={msg.Id}, error={ex.Message}");
++            await _repository.UpdateMessageStatusAsync(
++                msg.Id, "failed", failedReason: $"Exception: {ex.Message}", ct: ct);
++
++            if (msg.BroadcastId.HasValue)
++            {
++                await _repository.IncrementBroadcastCounterAsync(msg.BroadcastId.Value, "failed", ct);
++                await TryCompleteBroadcastAsync(msg.BroadcastId.Value, ct);
++            }
++        }
++    }
++
++    private async Task TryCompleteBroadcastAsync(Guid broadcastId, CancellationToken ct)
++    {
++        try
++        {
++            if (await _repository.IsBroadcastCompleteAsync(broadcastId, ct))
++            {
++                await _repository.UpdateBroadcastStatusAsync(broadcastId, "completed", ct);
++                _logger.SystemInfo($"Broadcast completed: {broadcastId}");
++            }
++        }
++        catch (Exception ex)
++        {
++            _logger.SystemError($"Error checking broadcast completion: {broadcastId}, {ex.Message}");
++        }
++    }
++}
+diff --git a/src/Invekto.Outbound/Services/OptOutManager.cs b/src/Invekto.Outbound/Services/OptOutManager.cs
+new file mode 100644
+index 0000000..5a72e9a
+--- /dev/null
++++ b/src/Invekto.Outbound/Services/OptOutManager.cs
+@@ -0,0 +1,74 @@
++using Invekto.Outbound.Data;
++using Invekto.Shared.Logging;
++
++namespace Invekto.Outbound.Services;
++
++/// <summary>
++/// Manages opt-out registry and stop keyword detection.
++/// Thread-safe, register as singleton.
++/// </summary>
++public sealed class OptOutManager
++{
++    private readonly OutboundRepository _repository;
++    private readonly JsonLinesLogger _logger;
++
++    // Stop keywords - normalized to uppercase for comparison
++    private static readonly string[] StopKeywords =
++    {
++        "STOP", "DUR", "ΓöÇΓûæPTAL", "IPTAL", "DURDU", "Γö£├ºIKIΓö╝Γéº", "CIKIS"
++    };
++
++    public OptOutManager(OutboundRepository repository, JsonLinesLogger logger)
++    {
++        _repository = repository;
++        _logger = logger;
++    }
++
++    /// <summary>
++    /// Check if a phone number has opted out for a given tenant.
++    /// </summary>
++    public Task<bool> IsOptedOutAsync(int tenantId, string phone, CancellationToken ct = default)
++        => _repository.IsOptedOutAsync(tenantId, phone, ct);
++
++    /// <summary>
++    /// Detect stop keyword in incoming message text.
++    /// Returns the matched keyword or null.
++    /// </summary>
++    public string? DetectStopKeyword(string messageText)
++    {
++        if (string.IsNullOrWhiteSpace(messageText))
++            return null;
++
++        var normalized = messageText.Trim().ToUpperInvariant();
++        foreach (var keyword in StopKeywords)
++        {
++            if (normalized == keyword)
++                return keyword;
++        }
++        return null;
++    }
++
++    /// <summary>
++    /// Process incoming message for opt-out detection.
++    /// Returns (optedOut, matchedKeyword).
++    /// </summary>
++    public async Task<(bool optedOut, string? keyword)> ProcessIncomingMessageAsync(
++        int tenantId, string phone, string messageText, CancellationToken ct = default)
++    {
++        var keyword = DetectStopKeyword(messageText);
++        if (keyword == null)
++            return (false, null);
++
++        var added = await _repository.AddOptOutAsync(tenantId, phone, $"Keyword: {keyword}", ct);
++        if (added)
++        {
++            _logger.SystemInfo($"Opt-out registered: tenant={tenantId}, phone={phone}, keyword={keyword}");
++        }
++        else
++        {
++            _logger.SystemInfo($"Opt-out already exists: tenant={tenantId}, phone={phone}");
++        }
++
++        return (true, keyword);
++    }
++}
+diff --git a/src/Invekto.Outbound/Services/RateLimiter.cs b/src/Invekto.Outbound/Services/RateLimiter.cs
+new file mode 100644
+index 0000000..e79962d
+--- /dev/null
++++ b/src/Invekto.Outbound/Services/RateLimiter.cs
+@@ -0,0 +1,79 @@
++using System.Collections.Concurrent;
++using Invekto.Shared.Logging;
++
++namespace Invekto.Outbound.Services;
++
++/// <summary>
++/// Tenant-based in-memory rate limiter. Tracks messages per minute per tenant.
++/// When limit is exceeded, messages stay in the DB queue (not rejected).
++/// Thread-safe, register as singleton.
++/// </summary>
++public sealed class RateLimiter
++{
++    private readonly int _defaultMessagesPerMinute;
++    private readonly JsonLinesLogger _logger;
++
++    // Track per-tenant send timestamps (sliding window)
++    private readonly ConcurrentDictionary<int, TenantWindow> _windows = new();
++
++    public RateLimiter(int defaultMessagesPerMinute, JsonLinesLogger logger)
++    {
++        _defaultMessagesPerMinute = defaultMessagesPerMinute;
++        _logger = logger;
++    }
++
++    /// <summary>
++    /// Check if tenant can send a message right now.
++    /// Returns true if within rate limit, false if should wait.
++    /// </summary>
++    public bool TryAcquire(int tenantId)
++    {
++        var window = _windows.GetOrAdd(tenantId, _ => new TenantWindow());
++        return window.TryAcquire(_defaultMessagesPerMinute);
++    }
++
++    /// <summary>
++    /// Get how many messages tenant has sent in the current minute window.
++    /// </summary>
++    public int GetCurrentCount(int tenantId)
++    {
++        if (_windows.TryGetValue(tenantId, out var window))
++            return window.GetCurrentCount();
++        return 0;
++    }
++
++    private sealed class TenantWindow
++    {
++        private readonly object _lock = new();
++        private readonly Queue<DateTime> _timestamps = new();
++
++        public bool TryAcquire(int maxPerMinute)
++        {
++            lock (_lock)
++            {
++                PurgeOld();
++                if (_timestamps.Count >= maxPerMinute)
++                    return false;
++
++                _timestamps.Enqueue(DateTime.UtcNow);
++                return true;
++            }
++        }
++
++        public int GetCurrentCount()
++        {
++            lock (_lock)
++            {
++                PurgeOld();
++                return _timestamps.Count;
++            }
++        }
++
++        private void PurgeOld()
++        {
++            var cutoff = DateTime.UtcNow.AddMinutes(-1);
++            while (_timestamps.Count > 0 && _timestamps.Peek() < cutoff)
++                _timestamps.Dequeue();
++        }
++    }
++}
+diff --git a/src/Invekto.Outbound/Services/TemplateEngine.cs b/src/Invekto.Outbound/Services/TemplateEngine.cs
+new file mode 100644
+index 0000000..4fc7a3b
+--- /dev/null
++++ b/src/Invekto.Outbound/Services/TemplateEngine.cs
+@@ -0,0 +1,37 @@
++using Invekto.Shared.Logging;
++using Invekto.Shared.Services;
++
++namespace Invekto.Outbound.Services;
++
++/// <summary>
++/// Outbound-specific template engine wrapper.
++/// Delegates core {{variable}} substitution to shared TemplateSubstitution.
++/// Thread-safe, register as singleton.
++/// </summary>
++public sealed class TemplateEngine
++{
++    private readonly JsonLinesLogger _logger;
++
++    public TemplateEngine(JsonLinesLogger logger)
++    {
++        _logger = logger;
++    }
++
++    /// <summary>
++    /// Apply variables to a template string. Returns (result, missingVars).
++    /// If any variables are missing, the message is NOT sent (missingVars.Count > 0).
++    /// </summary>
++    public (string result, List<string> missingVars) Substitute(
++        string template, Dictionary<string, string>? variables)
++    {
++        return TemplateSubstitution.Substitute(template, variables);
++    }
++
++    /// <summary>
++    /// Extract all variable names from a template string.
++    /// </summary>
++    public static List<string> ExtractVariables(string template)
++    {
++        return TemplateSubstitution.ExtractVariables(template);
++    }
++}
+diff --git a/src/Invekto.Outbound/Services/TriggerProcessor.cs b/src/Invekto.Outbound/Services/TriggerProcessor.cs
+new file mode 100644
+index 0000000..3019f9b
+--- /dev/null
++++ b/src/Invekto.Outbound/Services/TriggerProcessor.cs
+@@ -0,0 +1,88 @@
++using Invekto.Outbound.Data;
++using Invekto.Shared.Constants;
++using Invekto.Shared.DTOs.Outbound;
++using Invekto.Shared.Logging;
++
++namespace Invekto.Outbound.Services;
++
++/// <summary>
++/// Processes trigger events from Main App webhooks.
++/// Finds matching template, applies variables, inserts single message.
++/// Thread-safe, register as singleton.
++/// </summary>
++public sealed class TriggerProcessor
++{
++    private readonly OutboundRepository _repository;
++    private readonly TemplateEngine _templateEngine;
++    private readonly OptOutManager _optOutManager;
++    private readonly JsonLinesLogger _logger;
++
++    public TriggerProcessor(
++        OutboundRepository repository,
++        TemplateEngine templateEngine,
++        OptOutManager optOutManager,
++        JsonLinesLogger logger)
++    {
++        _repository = repository;
++        _templateEngine = templateEngine;
++        _optOutManager = optOutManager;
++        _logger = logger;
++    }
++
++    /// <summary>
++    /// Process a trigger event. Returns response or error.
++    /// </summary>
++    public async Task<(TriggerWebhookResponse? response, string? errorCode, string? errorMessage, int statusCode)>
++        ProcessTriggerAsync(
++            int tenantId, TriggerWebhookRequest request, CancellationToken ct = default)
++    {
++        if (string.IsNullOrWhiteSpace(request.Event))
++            return (null, ErrorCodes.OutboundInvalidBroadcastPayload, "event is required", 400);
++
++        if (string.IsNullOrWhiteSpace(request.Phone))
++            return (null, ErrorCodes.OutboundInvalidBroadcastPayload, "phone is required", 400);
++
++        // Check opt-out
++        if (await _optOutManager.IsOptedOutAsync(tenantId, request.Phone, ct))
++        {
++            _logger.SystemInfo($"Trigger skipped (opted out): tenant={tenantId}, phone={request.Phone}, event={request.Event}");
++            return (null, ErrorCodes.OutboundRecipientOptedOut,
++                $"Recipient {request.Phone} has opted out of messages", 409);
++        }
++
++        // Find matching trigger template
++        var template = await _repository.GetTriggerTemplateAsync(tenantId, request.Event, ct);
++        if (template == null)
++        {
++            return (null, ErrorCodes.OutboundNoMatchingTriggerTemplate,
++                $"No active template found for event '{request.Event}' in tenant {tenantId}", 404);
++        }
++
++        // Apply template variables
++        var (messageText, missingVars) = _templateEngine.Substitute(
++            template.MessageTemplate, request.Variables);
++
++        if (missingVars.Count > 0)
++        {
++            _logger.SystemWarn(
++                $"Trigger template {template.Id} has missing variables: [{string.Join(", ", missingVars)}]");
++            return (null, ErrorCodes.OutboundInvalidBroadcastPayload,
++                $"Template requires variables: {string.Join(", ", missingVars)}", 400);
++        }
++
++        // Insert single message (no broadcast_id)
++        var messageId = await _repository.InsertMessageAsync(
++            tenantId, null, template.Id, request.Phone, messageText, ct);
++
++        _logger.SystemInfo(
++            $"Trigger message queued: id={messageId}, tenant={tenantId}, " +
++            $"event={request.Event}, phone={request.Phone}, template={template.Id}");
++
++        return (new TriggerWebhookResponse
++        {
++            MessageId = messageId,
++            TemplateId = template.Id,
++            TemplateName = template.Name
++        }, null, null, 202);
++    }
++}
+diff --git a/src/Invekto.Outbound/appsettings.json b/src/Invekto.Outbound/appsettings.json
+new file mode 100644
+index 0000000..490e373
+--- /dev/null
++++ b/src/Invekto.Outbound/appsettings.json
+@@ -0,0 +1,27 @@
++{
++  "Service": {
++    "ListenPort": 7107
++  },
++  "Logging": {
++    "FilePath": "logs"
++  },
++  "Jwt": {
++    "SecretKey": "",
++    "Issuer": null,
++    "Audience": null,
++    "ClockSkewSeconds": 60
++  },
++  "ConnectionStrings": {
++    "PostgreSQL": "Host=localhost;Port=5432;Database=invekto;Username=invekto;Password="
++  },
++  "RateLimit": {
++    "DefaultMessagesPerMinute": 30,
++    "SenderIntervalMs": 1000
++  },
++  "Callback": {
++    "DefaultCallbackUrl": "",
++    "MaxRetries": 3,
++    "BaseDelayMs": 500,
++    "TimeoutMs": 5000
++  }
++}
+diff --git a/src/Invekto.Shared/Constants/ErrorCodes.cs b/src/Invekto.Shared/Constants/ErrorCodes.cs
+index 9c5c16f..cf41acc 100644
+--- a/src/Invekto.Shared/Constants/ErrorCodes.cs
++++ b/src/Invekto.Shared/Constants/ErrorCodes.cs
+@@ -55,6 +55,18 @@ public static class ErrorCodes
+     public const string AgentAIClaudeTimeout = "INV-AA-005";
+     public const string AgentAIInvalidFeedback = "INV-AA-006";
+ 
++    // Outbound errors (INV-OB-xxx) -- GR-1.3
++    public const string OutboundInvalidBroadcastPayload = "INV-OB-001";
++    public const string OutboundTemplateNotFound = "INV-OB-002";
++    public const string OutboundRateLimitExceeded = "INV-OB-003";
++    public const string OutboundRecipientOptedOut = "INV-OB-004";
++    public const string OutboundBroadcastNotFound = "INV-OB-005";
++    public const string OutboundDeliveryStatusFailed = "INV-OB-006";
++    public const string OutboundInvalidTemplatePayload = "INV-OB-007";
++    public const string OutboundNoMatchingTriggerTemplate = "INV-OB-008";
++    public const string OutboundMessageSendCallbackFailed = "INV-OB-009";
++    public const string OutboundTooManyRecipients = "INV-OB-010";
++
+     // Database errors (INV-DB-xxx)
+     public const string DatabaseConnectionFailed = "INV-DB-001";
+     public const string DatabaseQueryTimeout = "INV-DB-002";
+diff --git a/src/Invekto.Shared/DTOs/Integration/OutgoingCallback.cs b/src/Invekto.Shared/DTOs/Integration/OutgoingCallback.cs
+index fa506e4..991eefa 100644
+--- a/src/Invekto.Shared/DTOs/Integration/OutgoingCallback.cs
++++ b/src/Invekto.Shared/DTOs/Integration/OutgoingCallback.cs
+@@ -77,6 +77,19 @@ public sealed class CallbackData
+     /// <summary>Error message when processing fails</summary>
+     [JsonPropertyName("error_message")]
+     public string? ErrorMessage { get; init; }
++
++    // GR-1.3 Outbound: fields for send_message callback
++    /// <summary>Recipient phone number (E.164 format) for outbound message delivery</summary>
++    [JsonPropertyName("phone")]
++    public string? Phone { get; init; }
++
++    /// <summary>Broadcast ID that this message belongs to (null for trigger-based)</summary>
++    [JsonPropertyName("broadcast_id")]
++    public Guid? BroadcastId { get; init; }
++
++    /// <summary>Outbound message record ID for delivery status correlation</summary>
++    [JsonPropertyName("outbound_message_id")]
++    public long? OutboundMessageId { get; init; }
+ }
+ 
+ /// <summary>
+diff --git a/src/Invekto.Shared/DTOs/Outbound/BroadcastDtos.cs b/src/Invekto.Shared/DTOs/Outbound/BroadcastDtos.cs
+new file mode 100644
+index 0000000..2205700
+--- /dev/null
++++ b/src/Invekto.Shared/DTOs/Outbound/BroadcastDtos.cs
+@@ -0,0 +1,85 @@
++using System.Text.Json.Serialization;
++
++namespace Invekto.Shared.DTOs.Outbound;
++
++/// <summary>
++/// POST /api/v1/broadcast/send request body.
++/// Main App sends recipients + template_id to start a broadcast.
++/// </summary>
++public sealed class BroadcastSendRequest
++{
++    [JsonPropertyName("template_id")]
++    public int TemplateId { get; set; }
++
++    [JsonPropertyName("recipients")]
++    public List<BroadcastRecipient> Recipients { get; set; } = new();
++
++    [JsonPropertyName("scheduled_at")]
++    public DateTime? ScheduledAt { get; set; }
++}
++
++public sealed class BroadcastRecipient
++{
++    [JsonPropertyName("phone")]
++    public string Phone { get; set; } = "";
++
++    [JsonPropertyName("variables")]
++    public Dictionary<string, string>? Variables { get; set; }
++}
++
++/// <summary>
++/// 202 Accepted response for broadcast send.
++/// </summary>
++public sealed class BroadcastSendResponse
++{
++    [JsonPropertyName("broadcast_id")]
++    public Guid BroadcastId { get; set; }
++
++    [JsonPropertyName("total_recipients")]
++    public int TotalRecipients { get; set; }
++
++    [JsonPropertyName("queued")]
++    public int Queued { get; set; }
++
++    [JsonPropertyName("skipped_optout")]
++    public int SkippedOptout { get; set; }
++}
++
++/// <summary>
++/// GET /api/v1/broadcast/{broadcastId}/status response.
++/// </summary>
++public sealed class BroadcastStatusResponse
++{
++    [JsonPropertyName("broadcast_id")]
++    public Guid BroadcastId { get; set; }
++
++    [JsonPropertyName("status")]
++    public string Status { get; set; } = "";
++
++    [JsonPropertyName("total_recipients")]
++    public int TotalRecipients { get; set; }
++
++    [JsonPropertyName("queued")]
++    public int Queued { get; set; }
++
++    [JsonPropertyName("sent")]
++    public int Sent { get; set; }
++
++    [JsonPropertyName("delivered")]
++    public int Delivered { get; set; }
++
++    [JsonPropertyName("read")]
++    public int Read { get; set; }
++
++    [JsonPropertyName("failed")]
++    public int Failed { get; set; }
++
++    [JsonPropertyName("created_at")]
++    public DateTime CreatedAt { get; set; }
++
++    [JsonPropertyName("started_at")]
++    public DateTime? StartedAt { get; set; }
++
++    [JsonPropertyName("completed_at")]
++    public DateTime? CompletedAt { get; set; }
++}
+diff --git a/src/Invekto.Shared/DTOs/Outbound/TemplateDtos.cs b/src/Invekto.Shared/DTOs/Outbound/TemplateDtos.cs
+new file mode 100644
+index 0000000..972d0c0
+--- /dev/null
++++ b/src/Invekto.Shared/DTOs/Outbound/TemplateDtos.cs
+@@ -0,0 +1,69 @@
++using System.Text.Json.Serialization;
++
++namespace Invekto.Shared.DTOs.Outbound;
++
++/// <summary>
++/// POST /api/v1/templates request body.
++/// </summary>
++public sealed class TemplateCreateRequest
++{
++    [JsonPropertyName("name")]
++    public string Name { get; set; } = "";
++
++    [JsonPropertyName("trigger_event")]
++    public string TriggerEvent { get; set; } = "manual";
++
++    [JsonPropertyName("message_template")]
++    public string MessageTemplate { get; set; } = "";
++
++    [JsonPropertyName("variables_json")]
++    public Dictionary<string, string>? VariablesJson { get; set; }
++}
++
++/// <summary>
++/// PUT /api/v1/templates/{id} request body. All fields optional.
++/// </summary>
++public sealed class TemplateUpdateRequest
++{
++    [JsonPropertyName("name")]
++    public string? Name { get; set; }
++
++    [JsonPropertyName("trigger_event")]
++    public string? TriggerEvent { get; set; }
++
++    [JsonPropertyName("message_template")]
++    public string? MessageTemplate { get; set; }
++
++    [JsonPropertyName("variables_json")]
++    public Dictionary<string, string>? VariablesJson { get; set; }
++}
++
++/// <summary>
++/// Template list item in GET /api/v1/templates response.
++/// </summary>
++public sealed class TemplateDto
++{
++    [JsonPropertyName("id")]
++    public int Id { get; set; }
++
++    [JsonPropertyName("name")]
++    public string Name { get; set; } = "";
++
++    [JsonPropertyName("trigger_event")]
++    public string TriggerEvent { get; set; } = "";
++
++    [JsonPropertyName("message_template")]
++    public string MessageTemplate { get; set; } = "";
++
++    [JsonPropertyName("variables_json")]
++    public Dictionary<string, string>? VariablesJson { get; set; }
++
++    [JsonPropertyName("is_active")]
++    public bool IsActive { get; set; }
++
++    [JsonPropertyName("created_at")]
++    public DateTime CreatedAt { get; set; }
++
++    [JsonPropertyName("updated_at")]
++    public DateTime UpdatedAt { get; set; }
++}
+diff --git a/src/Invekto.Shared/DTOs/Outbound/WebhookDtos.cs b/src/Invekto.Shared/DTOs/Outbound/WebhookDtos.cs
+new file mode 100644
+index 0000000..03f239f
+--- /dev/null
++++ b/src/Invekto.Shared/DTOs/Outbound/WebhookDtos.cs
+@@ -0,0 +1,102 @@
++using System.Text.Json.Serialization;
++
++namespace Invekto.Shared.DTOs.Outbound;
++
++/// <summary>
++/// POST /api/v1/webhook/trigger request - event from Main App triggers a template message.
++/// </summary>
++public sealed class TriggerWebhookRequest
++{
++    [JsonPropertyName("event")]
++    public string Event { get; set; } = "";
++
++    [JsonPropertyName("phone")]
++    public string Phone { get; set; } = "";
++
++    [JsonPropertyName("variables")]
++    public Dictionary<string, string>? Variables { get; set; }
++}
++
++/// <summary>
++/// 202 response for trigger webhook.
++/// </summary>
++public sealed class TriggerWebhookResponse
++{
++    [JsonPropertyName("message_id")]
++    public long MessageId { get; set; }
++
++    [JsonPropertyName("template_id")]
++    public int TemplateId { get; set; }
++
++    [JsonPropertyName("template_name")]
++    public string TemplateName { get; set; } = "";
++}
++
++/// <summary>
++/// POST /api/v1/webhook/delivery-status - delivery status from Main App.
++/// </summary>
++public sealed class DeliveryStatusRequest
++{
++    [JsonPropertyName("external_message_id")]
++    public string ExternalMessageId { get; set; } = "";
++
++    [JsonPropertyName("status")]
++    public string Status { get; set; } = "";
++
++    [JsonPropertyName("failed_reason")]
++    public string? FailedReason { get; set; }
++
++    [JsonPropertyName("timestamp")]
++    public DateTime? Timestamp { get; set; }
++}
++
++/// <summary>
++/// POST /api/v1/webhook/message - incoming message for opt-out detection.
++/// </summary>
++public sealed class IncomingMessageRequest
++{
++    [JsonPropertyName("phone")]
++    public string Phone { get; set; } = "";
++
++    [JsonPropertyName("message_text")]
++    public string MessageText { get; set; } = "";
++}
++
++/// <summary>
++/// Response for incoming message opt-out check.
++/// </summary>
++public sealed class IncomingMessageResponse
++{
++    [JsonPropertyName("opted_out")]
++    public bool OptedOut { get; set; }
++
++    [JsonPropertyName("keyword_matched")]
++    public string? KeywordMatched { get; set; }
++}
++
++/// <summary>
++/// POST /api/v1/optout request - manual opt-out add.
++/// </summary>
++public sealed class OptOutRequest
++{
++    [JsonPropertyName("phone")]
++    public string Phone { get; set; } = "";
++
++    [JsonPropertyName("reason")]
++    public string? Reason { get; set; }
++}
++
++/// <summary>
++/// GET /api/v1/optout/check/{phone} response.
++/// </summary>
++public sealed class OptOutCheckResponse
++{
++    [JsonPropertyName("phone")]
++    public string Phone { get; set; } = "";
++
++    [JsonPropertyName("opted_out")]
++    public bool OptedOut { get; set; }
++
++    [JsonPropertyName("opted_out_at")]
++    public DateTime? OptedOutAt { get; set; }
++}
+diff --git a/src/Invekto.Shared/Services/TemplateSubstitution.cs b/src/Invekto.Shared/Services/TemplateSubstitution.cs
+new file mode 100644
+index 0000000..1e8cb7a
+--- /dev/null
++++ b/src/Invekto.Shared/Services/TemplateSubstitution.cs
+@@ -0,0 +1,52 @@
++using System.Text.RegularExpressions;
++
++namespace Invekto.Shared.Services;
++
++/// <summary>
++/// Shared {{variable}} substitution utility.
++/// Used by Outbound (broadcast templates) and AgentAI (reply templates).
++/// Thread-safe static methods.
++/// </summary>
++public static class TemplateSubstitution
++{
++    private static readonly Regex VariablePattern = new(@"\{\{(\w+)\}\}", RegexOptions.Compiled);
++
++    /// <summary>
++    /// Substitute {{variable}} placeholders in template text.
++    /// Returns (result, missingVars). Missing variables are left as-is.
++    /// </summary>
++    public static (string result, List<string> missingVars) Substitute(
++        string template, Dictionary<string, string>? variables)
++    {
++        var missingVars = new List<string>();
++
++        if (string.IsNullOrEmpty(template))
++            return (template, missingVars);
++
++        var result = VariablePattern.Replace(template, match =>
++        {
++            var varName = match.Groups[1].Value;
++            if (variables != null && variables.TryGetValue(varName, out var value))
++                return value;
++
++            missingVars.Add(varName);
++            return match.Value;
++        });
++
++        return (result, missingVars);
++    }
++
++    /// <summary>
++    /// Extract all variable names from a template string.
++    /// </summary>
++    public static List<string> ExtractVariables(string template)
++    {
++        if (string.IsNullOrEmpty(template))
++            return new List<string>();
++
++        return VariablePattern.Matches(template)
++            .Select(m => m.Groups[1].Value)
++            .Distinct()
++            .ToList();
++    }
++}
diff --git a/arch/session-memory.md b/arch/session-memory.md
index f3808ae..7a14c3f 100644
--- a/arch/session-memory.md
+++ b/arch/session-memory.md
@@ -5,8 +5,8 @@
 ## Last Update
 
 - **Date:** 2026-02-12
-- **Status:** Ops tamamland─▒ - t├╝m servisler production'da ├ºal─▒┼ƒ─▒yor
-- **Last Task:** Production deploy do─ƒrulama. Backend:5000 (external OK), Automation:7108 (external OK), ChatAnalysis:7101 (localhost-only OK), AgentAI:7105 (localhost-only OK). Firewall kurallar─▒ tasar─▒ma uygun.
+- **Status:** GR-1.3 Outbound service implemented - Build PASS, /rev bekliyor
+- **Last Task:** Invekto.Outbound microservice (Port 7107) full implementation. Backend proxy (12 endpoints), deploy scripts updated, all arch files in sync.
 
 ---
 
@@ -50,6 +50,19 @@
   - API contract: `arch/contracts/agentai-suggest.json`
   - Error codes: INV-AA-001 ~ INV-AA-006
 
+- **GR-1.3 Outbound Service (Port 7107):**
+  - Broadcast/bulk messaging (max 1000 recipients, async queue)
+  - Event-based trigger engine (webhook -> template -> send)
+  - Template engine: `{{variable}}` substitution with missing var detection
+  - Tenant-based sliding window rate limiter (in-memory, configurable msg/min)
+  - Opt-out management (STOP/DUR/─░PTAL keyword detection)
+  - Delivery status tracking (sent/delivered/failed/read counters)
+  - Background IHostedService message sender (batch dequeue, FOR UPDATE SKIP LOCKED)
+  - Backend proxy pattern (Main App -> Backend:5000 -> Outbound:7107, localhost-only)
+  - DB schema: `arch/db/outbound.sql` (outbound_templates, outbound_broadcasts, outbound_messages, outbound_optouts)
+  - API contract: `arch/contracts/outbound-broadcast.json`
+  - Error codes: INV-OB-001 ~ INV-OB-010
+
 ### Tech Stack
 | Component | Technology |
 |-----------|------------|
@@ -65,7 +78,7 @@
 | ChatAnalysis | 7101 | Active |
 | AgentAI | 7105 | Implemented (GR-1.11) |
 | Integrations | 7106 | Reserved (Phase 2+) |
-| Outbound | 7107 | Reserved (Phase 1) |
+| Outbound | 7107 | Implemented (GR-1.3) |
 | Automation | 7108 | Implemented (GR-1.1) |
 | Simulator | 4500 | Dev-only tool (Node.js) |
 
@@ -73,11 +86,11 @@
 - **Script:** `dev-to-invekto-services.bat`
 - **Protokol:** FTPES (explicit TLS)
 - **FTP Host:** services.invekto.com
-- **Sunucu Yapi:** `E:\Invekto\Backend\current\`, `E:\Invekto\ChatAnalysis\current\`, `E:\Invekto\Automation\current\`, `E:\Invekto\AgentAI\current\`
+- **Sunucu Yapi:** `E:\Invekto\Backend\current\`, `E:\Invekto\ChatAnalysis\current\`, `E:\Invekto\Automation\current\`, `E:\Invekto\AgentAI\current\`, `E:\Invekto\Outbound\current\`
 - **Sunucu Domain:** services.invekto.com
 - **Sunucu Root:** `E:\Invekto\` (Backend, ChatAnalysis, scripts, logs)
 - **Service Manager:** NSSM (`E:\nssm.exe`)
-- **Servisler:** InvektoBackend, InvektoChatAnalysis, InvektoAutomation, InvektoAgentAI, InvektoDeployWatcher (auto-start, auto-restart)
+- **Servisler:** InvektoBackend, InvektoChatAnalysis, InvektoAutomation, InvektoAgentAI, InvektoOutbound, InvektoDeployWatcher (auto-start, auto-restart)
 - **Deploy Watcher:** `E:\Invekto\scripts\deploy-watcher.ps1` (flag-based stop/start)
 - **.NET Runtime:** ASP.NET Core 8.0.23 (`C:\Program Files\dotnet`)
 - **PostgreSQL:** localhost:5432 / invekto DB (pgAdmin ile yonetim)
@@ -102,7 +115,7 @@
 - [x] ~~Q: agentai.sql calistir~~ (Tamamlandi)
 - [x] ~~Q: AgentAI appsettings.Production.json doldur~~ (Tamamlandi)
 - [x] ~~Q: AgentAI deploy + Windows Service kurulumu~~ (Tamamlandi - InvektoAgentAI SERVICE_RUNNING)
-- [ ] **GR-1.3 Outbound Service** (Port 7107) - Broadcast, trigger, template engine, rate limiting
+- [x] ~~GR-1.3 Outbound Service~~ (Tamamlandi - Port 7107, Build PASS, /rev bekliyor)
 
 ### Known Issues
 - (Hen├╝z yok)
@@ -131,6 +144,10 @@
 | 2026-02-11 | Per-agent feedback learning | Son 20 interaction Claude prompt'a enjekte, kisisel oneri |
 | 2026-02-11 | Async feedback (fire-and-forget) | Agent accept/edit/reject sonrasi POST, response beklenmez |
 | 2026-02-11 | Backend proxy for simulator | Tum simulator trafigi Backend:5000 uzerinden, internal servisler localhost-only |
+| 2026-02-12 | Outbound ayri mikroservis | Broadcast + trigger engine, Port 7107, Backend proxy pattern |
+| 2026-02-12 | In-memory rate limiter | Tenant bazli sliding window, queue (reject degil), configurable msg/min |
+| 2026-02-12 | FOR UPDATE SKIP LOCKED | Message dequeue icin safe concurrency, batch 10 |
+| 2026-02-12 | Stop keyword detection | STOP, DUR, IPTAL, CIKIS - exact match on trimmed uppercase |
 
 ---
 
@@ -145,6 +162,7 @@ src/
 Γöé   Γö£ΓöÇΓöÇ DTOs/
 Γöé   Γöé   Γö£ΓöÇΓöÇ AgentAI/          # GR-1.11: Suggest/Feedback DTOs
 Γöé   Γöé   Γö£ΓöÇΓöÇ ChatAnalysis/
+Γöé   Γöé   Γö£ΓöÇΓöÇ Outbound/          # GR-1.3: Broadcast/Template/Webhook DTOs
 Γöé   Γöé   ΓööΓöÇΓöÇ Integration/      # GR-1.9: Webhook/Callback DTOs
 Γöé   Γö£ΓöÇΓöÇ Integration/          # GR-1.9: Callback client
 Γöé   ΓööΓöÇΓöÇ Logging/
@@ -157,10 +175,14 @@ src/
 Γöé   Γö£ΓöÇΓöÇ Data/                # AutomationRepository
 Γöé   Γö£ΓöÇΓöÇ Middleware/           # Traffic logging + JWT auth
 Γöé   ΓööΓöÇΓöÇ Services/            # FlowEngine, IntentDetector, FaqMatcher, WorkingHoursChecker, AutomationOrchestrator
+Γö£ΓöÇΓöÇ Invekto.Outbound/         # GR-1.3: Broadcast & Trigger Engine (Port 7107)
+Γöé   Γö£ΓöÇΓöÇ Data/                # OutboundRepository
+Γöé   Γö£ΓöÇΓöÇ Middleware/           # Traffic logging + JWT auth
+Γöé   ΓööΓöÇΓöÇ Services/            # BroadcastOrchestrator, TriggerProcessor, MessageSenderService, TemplateEngine, OptOutManager, RateLimiter
 ΓööΓöÇΓöÇ Invekto.Backend/          # Backend API (Port 5000)
     Γö£ΓöÇΓöÇ Dashboard/            # React/TS Ops Dashboard
     Γö£ΓöÇΓöÇ Middleware/            # Traffic logging + JWT auth
-    ΓööΓöÇΓöÇ Services/             # ChatAnalysisClient, AutomationClient, AgentAIClient
+    ΓööΓöÇΓöÇ Services/             # ChatAnalysisClient, AutomationClient, AgentAIClient, OutboundClient
 ```
 
 ---
@@ -168,13 +190,13 @@ src/
 ## Context for Next Session
 
 Sonraki session'da:
-1. **GR-1.3 Invekto.Outbound** mikroservisi (Port 7107) implement et
-2. Scope: Broadcast/toplu mesaj, trigger engine, template engine, rate limiting, opt-out, delivery tracking
-3. DB tablolari: outbound_templates, outbound_messages, outbound_optouts (roadmap-phases.md'de tanimli)
-4. Mimari: Backend proxy pattern (Main App -> Backend:5000 -> Outbound:7107, localhost-only)
-5. Mevcut pattern'leri takip et: Automation + AgentAI servisleri referans
-6. Firewall: localhost-only (remoteip=127.0.0.1) - Backend proxy uzerinden erisim
-7. Deploy sonrasi: outbound.sql calistir, appsettings.Production.json doldur, NSSM servis kur
+1. **GR-1.3 Outbound /rev tamamla** - Codex review prompt gonder, PASS/FAIL bekle
+2. Deploy sonrasi Q'nun yapacaklari:
+   - `outbound.sql` calistir (PostgreSQL'de tablolari olustur)
+   - `appsettings.Production.json` doldur (JWT key, PostgreSQL connection, callback URL)
+   - NSSM servis kur: `install-services.bat` (veya manual InvektoOutbound)
+   - Firewall: Port 7107 localhost-only (zaten firewall-rules.bat'a eklendi)
+3. Test: `http://localhost:7107/health` (Outbound direkt) veya `http://services.invekto.com:5000/api/v1/outbound/health` (Backend proxy)
 
 ---
 
diff --git a/dev-to-invekto-services.bat b/dev-to-invekto-services.bat
index 3d91641..54fb911 100644
--- a/dev-to-invekto-services.bat
+++ b/dev-to-invekto-services.bat
@@ -27,6 +27,7 @@ set "REMOTE_BACKEND=/e/Invekto/Backend/current"
 set "REMOTE_CHATANALYSIS=/e/Invekto/ChatAnalysis/current"
 set "REMOTE_AUTOMATION=/e/Invekto/Automation/current"
 set "REMOTE_AGENTAI=/e/Invekto/AgentAI/current"
+set "REMOTE_OUTBOUND=/e/Invekto/Outbound/current"
 set "REMOTE_SIMULATOR=/e/Invekto/Simulator"
 
 REM Local paths
@@ -36,6 +37,7 @@ set "LOCAL_BACKEND=%LOCAL_DEPLOY%\Backend"
 set "LOCAL_CHATANALYSIS=%LOCAL_DEPLOY%\ChatAnalysis"
 set "LOCAL_AUTOMATION=%LOCAL_DEPLOY%\Automation"
 set "LOCAL_AGENTAI=%LOCAL_DEPLOY%\AgentAI"
+set "LOCAL_OUTBOUND=%LOCAL_DEPLOY%\Outbound"
 set "LOCAL_SIMULATOR=%~dp0tools\simulator"
 
 REM Check WinSCP exists
@@ -51,6 +53,7 @@ if not exist "!LOCAL_BACKEND!" mkdir "!LOCAL_BACKEND!"
 if not exist "!LOCAL_CHATANALYSIS!" mkdir "!LOCAL_CHATANALYSIS!"
 if not exist "!LOCAL_AUTOMATION!" mkdir "!LOCAL_AUTOMATION!"
 if not exist "!LOCAL_AGENTAI!" mkdir "!LOCAL_AGENTAI!"
+if not exist "!LOCAL_OUTBOUND!" mkdir "!LOCAL_OUTBOUND!"
 
 echo ============================================
 echo [1/5] Building Backend...
@@ -105,10 +108,23 @@ if errorlevel 1 (
 echo [OK] AgentAI built to !LOCAL_AGENTAI!
 echo.
 
+echo ============================================
+echo [5/5] Building Outbound...
+echo ============================================
+echo.
+
+dotnet publish src/Invekto.Outbound/Invekto.Outbound.csproj -c Release -o "!LOCAL_OUTBOUND!" --self-contained false
+if errorlevel 1 (
+    echo [ERROR] Outbound build failed!
+    goto :error_exit
+)
+echo [OK] Outbound built to !LOCAL_OUTBOUND!
+echo.
+
 REM Q: Create build marker
 for /f "tokens=*" %%i in ('git rev-parse --short HEAD 2^>nul') do set "GIT_HASH=%%i"
 for /f "tokens=*" %%i in ('git rev-parse --abbrev-ref HEAD 2^>nul') do set "GIT_BRANCH=%%i"
-powershell -NoProfile -Command "$marker = @{ timestamp = (Get-Date).ToString('o'); gitHash = '%GIT_HASH%'; gitBranch = '%GIT_BRANCH%'; services = @('Backend','ChatAnalysis','Automation','AgentAI') }; [System.IO.File]::WriteAllText('!LOCAL_DEPLOY!\.build-marker.json', ($marker | ConvertTo-Json))"
+powershell -NoProfile -Command "$marker = @{ timestamp = (Get-Date).ToString('o'); gitHash = '%GIT_HASH%'; gitBranch = '%GIT_BRANCH%'; services = @('Backend','ChatAnalysis','Automation','AgentAI','Outbound') }; [System.IO.File]::WriteAllText('!LOCAL_DEPLOY!\.build-marker.json', ($marker | ConvertTo-Json))"
 echo [OK] Build marker created (%GIT_BRANCH%@%GIT_HASH%)
 echo.
 
@@ -147,10 +163,12 @@ echo Local Backend:      !LOCAL_BACKEND!
 echo Local ChatAnalysis: !LOCAL_CHATANALYSIS!
 echo Local Automation:   !LOCAL_AUTOMATION!
 echo Local AgentAI:      !LOCAL_AGENTAI!
+echo Local Outbound:     !LOCAL_OUTBOUND!
 echo Remote Backend:     %REMOTE_BACKEND%
 echo Remote ChatAnalysis: %REMOTE_CHATANALYSIS%
 echo Remote Automation:  %REMOTE_AUTOMATION%
 echo Remote AgentAI:     %REMOTE_AGENTAI%
+echo Remote Outbound:    %REMOTE_OUTBOUND%
 echo.
 echo Mode: Synchronize (only changed files)
 
@@ -167,6 +185,7 @@ set "WINSCP_SCRIPT=%TEMP%\winscp_invekto_deploy.txt"
     echo mkdir "%REMOTE_CHATANALYSIS%"
     echo mkdir "%REMOTE_AUTOMATION%"
     echo mkdir "%REMOTE_AGENTAI%"
+    echo mkdir "%REMOTE_OUTBOUND%"
     echo mkdir "%REMOTE_SIMULATOR%"
     echo option batch abort
     echo echo Uploading Backend to STAGING...
@@ -177,6 +196,8 @@ set "WINSCP_SCRIPT=%TEMP%\winscp_invekto_deploy.txt"
     echo synchronize remote "!LOCAL_AUTOMATION!" "%REMOTE_AUTOMATION%" -mirror -transfer=binary -criteria=size,time -resumesupport=on -filemask="|appsettings.Production.json"
     echo echo Uploading AgentAI to STAGING...
     echo synchronize remote "!LOCAL_AGENTAI!" "%REMOTE_AGENTAI%" -mirror -transfer=binary -criteria=size,time -resumesupport=on -filemask="|appsettings.Production.json"
+    echo echo Uploading Outbound to STAGING...
+    echo synchronize remote "!LOCAL_OUTBOUND!" "%REMOTE_OUTBOUND%" -mirror -transfer=binary -criteria=size,time -resumesupport=on -filemask="|appsettings.Production.json"
     echo echo Uploading Simulator to STAGING...
     echo synchronize remote "!LOCAL_SIMULATOR!" "%REMOTE_SIMULATOR%" -mirror -transfer=binary -criteria=size,time -resumesupport=on -filemask="|node_modules/;.env"
     echo echo Uploading build marker...
@@ -246,6 +267,7 @@ echo   Backend:      %REMOTE_BACKEND%
 echo   ChatAnalysis: %REMOTE_CHATANALYSIS%
 echo   Automation:   %REMOTE_AUTOMATION%
 echo   AgentAI:      %REMOTE_AGENTAI%
+echo   Outbound:     %REMOTE_OUTBOUND%
 echo   Simulator:    %REMOTE_SIMULATOR%
 echo.
 echo ============================================
diff --git a/src/Invekto.AgentAI/Services/TemplateEngine.cs b/src/Invekto.AgentAI/Services/TemplateEngine.cs
index f06bfab..49e52e8 100644
--- a/src/Invekto.AgentAI/Services/TemplateEngine.cs
+++ b/src/Invekto.AgentAI/Services/TemplateEngine.cs
@@ -1,15 +1,17 @@
-using System.Text.RegularExpressions;
 using Invekto.Shared.Logging;
+using Invekto.Shared.Services;
 
 namespace Invekto.AgentAI.Services;
 
-public sealed partial class TemplateEngine
+/// <summary>
+/// AgentAI-specific template engine.
+/// Delegates core {{variable}} substitution to shared TemplateSubstitution.
+/// Adds HTML sanitization for agent-facing content safety.
+/// </summary>
+public sealed class TemplateEngine
 {
     private readonly JsonLinesLogger _logger;
 
-    [GeneratedRegex(@"\{\{(\w+)\}\}", RegexOptions.Compiled)]
-    private static partial Regex VariablePattern();
-
     public TemplateEngine(JsonLinesLogger logger)
     {
         _logger = logger;
@@ -17,23 +19,26 @@ public sealed partial class TemplateEngine
 
     /// <summary>
     /// Replaces {{variable}} placeholders in text with provided values.
-    /// Missing variables are left as-is (not removed, not crashed).
+    /// Values are HTML-sanitized. Missing variables are left as-is.
     /// </summary>
     public string Substitute(string text, Dictionary<string, string>? variables)
     {
         if (string.IsNullOrEmpty(text) || variables == null || variables.Count == 0)
             return text;
 
-        return VariablePattern().Replace(text, match =>
+        // Pre-sanitize values for HTML safety before substitution
+        var sanitized = new Dictionary<string, string>(variables.Count);
+        foreach (var kvp in variables)
         {
-            var varName = match.Groups[1].Value;
-            if (variables.TryGetValue(varName, out var value))
-                return SanitizeValue(value) ?? match.Value;
+            sanitized[kvp.Key] = SanitizeValue(kvp.Value) ?? kvp.Value;
+        }
+
+        var (result, missingVars) = TemplateSubstitution.Substitute(text, sanitized);
 
-            // Missing variable -- leave placeholder, log warning
+        foreach (var varName in missingVars)
             _logger.SystemWarn($"Template variable '{{{{{varName}}}}}' not found in provided variables");
-            return match.Value;
-        });
+
+        return result;
     }
 
     /// <summary>
diff --git a/src/Invekto.Backend/Program.cs b/src/Invekto.Backend/Program.cs
index 5e9fc0a..efb6fe7 100644
--- a/src/Invekto.Backend/Program.cs
+++ b/src/Invekto.Backend/Program.cs
@@ -29,6 +29,10 @@ var agentAIUrl = builder.Configuration["Microservice:AgentAI:Url"]
     ?? $"http://localhost:{ServiceConstants.AgentAIPort}";
 var agentAILogPath = builder.Configuration["Microservice:AgentAI:LogPath"];
 var agentAISuggestTimeoutMs = builder.Configuration.GetValue<int>("Microservice:AgentAI:SuggestTimeoutMs", 15000);
+var outboundUrl = builder.Configuration["Microservice:Outbound:Url"]
+    ?? $"http://localhost:{ServiceConstants.OutboundPort}";
+var outboundLogPath = builder.Configuration["Microservice:Outbound:LogPath"];
+var outboundTimeoutMs = builder.Configuration.GetValue<int>("Microservice:Outbound:TimeoutMs", 10000);
 
 // Register JSON Lines logger
 builder.Services.AddSingleton(new JsonLinesLogger(ServiceConstants.BackendServiceName, logPath));
@@ -47,6 +51,10 @@ if (!string.IsNullOrEmpty(agentAILogPath))
 {
     logPaths.Add(agentAILogPath);
 }
+if (!string.IsNullOrEmpty(outboundLogPath))
+{
+    logPaths.Add(outboundLogPath);
+}
 builder.Services.AddSingleton(new LogReader(logPaths.ToArray(), slowThresholdMs));
 
 // Register log cleanup service (30 day retention)
@@ -80,6 +88,13 @@ builder.Services.AddHttpClient<AgentAIClient>(client =>
     client.Timeout = TimeSpan.FromMilliseconds(agentAISuggestTimeoutMs);
 });
 
+// Configure Outbound HTTP client (GR-1.3)
+builder.Services.AddHttpClient<OutboundClient>(client =>
+{
+    client.BaseAddress = new Uri(outboundUrl);
+    client.Timeout = TimeSpan.FromMilliseconds(outboundTimeoutMs);
+});
+
 // ============================================
 // GR-1.9: INTEGRATION BRIDGE SETUP
 // ============================================
@@ -133,7 +148,7 @@ app.UseTrafficLogging();
 if (jwtValidator != null)
 {
     var jwtLogger = app.Services.GetRequiredService<JsonLinesLogger>();
-    app.UseJwtAuth(jwtValidator, jwtLogger, "/api/v1/webhook/", "/api/v1/automation/");
+    app.UseJwtAuth(jwtValidator, jwtLogger, "/api/v1/webhook/", "/api/v1/automation/", "/api/v1/outbound/");
 }
 
 // Enable static file serving for Dashboard UI (wwwroot/)
@@ -171,7 +186,7 @@ bool ValidateOpsAuth(HttpContext ctx)
 }
 
 // OPS endpoint - Stage-0 troubleshooting dashboard
-app.MapGet("/ops", async (HttpContext ctx, ChatAnalysisClient chatClient, AutomationClient automationClient, AgentAIClient agentAIClient, LogReader logReader) =>
+app.MapGet("/ops", async (HttpContext ctx, ChatAnalysisClient chatClient, AutomationClient automationClient, AgentAIClient agentAIClient, OutboundClient outboundClient, LogReader logReader) =>
 {
     if (!ValidateOpsAuth(ctx))
     {
@@ -182,6 +197,7 @@ app.MapGet("/ops", async (HttpContext ctx, ChatAnalysisClient chatClient, Automa
     var chatHealthy = await chatClient.CheckHealthAsync();
     var autoHealthy = await automationClient.CheckHealthAsync();
     var agentAIHealthy = await agentAIClient.CheckHealthAsync();
+    var outboundHealthy = await outboundClient.CheckHealthAsync();
 
     var ops = new
     {
@@ -192,7 +208,8 @@ app.MapGet("/ops", async (HttpContext ctx, ChatAnalysisClient chatClient, Automa
             backend = new { status = "ok" },
             chatAnalysis = new { status = chatHealthy ? "ok" : "unavailable" },
             automation = new { status = autoHealthy ? "ok" : "unavailable" },
-            agentAI = new { status = agentAIHealthy ? "ok" : "unavailable" }
+            agentAI = new { status = agentAIHealthy ? "ok" : "unavailable" },
+            outbound = new { status = outboundHealthy ? "ok" : "unavailable" }
         },
         info = new
         {
@@ -355,7 +372,7 @@ app.MapGet("/ops/search", async (HttpContext ctx, LogReader logReader, string? r
 // ============================================
 
 // Dashboard: Service health with response times
-app.MapGet("/api/ops/health", async (HttpContext ctx, ChatAnalysisClient chatClient, AutomationClient automationClient, AgentAIClient agentAIClient) =>
+app.MapGet("/api/ops/health", async (HttpContext ctx, ChatAnalysisClient chatClient, AutomationClient automationClient, AgentAIClient agentAIClient, OutboundClient outboundClient) =>
 {
     if (!ValidateOpsAuth(ctx))
     {
@@ -372,7 +389,7 @@ app.MapGet("/api/ops/health", async (HttpContext ctx, ChatAnalysisClient chatCli
         name = ServiceConstants.BackendServiceName,
         status = "ok",
         responseTimeMs = 0,
-        uptimeSeconds = (long?)null, // Not tracked
+        uptimeSeconds = (long?)null,
         lastCheck = now
     });
 
@@ -386,7 +403,7 @@ app.MapGet("/api/ops/health", async (HttpContext ctx, ChatAnalysisClient chatCli
         name = ServiceConstants.ChatAnalysisServiceName,
         status = chatHealthy ? "ok" : "unavailable",
         responseTimeMs = chatHealthy ? (int?)sw.ElapsedMilliseconds : null,
-        uptimeSeconds = (long?)null, // Not tracked
+        uptimeSeconds = (long?)null,
         lastCheck = now,
         error = chatHealthy ? null : "Service unreachable"
     });
@@ -421,6 +438,21 @@ app.MapGet("/api/ops/health", async (HttpContext ctx, ChatAnalysisClient chatCli
         error = agentAIHealthy ? null : "Service unreachable"
     });
 
+    // Outbound - check health with timing (GR-1.3)
+    var swOutbound = System.Diagnostics.Stopwatch.StartNew();
+    var outboundHealthy = await outboundClient.CheckHealthAsync();
+    swOutbound.Stop();
+
+    services.Add(new
+    {
+        name = ServiceConstants.OutboundServiceName,
+        status = outboundHealthy ? "ok" : "unavailable",
+        responseTimeMs = outboundHealthy ? (int?)swOutbound.ElapsedMilliseconds : null,
+        uptimeSeconds = (long?)null,
+        lastCheck = now,
+        error = outboundHealthy ? null : "Service unreachable"
+    });
+
     return Results.Ok(new
     {
         timestamp = now,
@@ -570,6 +602,7 @@ app.MapPost("/api/ops/services/{serviceName}/restart", async (HttpContext ctx, s
         "Invekto.ChatAnalysis" => "Invekto.Microservice.Chat",
         "Invekto.Automation" => "InvektoAutomation",
         "Invekto.AgentAI" => "InvektoAgentAI",
+        "Invekto.Outbound" => "InvektoOutbound",
         _ => null
     };
 
@@ -623,7 +656,7 @@ app.MapPost("/api/ops/services/{serviceName}/restart", async (HttpContext ctx, s
 });
 
 // Dashboard: Test proxy for external services (avoids CORS issues)
-app.MapGet("/api/ops/test/{serviceName}/{*path}", async (HttpContext ctx, ChatAnalysisClient chatClient, AutomationClient automationClient, AgentAIClient agentAIClient, string serviceName, string? path) =>
+app.MapGet("/api/ops/test/{serviceName}/{*path}", async (HttpContext ctx, ChatAnalysisClient chatClient, AutomationClient automationClient, AgentAIClient agentAIClient, OutboundClient outboundClient, string serviceName, string? path) =>
 {
     if (!ValidateOpsAuth(ctx))
     {
@@ -680,6 +713,21 @@ app.MapGet("/api/ops/test/{serviceName}/{*path}", async (HttpContext ctx, ChatAn
             });
         }
 
+        if (serviceName == "outbound")
+        {
+            var endpoint = "/" + (path ?? "health");
+            var result = await outboundClient.TestEndpointAsync(endpoint);
+            sw.Stop();
+
+            return Results.Ok(new
+            {
+                success = result.Success,
+                statusCode = result.StatusCode,
+                durationMs = sw.ElapsedMilliseconds,
+                message = result.Message
+            });
+        }
+
         return Results.BadRequest(new { success = false, message = "Unknown service" });
     }
     catch (Exception ex)
@@ -905,7 +953,7 @@ app.MapPost("/api/v1/chat/analyze", async (
 });
 
 // Endpoint discovery - returns all services' endpoints (aggregated)
-app.MapGet("/api/ops/endpoints", async (HttpContext ctx, ChatAnalysisClient chatClient, AutomationClient automationClient, AgentAIClient agentAIClient) =>
+app.MapGet("/api/ops/endpoints", async (HttpContext ctx, ChatAnalysisClient chatClient, AutomationClient automationClient, AgentAIClient agentAIClient, OutboundClient outboundClient) =>
 {
     if (!ValidateOpsAuth(ctx))
     {
@@ -929,6 +977,19 @@ app.MapGet("/api/ops/endpoints", async (HttpContext ctx, ChatAnalysisClient chat
             new() { Method = "POST", Path = "/api/v1/agent-assist/feedback", Description = "Agent feedback proxy (Backend -> AgentAI)", Auth = "Bearer", Category = "API" },
             // Automation proxy endpoint
             new() { Method = "POST", Path = "/api/v1/automation/webhook", Description = "Webhook event proxy (Backend -> Automation)", Auth = "Bearer", Category = "API" },
+            // Outbound proxy endpoints (GR-1.3)
+            new() { Method = "POST", Path = "/api/v1/outbound/broadcast/send", Description = "Broadcast send proxy (Backend -> Outbound)", Auth = "Bearer", Category = "API" },
+            new() { Method = "GET", Path = "/api/v1/outbound/broadcast/{broadcastId}/status", Description = "Broadcast status proxy", Auth = "Bearer", Category = "API" },
+            new() { Method = "POST", Path = "/api/v1/outbound/webhook/trigger", Description = "Trigger event proxy", Auth = "Bearer", Category = "API" },
+            new() { Method = "POST", Path = "/api/v1/outbound/webhook/delivery-status", Description = "Delivery status proxy", Auth = "Bearer", Category = "API" },
+            new() { Method = "POST", Path = "/api/v1/outbound/webhook/message", Description = "Incoming message proxy (opt-out)", Auth = "Bearer", Category = "API" },
+            new() { Method = "GET", Path = "/api/v1/outbound/templates", Description = "List templates proxy", Auth = "Bearer", Category = "API" },
+            new() { Method = "POST", Path = "/api/v1/outbound/templates", Description = "Create template proxy", Auth = "Bearer", Category = "API" },
+            new() { Method = "PUT", Path = "/api/v1/outbound/templates/{id}", Description = "Update template proxy", Auth = "Bearer", Category = "API" },
+            new() { Method = "DELETE", Path = "/api/v1/outbound/templates/{id}", Description = "Deactivate template proxy", Auth = "Bearer", Category = "API" },
+            new() { Method = "POST", Path = "/api/v1/outbound/optout", Description = "Add opt-out proxy", Auth = "Bearer", Category = "API" },
+            new() { Method = "DELETE", Path = "/api/v1/outbound/optout/{phone}", Description = "Remove opt-out proxy", Auth = "Bearer", Category = "API" },
+            new() { Method = "GET", Path = "/api/v1/outbound/optout/check/{phone}", Description = "Check opt-out proxy", Auth = "Bearer", Category = "API" },
 
             // Health
             new() { Method = "GET", Path = "/health", Description = "Health check", Auth = "none", Category = "Health" },
@@ -963,6 +1024,9 @@ app.MapGet("/api/ops/endpoints", async (HttpContext ctx, ChatAnalysisClient chat
     // Fetch AgentAI endpoints (internal call)
     var agentAIEndpoints = await agentAIClient.GetEndpointsAsync();
 
+    // Fetch Outbound endpoints (internal call, GR-1.3)
+    var outboundEndpoints = await outboundClient.GetEndpointsAsync();
+
     var services = new List<EndpointDiscoveryResponse> { backendEndpoints };
     if (chatEndpoints != null)
     {
@@ -976,6 +1040,10 @@ app.MapGet("/api/ops/endpoints", async (HttpContext ctx, ChatAnalysisClient chat
     {
         services.Add(agentAIEndpoints);
     }
+    if (outboundEndpoints != null)
+    {
+        services.Add(outboundEndpoints);
+    }
 
     return Results.Ok(new { services });
 });
@@ -1275,6 +1343,115 @@ app.MapPost("/api/v1/automation/webhook", async (HttpContext ctx, AutomationClie
     return Results.Empty;
 });
 
+// ============================================
+// OUTBOUND PROXY ENDPOINTS (GR-1.3)
+// ============================================
+
+// Generic outbound proxy helper
+async Task<IResult> OutboundProxyPost(HttpContext ctx, OutboundClient obClient, JsonLinesLogger jsonLog, string targetPath)
+{
+    var requestId = ctx.Request.Headers["X-Request-Id"].FirstOrDefault() ?? Guid.NewGuid().ToString("N");
+    var authHeader = ctx.Request.Headers.Authorization.FirstOrDefault();
+
+    string requestBody;
+    using (var reader = new StreamReader(ctx.Request.Body))
+        requestBody = await reader.ReadToEndAsync();
+
+    var sw = System.Diagnostics.Stopwatch.StartNew();
+    var (statusCode, body) = await obClient.ProxyPostAsync(targetPath, requestBody, authHeader, requestId);
+    sw.Stop();
+
+    jsonLog.StepInfo($"Outbound proxy POST {targetPath}: status={statusCode}, time={sw.ElapsedMilliseconds}ms", requestId);
+
+    ctx.Response.StatusCode = statusCode;
+    ctx.Response.ContentType = "application/json";
+    if (body != null) await ctx.Response.WriteAsync(body);
+    return Results.Empty;
+}
+
+async Task<IResult> OutboundProxyGet(HttpContext ctx, OutboundClient obClient, JsonLinesLogger jsonLog, string targetPath)
+{
+    var requestId = ctx.Request.Headers["X-Request-Id"].FirstOrDefault() ?? Guid.NewGuid().ToString("N");
+    var authHeader = ctx.Request.Headers.Authorization.FirstOrDefault();
+
+    var (statusCode, body) = await obClient.ProxyGetAsync(targetPath, authHeader, requestId);
+
+    ctx.Response.StatusCode = statusCode;
+    ctx.Response.ContentType = "application/json";
+    if (body != null) await ctx.Response.WriteAsync(body);
+    return Results.Empty;
+}
+
+async Task<IResult> OutboundProxyPut(HttpContext ctx, OutboundClient obClient, JsonLinesLogger jsonLog, string targetPath)
+{
+    var requestId = ctx.Request.Headers["X-Request-Id"].FirstOrDefault() ?? Guid.NewGuid().ToString("N");
+    var authHeader = ctx.Request.Headers.Authorization.FirstOrDefault();
+
+    string requestBody;
+    using (var reader = new StreamReader(ctx.Request.Body))
+        requestBody = await reader.ReadToEndAsync();
+
+    var (statusCode, body) = await obClient.ProxyPutAsync(targetPath, requestBody, authHeader, requestId);
+
+    ctx.Response.StatusCode = statusCode;
+    ctx.Response.ContentType = "application/json";
+    if (body != null) await ctx.Response.WriteAsync(body);
+    return Results.Empty;
+}
+
+async Task<IResult> OutboundProxyDelete(HttpContext ctx, OutboundClient obClient, JsonLinesLogger jsonLog, string targetPath)
+{
+    var requestId = ctx.Request.Headers["X-Request-Id"].FirstOrDefault() ?? Guid.NewGuid().ToString("N");
+    var authHeader = ctx.Request.Headers.Authorization.FirstOrDefault();
+
+    var (statusCode, body) = await obClient.ProxyDeleteAsync(targetPath, authHeader, requestId);
+
+    ctx.Response.StatusCode = statusCode;
+    ctx.Response.ContentType = "application/json";
+    if (body != null) await ctx.Response.WriteAsync(body);
+    return Results.Empty;
+}
+
+// Broadcast
+app.MapPost("/api/v1/outbound/broadcast/send", async (HttpContext ctx, OutboundClient obClient, JsonLinesLogger jsonLog) =>
+    await OutboundProxyPost(ctx, obClient, jsonLog, "/api/v1/broadcast/send"));
+
+app.MapGet("/api/v1/outbound/broadcast/{broadcastId}/status", async (HttpContext ctx, OutboundClient obClient, JsonLinesLogger jsonLog, string broadcastId) =>
+    await OutboundProxyGet(ctx, obClient, jsonLog, $"/api/v1/broadcast/{broadcastId}/status"));
+
+// Webhooks
+app.MapPost("/api/v1/outbound/webhook/trigger", async (HttpContext ctx, OutboundClient obClient, JsonLinesLogger jsonLog) =>
+    await OutboundProxyPost(ctx, obClient, jsonLog, "/api/v1/webhook/trigger"));
+
+app.MapPost("/api/v1/outbound/webhook/delivery-status", async (HttpContext ctx, OutboundClient obClient, JsonLinesLogger jsonLog) =>
+    await OutboundProxyPost(ctx, obClient, jsonLog, "/api/v1/webhook/delivery-status"));
+
+app.MapPost("/api/v1/outbound/webhook/message", async (HttpContext ctx, OutboundClient obClient, JsonLinesLogger jsonLog) =>
+    await OutboundProxyPost(ctx, obClient, jsonLog, "/api/v1/webhook/message"));
+
+// Templates
+app.MapGet("/api/v1/outbound/templates", async (HttpContext ctx, OutboundClient obClient, JsonLinesLogger jsonLog) =>
+    await OutboundProxyGet(ctx, obClient, jsonLog, "/api/v1/templates"));
+
+app.MapPost("/api/v1/outbound/templates", async (HttpContext ctx, OutboundClient obClient, JsonLinesLogger jsonLog) =>
+    await OutboundProxyPost(ctx, obClient, jsonLog, "/api/v1/templates"));
+
+app.MapPut("/api/v1/outbound/templates/{id:int}", async (HttpContext ctx, OutboundClient obClient, JsonLinesLogger jsonLog, int id) =>
+    await OutboundProxyPut(ctx, obClient, jsonLog, $"/api/v1/templates/{id}"));
+
+app.MapDelete("/api/v1/outbound/templates/{id:int}", async (HttpContext ctx, OutboundClient obClient, JsonLinesLogger jsonLog, int id) =>
+    await OutboundProxyDelete(ctx, obClient, jsonLog, $"/api/v1/templates/{id}"));
+
+// Opt-out
+app.MapPost("/api/v1/outbound/optout", async (HttpContext ctx, OutboundClient obClient, JsonLinesLogger jsonLog) =>
+    await OutboundProxyPost(ctx, obClient, jsonLog, "/api/v1/optout"));
+
+app.MapDelete("/api/v1/outbound/optout/{phone}", async (HttpContext ctx, OutboundClient obClient, JsonLinesLogger jsonLog, string phone) =>
+    await OutboundProxyDelete(ctx, obClient, jsonLog, $"/api/v1/optout/{phone}"));
+
+app.MapGet("/api/v1/outbound/optout/check/{phone}", async (HttpContext ctx, OutboundClient obClient, JsonLinesLogger jsonLog, string phone) =>
+    await OutboundProxyGet(ctx, obClient, jsonLog, $"/api/v1/optout/check/{phone}"));
+
 // SPA fallback - serve index.html for non-API routes (Dashboard routing)
 app.MapFallbackToFile("index.html");
 
diff --git a/src/Invekto.Backend/Services/OutboundClient.cs b/src/Invekto.Backend/Services/OutboundClient.cs
new file mode 100644
index 0000000..db1af9b
--- /dev/null
+++ b/src/Invekto.Backend/Services/OutboundClient.cs
@@ -0,0 +1,152 @@
+using System.Text;
+using System.Text.Json;
+using Invekto.Shared.DTOs;
+
+namespace Invekto.Backend.Services;
+
+/// <summary>
+/// HTTP client for Outbound microservice (Port 7107).
+/// Health checks, endpoint discovery, and generic HTTP proxy for all Outbound endpoints.
+/// GR-1.3: Broadcast, trigger, template, opt-out proxy.
+/// </summary>
+public sealed class OutboundClient
+{
+    private readonly HttpClient _httpClient;
+    private readonly ILogger<OutboundClient> _logger;
+
+    public OutboundClient(HttpClient httpClient, ILogger<OutboundClient> logger)
+    {
+        _httpClient = httpClient;
+        _logger = logger;
+    }
+
+    public async Task<bool> CheckHealthAsync(CancellationToken ct = default)
+    {
+        try
+        {
+            var response = await _httpClient.GetAsync("/health", ct);
+            return response.IsSuccessStatusCode;
+        }
+        catch (Exception ex)
+        {
+            _logger.LogWarning(ex, "Outbound health check failed");
+            return false;
+        }
+    }
+
+    public async Task<EndpointDiscoveryResponse?> GetEndpointsAsync(CancellationToken ct = default)
+    {
+        try
+        {
+            var response = await _httpClient.GetAsync("/api/ops/endpoints", ct);
+            if (response.IsSuccessStatusCode)
+            {
+                return await response.Content.ReadFromJsonAsync<EndpointDiscoveryResponse>(ct);
+            }
+            return null;
+        }
+        catch (Exception ex)
+        {
+            _logger.LogWarning(ex, "Outbound endpoint discovery failed");
+            return null;
+        }
+    }
+
+    public async Task<TestEndpointResult> TestEndpointAsync(string endpoint, CancellationToken ct = default)
+    {
+        try
+        {
+            var response = await _httpClient.GetAsync(endpoint, ct);
+            return new TestEndpointResult
+            {
+                Success = response.IsSuccessStatusCode,
+                StatusCode = (int)response.StatusCode,
+                Message = response.IsSuccessStatusCode ? "OK" : $"HTTP {(int)response.StatusCode}"
+            };
+        }
+        catch (TaskCanceledException ex)
+        {
+            _logger.LogWarning(ex, "Outbound endpoint test timeout: {Endpoint}", endpoint);
+            return new TestEndpointResult { Success = false, StatusCode = 0, Message = "Timeout" };
+        }
+        catch (HttpRequestException ex)
+        {
+            _logger.LogWarning(ex, "Outbound endpoint test failed: {Endpoint}", endpoint);
+            return new TestEndpointResult { Success = false, StatusCode = 0, Message = ex.Message };
+        }
+    }
+
+    /// <summary>
+    /// Generic POST proxy - forwards body + auth + request-id to Outbound.
+    /// </summary>
+    public async Task<(int StatusCode, string? Body)> ProxyPostAsync(
+        string path, string requestBody, string? authHeader, string? requestId,
+        CancellationToken ct = default)
+    {
+        return await ProxyRequestAsync(HttpMethod.Post, path, requestBody, authHeader, requestId, ct);
+    }
+
+    /// <summary>
+    /// Generic GET proxy - forwards auth + request-id to Outbound.
+    /// </summary>
+    public async Task<(int StatusCode, string? Body)> ProxyGetAsync(
+        string path, string? authHeader, string? requestId,
+        CancellationToken ct = default)
+    {
+        return await ProxyRequestAsync(HttpMethod.Get, path, null, authHeader, requestId, ct);
+    }
+
+    /// <summary>
+    /// Generic PUT proxy - forwards body + auth + request-id to Outbound.
+    /// </summary>
+    public async Task<(int StatusCode, string? Body)> ProxyPutAsync(
+        string path, string requestBody, string? authHeader, string? requestId,
+        CancellationToken ct = default)
+    {
+        return await ProxyRequestAsync(HttpMethod.Put, path, requestBody, authHeader, requestId, ct);
+    }
+
+    /// <summary>
+    /// Generic DELETE proxy - forwards auth + request-id to Outbound.
+    /// </summary>
+    public async Task<(int StatusCode, string? Body)> ProxyDeleteAsync(
+        string path, string? authHeader, string? requestId,
+        CancellationToken ct = default)
+    {
+        return await ProxyRequestAsync(HttpMethod.Delete, path, null, authHeader, requestId, ct);
+    }
+
+    private async Task<(int StatusCode, string? Body)> ProxyRequestAsync(
+        HttpMethod method, string path, string? requestBody, string? authHeader, string? requestId,
+        CancellationToken ct)
+    {
+        try
+        {
+            using var request = new HttpRequestMessage(method, path);
+
+            if (requestBody != null)
+                request.Content = new StringContent(requestBody, Encoding.UTF8, "application/json");
+
+            if (!string.IsNullOrEmpty(authHeader))
+                request.Headers.TryAddWithoutValidation("Authorization", authHeader);
+
+            if (!string.IsNullOrEmpty(requestId))
+                request.Headers.TryAddWithoutValidation("X-Request-Id", requestId);
+
+            using var response = await _httpClient.SendAsync(request, ct);
+            var body = await response.Content.ReadAsStringAsync(ct);
+
+            return ((int)response.StatusCode, body);
+        }
+        catch (TaskCanceledException)
+        {
+            _logger.LogWarning("Outbound proxy timeout: {Path}", path);
+            return (504, JsonSerializer.Serialize(new { error_code = "INV-BE-002", message = "Outbound service timeout" }));
+        }
+        catch (Exception ex)
+        {
+            _logger.LogWarning(ex, "Outbound proxy failed: {Path}", path);
+            return (502, JsonSerializer.Serialize(new { error_code = "INV-BE-001", message = $"Outbound service unavailable: {ex.Message}" }));
+        }
+    }
+}
diff --git a/src/Invekto.Backend/appsettings.json b/src/Invekto.Backend/appsettings.json
index 7fe5bee..3462235 100644
--- a/src/Invekto.Backend/appsettings.json
+++ b/src/Invekto.Backend/appsettings.json
@@ -25,6 +25,11 @@
       "Url": "http://localhost:7105",
       "LogPath": "../Invekto.AgentAI/logs",
       "SuggestTimeoutMs": 15000
+    },
+    "Outbound": {
+      "Url": "http://localhost:7107",
+      "LogPath": "../Invekto.Outbound/logs",
+      "TimeoutMs": 10000
     }
   },
   "Jwt": {
diff --git a/src/Invekto.Outbound/Data/OutboundRepository.cs b/src/Invekto.Outbound/Data/OutboundRepository.cs
new file mode 100644
index 0000000..3952663
--- /dev/null
+++ b/src/Invekto.Outbound/Data/OutboundRepository.cs
@@ -0,0 +1,590 @@
+using System.Text.Json;
+using Invekto.Shared.Data;
+using Invekto.Shared.DTOs.Outbound;
+using Invekto.Shared.Logging;
+using Npgsql;
+
+namespace Invekto.Outbound.Data;
+
+public sealed class OutboundRepository
+{
+    private readonly PostgresConnectionFactory _db;
+    private readonly JsonLinesLogger _logger;
+
+    public OutboundRepository(PostgresConnectionFactory db, JsonLinesLogger logger)
+    {
+        _db = db;
+        _logger = logger;
+    }
+
+    // ================================================================
+    // Templates
+    // ================================================================
+
+    public async Task<List<TemplateDto>> GetActiveTemplatesAsync(
+        int tenantId, CancellationToken ct = default)
+    {
+        const string sql = @"
+            SELECT id, name, trigger_event, message_template, variables_json,
+                   is_active, created_at, updated_at
+            FROM outbound_templates
+            WHERE tenant_id = @tid AND is_active = TRUE
+            ORDER BY created_at DESC";
+
+        await using var conn = await _db.OpenConnectionAsync(ct);
+        await using var cmd = new NpgsqlCommand(sql, conn);
+        cmd.Parameters.AddWithValue("tid", tenantId);
+
+        var templates = new List<TemplateDto>();
+        await using var reader = await cmd.ExecuteReaderAsync(ct);
+        while (await reader.ReadAsync(ct))
+        {
+            templates.Add(ReadTemplateDto(reader));
+        }
+        return templates;
+    }
+
+    public async Task<TemplateDto?> GetTemplateByIdAsync(
+        int tenantId, int templateId, CancellationToken ct = default)
+    {
+        const string sql = @"
+            SELECT id, name, trigger_event, message_template, variables_json,
+                   is_active, created_at, updated_at
+            FROM outbound_templates
+            WHERE tenant_id = @tid AND id = @id AND is_active = TRUE";
+
+        await using var conn = await _db.OpenConnectionAsync(ct);
+        await using var cmd = new NpgsqlCommand(sql, conn);
+        cmd.Parameters.AddWithValue("tid", tenantId);
+        cmd.Parameters.AddWithValue("id", templateId);
+
+        await using var reader = await cmd.ExecuteReaderAsync(ct);
+        if (await reader.ReadAsync(ct))
+            return ReadTemplateDto(reader);
+        return null;
+    }
+
+    public async Task<TemplateDto?> GetTriggerTemplateAsync(
+        int tenantId, string triggerEvent, CancellationToken ct = default)
+    {
+        const string sql = @"
+            SELECT id, name, trigger_event, message_template, variables_json,
+                   is_active, created_at, updated_at
+            FROM outbound_templates
+            WHERE tenant_id = @tid AND trigger_event = @evt AND is_active = TRUE
+            ORDER BY updated_at DESC
+            LIMIT 1";
+
+        await using var conn = await _db.OpenConnectionAsync(ct);
+        await using var cmd = new NpgsqlCommand(sql, conn);
+        cmd.Parameters.AddWithValue("tid", tenantId);
+        cmd.Parameters.AddWithValue("evt", triggerEvent);
+
+        await using var reader = await cmd.ExecuteReaderAsync(ct);
+        if (await reader.ReadAsync(ct))
+            return ReadTemplateDto(reader);
+        return null;
+    }
+
+    public async Task<int> CreateTemplateAsync(
+        int tenantId, string name, string triggerEvent,
+        string messageTemplate, Dictionary<string, string>? variablesJson,
+        CancellationToken ct = default)
+    {
+        const string sql = @"
+            INSERT INTO outbound_templates
+                (tenant_id, name, trigger_event, message_template, variables_json)
+            VALUES (@tid, @name, @evt, @tpl, @vars::jsonb)
+            RETURNING id";
+
+        await using var conn = await _db.OpenConnectionAsync(ct);
+        await using var cmd = new NpgsqlCommand(sql, conn);
+        cmd.Parameters.AddWithValue("tid", tenantId);
+        cmd.Parameters.AddWithValue("name", name);
+        cmd.Parameters.AddWithValue("evt", triggerEvent);
+        cmd.Parameters.AddWithValue("tpl", messageTemplate);
+        cmd.Parameters.AddWithValue("vars",
+            variablesJson != null ? (object)JsonSerializer.Serialize(variablesJson) : DBNull.Value);
+
+        var id = await cmd.ExecuteScalarAsync(ct);
+        return Convert.ToInt32(id);
+    }
+
+    public async Task<bool> UpdateTemplateAsync(
+        int tenantId, int templateId, TemplateUpdateRequest req,
+        CancellationToken ct = default)
+    {
+        var setClauses = new List<string>();
+        var parameters = new List<NpgsqlParameter>
+        {
+            new("tid", tenantId),
+            new("id", templateId)
+        };
+
+        if (req.Name != null)
+        {
+            setClauses.Add("name = @name");
+            parameters.Add(new NpgsqlParameter("name", req.Name));
+        }
+        if (req.TriggerEvent != null)
+        {
+            setClauses.Add("trigger_event = @evt");
+            parameters.Add(new NpgsqlParameter("evt", req.TriggerEvent));
+        }
+        if (req.MessageTemplate != null)
+        {
+            setClauses.Add("message_template = @tpl");
+            parameters.Add(new NpgsqlParameter("tpl", req.MessageTemplate));
+        }
+        if (req.VariablesJson != null)
+        {
+            setClauses.Add("variables_json = @vars::jsonb");
+            parameters.Add(new NpgsqlParameter("vars", JsonSerializer.Serialize(req.VariablesJson)));
+        }
+
+        if (setClauses.Count == 0) return false;
+        setClauses.Add("updated_at = NOW()");
+
+        var sql = $"UPDATE outbound_templates SET {string.Join(", ", setClauses)} WHERE tenant_id = @tid AND id = @id AND is_active = TRUE";
+
+        await using var conn = await _db.OpenConnectionAsync(ct);
+        await using var cmd = new NpgsqlCommand(sql, conn);
+        cmd.Parameters.AddRange(parameters.ToArray());
+
+        var rows = await cmd.ExecuteNonQueryAsync(ct);
+        return rows > 0;
+    }
+
+    public async Task<bool> DeactivateTemplateAsync(
+        int tenantId, int templateId, CancellationToken ct = default)
+    {
+        const string sql = @"
+            UPDATE outbound_templates
+            SET is_active = FALSE, updated_at = NOW()
+            WHERE tenant_id = @tid AND id = @id AND is_active = TRUE";
+
+        await using var conn = await _db.OpenConnectionAsync(ct);
+        await using var cmd = new NpgsqlCommand(sql, conn);
+        cmd.Parameters.AddWithValue("tid", tenantId);
+        cmd.Parameters.AddWithValue("id", templateId);
+
+        var rows = await cmd.ExecuteNonQueryAsync(ct);
+        return rows > 0;
+    }
+
+    // ================================================================
+    // Broadcasts
+    // ================================================================
+
+    public async Task<Guid> CreateBroadcastAsync(
+        int tenantId, int templateId, int totalRecipients, int queued,
+        DateTime? scheduledAt, CancellationToken ct = default)
+    {
+        const string sql = @"
+            INSERT INTO outbound_broadcasts
+                (tenant_id, template_id, total_recipients, queued, status, scheduled_at)
+            VALUES (@tid, @tmpl, @total, @queued, 'queued', @sched)
+            RETURNING id";
+
+        await using var conn = await _db.OpenConnectionAsync(ct);
+        await using var cmd = new NpgsqlCommand(sql, conn);
+        cmd.Parameters.AddWithValue("tid", tenantId);
+        cmd.Parameters.AddWithValue("tmpl", templateId);
+        cmd.Parameters.AddWithValue("total", totalRecipients);
+        cmd.Parameters.AddWithValue("queued", queued);
+        cmd.Parameters.AddWithValue("sched", scheduledAt.HasValue ? (object)scheduledAt.Value : DBNull.Value);
+
+        var id = await cmd.ExecuteScalarAsync(ct);
+        return (Guid)id!;
+    }
+
+    public async Task<BroadcastStatusResponse?> GetBroadcastStatusAsync(
+        int tenantId, Guid broadcastId, CancellationToken ct = default)
+    {
+        const string sql = @"
+            SELECT id, status, total_recipients, queued, sent, delivered, read, failed,
+                   created_at, started_at, completed_at
+            FROM outbound_broadcasts
+            WHERE tenant_id = @tid AND id = @bid";
+
+        await using var conn = await _db.OpenConnectionAsync(ct);
+        await using var cmd = new NpgsqlCommand(sql, conn);
+        cmd.Parameters.AddWithValue("tid", tenantId);
+        cmd.Parameters.AddWithValue("bid", broadcastId);
+
+        await using var reader = await cmd.ExecuteReaderAsync(ct);
+        if (!await reader.ReadAsync(ct)) return null;
+
+        return new BroadcastStatusResponse
+        {
+            BroadcastId = reader.GetGuid(0),
+            Status = reader.GetString(1),
+            TotalRecipients = reader.GetInt32(2),
+            Queued = reader.GetInt32(3),
+            Sent = reader.GetInt32(4),
+            Delivered = reader.GetInt32(5),
+            Read = reader.GetInt32(6),
+            Failed = reader.GetInt32(7),
+            CreatedAt = reader.GetDateTime(8),
+            StartedAt = reader.IsDBNull(9) ? null : reader.GetDateTime(9),
+            CompletedAt = reader.IsDBNull(10) ? null : reader.GetDateTime(10)
+        };
+    }
+
+    public async Task UpdateBroadcastStatusAsync(
+        Guid broadcastId, string status, CancellationToken ct = default)
+    {
+        var extraSet = status switch
+        {
+            "processing" => ", started_at = COALESCE(started_at, NOW())",
+            "completed" or "failed" => ", completed_at = NOW()",
+            _ => ""
+        };
+
+        var sql = $"UPDATE outbound_broadcasts SET status = @st{extraSet} WHERE id = @bid";
+
+        await using var conn = await _db.OpenConnectionAsync(ct);
+        await using var cmd = new NpgsqlCommand(sql, conn);
+        cmd.Parameters.AddWithValue("st", status);
+        cmd.Parameters.AddWithValue("bid", broadcastId);
+
+        await cmd.ExecuteNonQueryAsync(ct);
+    }
+
+    public async Task IncrementBroadcastCounterAsync(
+        Guid broadcastId, string counterColumn, CancellationToken ct = default)
+    {
+        // Whitelist valid columns to prevent SQL injection
+        if (counterColumn is not ("sent" or "delivered" or "read" or "failed"))
+            throw new ArgumentException($"Invalid counter column: {counterColumn}");
+
+        // Decrement queued when message leaves queue
+        var queuedDecrement = counterColumn == "sent" || counterColumn == "failed"
+            ? ", queued = GREATEST(queued - 1, 0)" : "";
+
+        var sql = $"UPDATE outbound_broadcasts SET {counterColumn} = {counterColumn} + 1{queuedDecrement} WHERE id = @bid";
+
+        await using var conn = await _db.OpenConnectionAsync(ct);
+        await using var cmd = new NpgsqlCommand(sql, conn);
+        cmd.Parameters.AddWithValue("bid", broadcastId);
+
+        await cmd.ExecuteNonQueryAsync(ct);
+    }
+
+    /// <summary>Check if all messages in a broadcast are processed (no more queued/sending).</summary>
+    public async Task<bool> IsBroadcastCompleteAsync(
+        Guid broadcastId, CancellationToken ct = default)
+    {
+        const string sql = @"
+            SELECT COUNT(*) FROM outbound_messages
+            WHERE broadcast_id = @bid AND status IN ('queued', 'sending')";
+
+        await using var conn = await _db.OpenConnectionAsync(ct);
+        await using var cmd = new NpgsqlCommand(sql, conn);
+        cmd.Parameters.AddWithValue("bid", broadcastId);
+
+        var count = (long)(await cmd.ExecuteScalarAsync(ct))!;
+        return count == 0;
+    }
+
+    // ================================================================
+    // Messages
+    // ================================================================
+
+    public async Task<long> InsertMessageAsync(
+        int tenantId, Guid? broadcastId, int? templateId,
+        string recipientPhone, string messageText,
+        CancellationToken ct = default)
+    {
+        const string sql = @"
+            INSERT INTO outbound_messages
+                (tenant_id, broadcast_id, template_id, recipient_phone, message_text, status)
+            VALUES (@tid, @bid, @tmpl, @phone, @msg, 'queued')
+            RETURNING id";
+
+        await using var conn = await _db.OpenConnectionAsync(ct);
+        await using var cmd = new NpgsqlCommand(sql, conn);
+        cmd.Parameters.AddWithValue("tid", tenantId);
+        cmd.Parameters.AddWithValue("bid", broadcastId.HasValue ? (object)broadcastId.Value : DBNull.Value);
+        cmd.Parameters.AddWithValue("tmpl", templateId.HasValue ? (object)templateId.Value : DBNull.Value);
+        cmd.Parameters.AddWithValue("phone", recipientPhone);
+        cmd.Parameters.AddWithValue("msg", messageText);
+
+        var id = await cmd.ExecuteScalarAsync(ct);
+        return Convert.ToInt64(id);
+    }
+
+    /// <summary>Dequeue next batch of messages to send, respecting rate limit.</summary>
+    public async Task<List<QueuedMessage>> DequeueMessagesAsync(
+        int batchSize, CancellationToken ct = default)
+    {
+        const string sql = @"
+            UPDATE outbound_messages
+            SET status = 'sending'
+            WHERE id IN (
+                SELECT id FROM outbound_messages
+                WHERE status = 'queued'
+                ORDER BY created_at
+                LIMIT @batch
+                FOR UPDATE SKIP LOCKED
+            )
+            RETURNING id, tenant_id, broadcast_id, template_id,
+                      recipient_phone, message_text";
+
+        await using var conn = await _db.OpenConnectionAsync(ct);
+        await using var cmd = new NpgsqlCommand(sql, conn);
+        cmd.Parameters.AddWithValue("batch", batchSize);
+
+        var messages = new List<QueuedMessage>();
+        await using var reader = await cmd.ExecuteReaderAsync(ct);
+        while (await reader.ReadAsync(ct))
+        {
+            messages.Add(new QueuedMessage
+            {
+                Id = reader.GetInt64(0),
+                TenantId = reader.GetInt32(1),
+                BroadcastId = reader.IsDBNull(2) ? null : reader.GetGuid(2),
+                TemplateId = reader.IsDBNull(3) ? null : reader.GetInt32(3),
+                RecipientPhone = reader.GetString(4),
+                MessageText = reader.GetString(5)
+            });
+        }
+        return messages;
+    }
+
+    public async Task UpdateMessageStatusAsync(
+        long messageId, string status, string? externalMessageId = null,
+        string? failedReason = null, CancellationToken ct = default)
+    {
+        var timestampCol = status switch
+        {
+            "sent" => ", sent_at = NOW()",
+            "delivered" => ", delivered_at = NOW()",
+            "read" => ", read_at = NOW()",
+            _ => ""
+        };
+
+        var extIdSet = externalMessageId != null ? ", external_message_id = @eid" : "";
+        var failSet = failedReason != null ? ", failed_reason = @fail" : "";
+
+        var sql = $"UPDATE outbound_messages SET status = @st{timestampCol}{extIdSet}{failSet} WHERE id = @mid";
+
+        await using var conn = await _db.OpenConnectionAsync(ct);
+        await using var cmd = new NpgsqlCommand(sql, conn);
+        cmd.Parameters.AddWithValue("st", status);
+        cmd.Parameters.AddWithValue("mid", messageId);
+
+        if (externalMessageId != null)
+            cmd.Parameters.AddWithValue("eid", externalMessageId);
+        if (failedReason != null)
+            cmd.Parameters.AddWithValue("fail", failedReason);
+
+        await cmd.ExecuteNonQueryAsync(ct);
+    }
+
+    /// <summary>Find message by external_message_id (from WapCRM/WhatsApp).</summary>
+    public async Task<(long messageId, Guid? broadcastId, int tenantId)?> FindMessageByExternalIdAsync(
+        string externalMessageId, CancellationToken ct = default)
+    {
+        const string sql = @"
+            SELECT id, broadcast_id, tenant_id
+            FROM outbound_messages
+            WHERE external_message_id = @eid
+            LIMIT 1";
+
+        await using var conn = await _db.OpenConnectionAsync(ct);
+        await using var cmd = new NpgsqlCommand(sql, conn);
+        cmd.Parameters.AddWithValue("eid", externalMessageId);
+
+        await using var reader = await cmd.ExecuteReaderAsync(ct);
+        if (await reader.ReadAsync(ct))
+        {
+            return (
+                reader.GetInt64(0),
+                reader.IsDBNull(1) ? null : reader.GetGuid(1),
+                reader.GetInt32(2)
+            );
+        }
+        return null;
+    }
+
+    // ================================================================
+    // Opt-outs
+    // ================================================================
+
+    public async Task<bool> IsOptedOutAsync(
+        int tenantId, string phone, CancellationToken ct = default)
+    {
+        const string sql = @"
+            SELECT 1 FROM outbound_optouts
+            WHERE tenant_id = @tid AND phone = @phone
+            LIMIT 1";
+
+        await using var conn = await _db.OpenConnectionAsync(ct);
+        await using var cmd = new NpgsqlCommand(sql, conn);
+        cmd.Parameters.AddWithValue("tid", tenantId);
+        cmd.Parameters.AddWithValue("phone", phone);
+
+        var result = await cmd.ExecuteScalarAsync(ct);
+        return result != null;
+    }
+
+    public async Task<DateTime?> GetOptOutDateAsync(
+        int tenantId, string phone, CancellationToken ct = default)
+    {
+        const string sql = @"
+            SELECT created_at FROM outbound_optouts
+            WHERE tenant_id = @tid AND phone = @phone
+            LIMIT 1";
+
+        await using var conn = await _db.OpenConnectionAsync(ct);
+        await using var cmd = new NpgsqlCommand(sql, conn);
+        cmd.Parameters.AddWithValue("tid", tenantId);
+        cmd.Parameters.AddWithValue("phone", phone);
+
+        var result = await cmd.ExecuteScalarAsync(ct);
+        return result as DateTime?;
+    }
+
+    public async Task<bool> AddOptOutAsync(
+        int tenantId, string phone, string? reason,
+        CancellationToken ct = default)
+    {
+        const string sql = @"
+            INSERT INTO outbound_optouts (tenant_id, phone, reason)
+            VALUES (@tid, @phone, @reason)
+            ON CONFLICT (tenant_id, phone) DO NOTHING
+            RETURNING id";
+
+        await using var conn = await _db.OpenConnectionAsync(ct);
+        await using var cmd = new NpgsqlCommand(sql, conn);
+        cmd.Parameters.AddWithValue("tid", tenantId);
+        cmd.Parameters.AddWithValue("phone", phone);
+        cmd.Parameters.AddWithValue("reason", (object?)reason ?? DBNull.Value);
+
+        var id = await cmd.ExecuteScalarAsync(ct);
+        return id != null;
+    }
+
+    public async Task<bool> RemoveOptOutAsync(
+        int tenantId, string phone, CancellationToken ct = default)
+    {
+        const string sql = @"
+            DELETE FROM outbound_optouts
+            WHERE tenant_id = @tid AND phone = @phone";
+
+        await using var conn = await _db.OpenConnectionAsync(ct);
+        await using var cmd = new NpgsqlCommand(sql, conn);
+        cmd.Parameters.AddWithValue("tid", tenantId);
+        cmd.Parameters.AddWithValue("phone", phone);
+
+        var rows = await cmd.ExecuteNonQueryAsync(ct);
+        return rows > 0;
+    }
+
+    // ================================================================
+    // Helpers
+    // ================================================================
+
+    /// <summary>Batch check which phones are opted out for a tenant.</summary>
+    public async Task<HashSet<string>> BatchCheckOptOutsAsync(
+        int tenantId, List<string> phones, CancellationToken ct = default)
+    {
+        if (phones.Count == 0) return new HashSet<string>();
+
+        await using var conn = await _db.OpenConnectionAsync(ct);
+        await using var cmd = new NpgsqlCommand(
+            "SELECT phone FROM outbound_optouts WHERE tenant_id = @tid AND phone = ANY(@phones)", conn);
+        cmd.Parameters.AddWithValue("tid", tenantId);
+        cmd.Parameters.AddWithValue("phones", phones.ToArray());
+
+        var optedOut = new HashSet<string>(StringComparer.OrdinalIgnoreCase);
+        await using var reader = await cmd.ExecuteReaderAsync(ct);
+        while (await reader.ReadAsync(ct))
+            optedOut.Add(reader.GetString(0));
+        return optedOut;
+    }
+
+    /// <summary>Batch insert messages in a single multi-row INSERT.</summary>
+    public async Task BatchInsertMessagesAsync(
+        int tenantId, Guid broadcastId, int templateId,
+        List<(string phone, string text)> messages,
+        CancellationToken ct = default)
+    {
+        if (messages.Count == 0) return;
+
+        await using var conn = await _db.OpenConnectionAsync(ct);
+
+        // Build multi-row VALUES clause
+        var valueClauses = new List<string>();
+        await using var cmd = new NpgsqlCommand();
+        cmd.Connection = conn;
+
+        for (var i = 0; i < messages.Count; i++)
+        {
+            valueClauses.Add($"(@tid, @bid, @tmpl, @phone{i}, @msg{i}, 'queued')");
+            cmd.Parameters.AddWithValue($"phone{i}", messages[i].phone);
+            cmd.Parameters.AddWithValue($"msg{i}", messages[i].text);
+        }
+
+        cmd.Parameters.AddWithValue("tid", tenantId);
+        cmd.Parameters.AddWithValue("bid", broadcastId);
+        cmd.Parameters.AddWithValue("tmpl", templateId);
+
+        cmd.CommandText = $@"
+            INSERT INTO outbound_messages
+                (tenant_id, broadcast_id, template_id, recipient_phone, message_text, status)
+            VALUES {string.Join(",\n                   ", valueClauses)}";
+
+        await cmd.ExecuteNonQueryAsync(ct);
+    }
+
+    /// <summary>Reset stale 'sending' messages back to 'queued' on service shutdown.</summary>
+    public async Task ResetSendingMessagesAsync(CancellationToken ct = default)
+    {
+        const string sql = "UPDATE outbound_messages SET status = 'queued' WHERE status = 'sending'";
+
+        await using var conn = await _db.OpenConnectionAsync(ct);
+        await using var cmd = new NpgsqlCommand(sql, conn);
+        var rows = await cmd.ExecuteNonQueryAsync(ct);
+        if (rows > 0)
+            _logger.SystemWarn($"Reset {rows} stale 'sending' messages back to 'queued' on shutdown");
+    }
+
+    private TemplateDto ReadTemplateDto(NpgsqlDataReader reader)
+    {
+        var variablesStr = reader.IsDBNull(4) ? null : reader.GetString(4);
+        Dictionary<string, string>? variables = null;
+        if (variablesStr != null)
+        {
+            try { variables = JsonSerializer.Deserialize<Dictionary<string, string>>(variablesStr); }
+            catch (JsonException ex)
+            {
+                var templateId = reader.GetInt32(0);
+                _logger.SystemWarn($"Malformed variables_json for template {templateId}: {ex.Message}");
+            }
+        }
+
+        return new TemplateDto
+        {
+            Id = reader.GetInt32(0),
+            Name = reader.GetString(1),
+            TriggerEvent = reader.GetString(2),
+            MessageTemplate = reader.GetString(3),
+            VariablesJson = variables,
+            IsActive = reader.GetBoolean(5),
+            CreatedAt = reader.GetDateTime(6),
+            UpdatedAt = reader.GetDateTime(7)
+        };
+    }
+}
+
+public sealed class QueuedMessage
+{
+    public long Id { get; set; }
+    public int TenantId { get; set; }
+    public Guid? BroadcastId { get; set; }
+    public int? TemplateId { get; set; }
+    public string RecipientPhone { get; set; } = "";
+    public string MessageText { get; set; } = "";
+}
diff --git a/src/Invekto.Outbound/Invekto.Outbound.csproj b/src/Invekto.Outbound/Invekto.Outbound.csproj
new file mode 100644
index 0000000..263b43f
--- /dev/null
+++ b/src/Invekto.Outbound/Invekto.Outbound.csproj
@@ -0,0 +1,16 @@
+<Project Sdk="Microsoft.NET.Sdk.Web">
+  <PropertyGroup>
+    <TargetFramework>net8.0</TargetFramework>
+    <Nullable>enable</Nullable>
+    <ImplicitUsings>enable</ImplicitUsings>
+    <RootNamespace>Invekto.Outbound</RootNamespace>
+  </PropertyGroup>
+
+  <ItemGroup>
+    <PackageReference Include="Microsoft.Extensions.Hosting.WindowsServices" Version="8.0.1" />
+  </ItemGroup>
+
+  <ItemGroup>
+    <ProjectReference Include="..\Invekto.Shared\Invekto.Shared.csproj" />
+  </ItemGroup>
+</Project>
diff --git a/src/Invekto.Outbound/Middleware/JwtAuthMiddleware.cs b/src/Invekto.Outbound/Middleware/JwtAuthMiddleware.cs
new file mode 100644
index 0000000..c5b3b4a
--- /dev/null
+++ b/src/Invekto.Outbound/Middleware/JwtAuthMiddleware.cs
@@ -0,0 +1,105 @@
+using Invekto.Shared.Auth;
+using Invekto.Shared.Constants;
+using Invekto.Shared.DTOs;
+using Invekto.Shared.Logging;
+
+namespace Invekto.Outbound.Middleware;
+
+public sealed class JwtAuthMiddleware
+{
+    private readonly RequestDelegate _next;
+    private readonly JwtValidator _jwtValidator;
+    private readonly JsonLinesLogger _logger;
+    private readonly HashSet<string> _authRequiredPrefixes;
+
+    public JwtAuthMiddleware(
+        RequestDelegate next,
+        JwtValidator jwtValidator,
+        JsonLinesLogger logger,
+        IEnumerable<string> authRequiredPrefixes)
+    {
+        _next = next;
+        _jwtValidator = jwtValidator;
+        _logger = logger;
+        _authRequiredPrefixes = new HashSet<string>(authRequiredPrefixes, StringComparer.OrdinalIgnoreCase);
+    }
+
+    public async Task InvokeAsync(HttpContext context)
+    {
+        var path = context.Request.Path.Value ?? "";
+
+        if (!RequiresAuth(path))
+        {
+            await _next(context);
+            return;
+        }
+
+        var authHeader = context.Request.Headers.Authorization.FirstOrDefault();
+        if (string.IsNullOrEmpty(authHeader) || !authHeader.StartsWith("Bearer ", StringComparison.OrdinalIgnoreCase))
+        {
+            _logger.SystemWarn($"[{ErrorCodes.AuthUnauthorized}] Missing or invalid Authorization header: path={path}");
+            context.Response.StatusCode = 401;
+            await context.Response.WriteAsJsonAsync(
+                ErrorResponse.Create(ErrorCodes.AuthUnauthorized, "Bearer token required", "-"));
+            return;
+        }
+
+        var token = authHeader["Bearer ".Length..].Trim();
+        var (tenantContext, error) = _jwtValidator.ValidateToken(token);
+
+        if (tenantContext == null)
+        {
+            var errorCode = error?.Contains("expired", StringComparison.OrdinalIgnoreCase) == true
+                ? ErrorCodes.AuthTokenExpired
+                : ErrorCodes.AuthTokenInvalid;
+
+            _logger.SystemWarn($"[{errorCode}] JWT validation failed: path={path}, error={error}");
+            context.Response.StatusCode = 401;
+            await context.Response.WriteAsJsonAsync(
+                ErrorResponse.Create(errorCode, error ?? "Token validation failed", "-"));
+            return;
+        }
+
+        context.Items["TenantContext"] = tenantContext;
+
+        // Validate tenant_id header matches JWT claim (prevent tenant spoofing)
+        var existingTenantId = context.Request.Headers[HeaderNames.TenantId].FirstOrDefault();
+        if (!string.IsNullOrEmpty(existingTenantId) && existingTenantId != tenantContext.TenantId.ToString())
+        {
+            _logger.SystemWarn($"[{ErrorCodes.AuthUnauthorized}] Tenant ID mismatch: header={existingTenantId}, jwt={tenantContext.TenantId}, path={path}");
+            context.Response.StatusCode = 403;
+            await context.Response.WriteAsJsonAsync(
+                ErrorResponse.Create(ErrorCodes.AuthUnauthorized, "Tenant ID mismatch between header and JWT token", "-"));
+            return;
+        }
+
+        if (string.IsNullOrEmpty(existingTenantId))
+        {
+            context.Request.Headers[HeaderNames.TenantId] = tenantContext.TenantId.ToString();
+        }
+
+        await _next(context);
+    }
+
+    private bool RequiresAuth(string path)
+    {
+        foreach (var prefix in _authRequiredPrefixes)
+        {
+            if (path.StartsWith(prefix, StringComparison.OrdinalIgnoreCase))
+                return true;
+        }
+        return false;
+    }
+}
+
+public static class JwtAuthMiddlewareExtensions
+{
+    public static IApplicationBuilder UseJwtAuth(
+        this IApplicationBuilder app,
+        JwtValidator jwtValidator,
+        JsonLinesLogger logger,
+        params string[] authRequiredPrefixes)
+    {
+        return app.UseMiddleware<JwtAuthMiddleware>(jwtValidator, logger, (IEnumerable<string>)authRequiredPrefixes);
+    }
+}
diff --git a/src/Invekto.Outbound/Middleware/TrafficLoggingMiddleware.cs b/src/Invekto.Outbound/Middleware/TrafficLoggingMiddleware.cs
new file mode 100644
index 0000000..39f7956
--- /dev/null
+++ b/src/Invekto.Outbound/Middleware/TrafficLoggingMiddleware.cs
@@ -0,0 +1,95 @@
+using System.Diagnostics;
+using System.Text;
+using Invekto.Shared.DTOs;
+using Invekto.Shared.Logging;
+
+namespace Invekto.Outbound.Middleware;
+
+public sealed class TrafficLoggingMiddleware
+{
+    private readonly RequestDelegate _next;
+    private readonly JsonLinesLogger _logger;
+
+    private static readonly string[] SkipPaths = { "/health", "/ready" };
+
+    public TrafficLoggingMiddleware(RequestDelegate next, JsonLinesLogger logger)
+    {
+        _next = next;
+        _logger = logger;
+    }
+
+    public async Task InvokeAsync(HttpContext context)
+    {
+        var path = context.Request.Path.Value ?? "";
+
+        if (SkipPaths.Any(p => path.StartsWith(p, StringComparison.OrdinalIgnoreCase)))
+        {
+            await _next(context);
+            return;
+        }
+
+        var sw = Stopwatch.StartNew();
+
+        string? requestBody = null;
+        if (context.Request.ContentLength > 0 && context.Request.ContentLength < 50000)
+        {
+            context.Request.EnableBuffering();
+            using var reader = new StreamReader(
+                context.Request.Body, Encoding.UTF8,
+                detectEncodingFromByteOrderMarks: false, leaveOpen: true);
+            requestBody = await reader.ReadToEndAsync();
+            context.Request.Body.Position = 0;
+        }
+
+        var originalBodyStream = context.Response.Body;
+        using var responseBodyStream = new MemoryStream();
+        context.Response.Body = responseBodyStream;
+
+        try
+        {
+            await _next(context);
+        }
+        finally
+        {
+            sw.Stop();
+
+            string? responseBody = null;
+            if (responseBodyStream.Length > 0 && responseBodyStream.Length < 50000)
+            {
+                responseBodyStream.Position = 0;
+                responseBody = await new StreamReader(responseBodyStream).ReadToEndAsync();
+            }
+
+            responseBodyStream.Position = 0;
+            await responseBodyStream.CopyToAsync(originalBodyStream);
+            context.Response.Body = originalBodyStream;
+
+            var requestId = context.Request.Headers["X-Request-Id"].FirstOrDefault()
+                ?? context.TraceIdentifier;
+            var tenantId = context.Request.Headers["X-Tenant-Id"].FirstOrDefault() ?? "-";
+            var chatId = context.Request.Headers["X-Chat-Id"].FirstOrDefault() ?? "-";
+
+            var logContext = new RequestContext
+            {
+                RequestId = requestId,
+                TenantId = tenantId,
+                ChatId = chatId
+            };
+
+            var level = context.Response.StatusCode >= 400 ? "WARN" : "INFO";
+            var message = $"{context.Request.Method} {path} -> {context.Response.StatusCode}";
+
+            _logger.LogTraffic(level, message, logContext, path,
+                context.Request.Method, sw.ElapsedMilliseconds,
+                context.Response.StatusCode, requestBody, responseBody);
+        }
+    }
+}
+
+public static class TrafficLoggingMiddlewareExtensions
+{
+    public static IApplicationBuilder UseTrafficLogging(this IApplicationBuilder builder)
+    {
+        return builder.UseMiddleware<TrafficLoggingMiddleware>();
+    }
+}
diff --git a/src/Invekto.Outbound/Program.cs b/src/Invekto.Outbound/Program.cs
new file mode 100644
index 0000000..ac44e73
--- /dev/null
+++ b/src/Invekto.Outbound/Program.cs
@@ -0,0 +1,587 @@
+using Invekto.Outbound.Data;
+using Invekto.Outbound.Middleware;
+using Invekto.Outbound.Services;
+using Invekto.Shared.Auth;
+using Invekto.Shared.Constants;
+using Invekto.Shared.Data;
+using Invekto.Shared.DTOs;
+using Invekto.Shared.DTOs.Outbound;
+using Invekto.Shared.Integration;
+using Invekto.Shared.Logging;
+
+var builder = WebApplication.CreateBuilder(args);
+
+// Windows Service support
+builder.Host.UseWindowsService();
+
+// Read configuration
+var listenPort = builder.Configuration.GetValue<int>("Service:ListenPort", ServiceConstants.OutboundPort);
+var logPath = builder.Configuration["Logging:FilePath"] ?? "logs";
+var pgConnStr = builder.Configuration.GetConnectionString("PostgreSQL") ?? "";
+var jwtSecretKey = builder.Configuration["Jwt:SecretKey"] ?? "";
+var defaultMsgPerMin = builder.Configuration.GetValue<int>("RateLimit:DefaultMessagesPerMinute", 30);
+var senderIntervalMs = builder.Configuration.GetValue<int>("RateLimit:SenderIntervalMs", 1000);
+var callbackUrl = builder.Configuration["Callback:DefaultCallbackUrl"] ?? "";
+var callbackMaxRetries = builder.Configuration.GetValue<int>("Callback:MaxRetries", 3);
+var callbackBaseDelayMs = builder.Configuration.GetValue<int>("Callback:BaseDelayMs", 500);
+var callbackTimeoutMs = builder.Configuration.GetValue<int>("Callback:TimeoutMs", 5000);
+
+// Validate required config
+if (string.IsNullOrEmpty(pgConnStr))
+{
+    Console.Error.WriteLine("FATAL: ConnectionStrings:PostgreSQL is not configured");
+    Environment.Exit(1);
+}
+if (string.IsNullOrEmpty(jwtSecretKey))
+{
+    Console.Error.WriteLine("FATAL: Jwt:SecretKey is not configured");
+    Environment.Exit(1);
+}
+
+// Configure Kestrel
+builder.WebHost.ConfigureKestrel(options =>
+{
+    options.ListenAnyIP(listenPort);
+});
+
+// Register logger
+var logger = new JsonLinesLogger(ServiceConstants.OutboundServiceName, logPath);
+builder.Services.AddSingleton(logger);
+
+// Register log cleanup
+builder.Services.AddSingleton<LogCleanupService>(sp =>
+    new LogCleanupService(logPath, ServiceConstants.LogRetentionDays));
+
+// Register JWT validator
+var jwtSettings = new JwtSettings
+{
+    SecretKey = jwtSecretKey,
+    Issuer = builder.Configuration["Jwt:Issuer"],
+    Audience = builder.Configuration["Jwt:Audience"],
+    ClockSkewSeconds = builder.Configuration.GetValue<int>("Jwt:ClockSkewSeconds", 60)
+};
+var jwtValidator = new JwtValidator(jwtSettings);
+builder.Services.AddSingleton(jwtValidator);
+
+// Register PostgreSQL connection factory
+var pgFactory = new PostgresConnectionFactory(pgConnStr);
+builder.Services.AddSingleton(pgFactory);
+
+// Register repository
+builder.Services.AddSingleton<OutboundRepository>();
+
+// Register services
+builder.Services.AddSingleton<TemplateEngine>();
+builder.Services.AddSingleton<OptOutManager>();
+builder.Services.AddSingleton(new RateLimiter(defaultMsgPerMin, logger));
+builder.Services.AddSingleton<BroadcastOrchestrator>();
+builder.Services.AddSingleton<TriggerProcessor>();
+
+// Register MainAppCallbackClient with HttpClient
+var callbackSettings = new CallbackSettings
+{
+    DefaultCallbackUrl = callbackUrl,
+    MaxRetries = callbackMaxRetries,
+    BaseDelayMs = callbackBaseDelayMs,
+    TimeoutMs = callbackTimeoutMs
+};
+builder.Services.AddSingleton(callbackSettings);
+builder.Services.AddHttpClient<MainAppCallbackClient>()
+    .AddTypedClient((httpClient, sp) =>
+    {
+        return new MainAppCallbackClient(
+            httpClient,
+            sp.GetRequiredService<CallbackSettings>(),
+            sp.GetRequiredService<JsonLinesLogger>());
+    });
+
+// Register background message sender
+builder.Services.AddSingleton<MessageSenderService>(sp =>
+    new MessageSenderService(
+        sp.GetRequiredService<OutboundRepository>(),
+        sp.GetRequiredService<RateLimiter>(),
+        sp.GetRequiredService<MainAppCallbackClient>(),
+        sp.GetRequiredService<JsonLinesLogger>(),
+        senderIntervalMs));
+builder.Services.AddHostedService(sp => sp.GetRequiredService<MessageSenderService>());
+
+var app = builder.Build();
+
+// Enable traffic logging middleware
+app.UseTrafficLogging();
+
+// Enable JWT auth for /api/v1/ prefixed paths
+app.UseJwtAuth(jwtValidator, logger, "/api/v1/");
+
+// Start log cleanup
+_ = app.Services.GetRequiredService<LogCleanupService>();
+
+// ============================================================
+// Health endpoints
+// ============================================================
+
+app.MapGet("/health", () => Results.Ok(HealthResponse.Ok(ServiceConstants.OutboundServiceName)));
+app.MapGet("/ready", async (PostgresConnectionFactory db) =>
+{
+    var (ok, error) = await db.TestConnectionAsync();
+    if (!ok)
+        return Results.Json(new { status = "unhealthy", error }, statusCode: 503);
+    return Results.Ok(HealthResponse.Ok(ServiceConstants.OutboundServiceName));
+});
+
+// ============================================================
+// Broadcast endpoints
+// ============================================================
+
+app.MapPost("/api/v1/broadcast/send", async (
+    HttpContext ctx,
+    BroadcastOrchestrator orchestrator,
+    JsonLinesLogger jsonLogger,
+    BroadcastSendRequest? request) =>
+{
+    var requestId = ctx.Request.Headers["X-Request-Id"].FirstOrDefault() ?? Guid.NewGuid().ToString("N");
+    ctx.Request.Headers["X-Request-Id"] = requestId;
+
+    if (request == null)
+    {
+        return Results.Json(
+            ErrorResponse.Create(ErrorCodes.OutboundInvalidBroadcastPayload, "Request body is required", requestId),
+            statusCode: 400);
+    }
+
+    var tenantContext = ctx.Items["TenantContext"] as TenantContext;
+    if (tenantContext == null)
+    {
+        return Results.Json(
+            ErrorResponse.Create(ErrorCodes.AuthUnauthorized, "Tenant context not available", requestId),
+            statusCode: 401);
+    }
+
+    var (response, errorCode, errorMessage) = await orchestrator.CreateBroadcastAsync(
+        tenantContext.TenantId, request, CancellationToken.None);
+
+    if (response == null)
+    {
+        var statusCode = errorCode switch
+        {
+            ErrorCodes.OutboundTooManyRecipients => 400,
+            ErrorCodes.OutboundTemplateNotFound => 404,
+            _ => 400
+        };
+        return Results.Json(
+            ErrorResponse.Create(errorCode!, errorMessage!, requestId),
+            statusCode: statusCode);
+    }
+
+    jsonLogger.StepInfo(
+        $"Broadcast submitted: id={response.BroadcastId}, queued={response.Queued}, skipped={response.SkippedOptout}",
+        requestId);
+
+    return Results.Json(response, statusCode: 202);
+});
+
+app.MapGet("/api/v1/broadcast/{broadcastId}/status", async (
+    HttpContext ctx,
+    OutboundRepository repository,
+    string broadcastId) =>
+{
+    var requestId = ctx.Request.Headers["X-Request-Id"].FirstOrDefault() ?? Guid.NewGuid().ToString("N");
+
+    var tenantContext = ctx.Items["TenantContext"] as TenantContext;
+    if (tenantContext == null)
+    {
+        return Results.Json(
+            ErrorResponse.Create(ErrorCodes.AuthUnauthorized, "Tenant context not available", requestId),
+            statusCode: 401);
+    }
+
+    if (!Guid.TryParse(broadcastId, out var bid))
+    {
+        return Results.Json(
+            ErrorResponse.Create(ErrorCodes.OutboundBroadcastNotFound, "Invalid broadcast ID format", requestId),
+            statusCode: 400);
+    }
+
+    var status = await repository.GetBroadcastStatusAsync(tenantContext.TenantId, bid);
+    if (status == null)
+    {
+        return Results.Json(
+            ErrorResponse.Create(ErrorCodes.OutboundBroadcastNotFound, $"Broadcast {broadcastId} not found", requestId),
+            statusCode: 404);
+    }
+
+    return Results.Ok(status);
+});
+
+// ============================================================
+// Webhook endpoints
+// ============================================================
+
+app.MapPost("/api/v1/webhook/trigger", async (
+    HttpContext ctx,
+    TriggerProcessor triggerProcessor,
+    JsonLinesLogger jsonLogger,
+    TriggerWebhookRequest? request) =>
+{
+    var requestId = ctx.Request.Headers["X-Request-Id"].FirstOrDefault() ?? Guid.NewGuid().ToString("N");
+    ctx.Request.Headers["X-Request-Id"] = requestId;
+
+    if (request == null)
+    {
+        return Results.Json(
+            ErrorResponse.Create(ErrorCodes.OutboundInvalidBroadcastPayload, "Request body is required", requestId),
+            statusCode: 400);
+    }
+
+    var tenantContext = ctx.Items["TenantContext"] as TenantContext;
+    if (tenantContext == null)
+    {
+        return Results.Json(
+            ErrorResponse.Create(ErrorCodes.AuthUnauthorized, "Tenant context not available", requestId),
+            statusCode: 401);
+    }
+
+    var (response, errorCode, errorMessage, statusCode) = await triggerProcessor.ProcessTriggerAsync(
+        tenantContext.TenantId, request, CancellationToken.None);
+
+    if (response == null)
+    {
+        return Results.Json(
+            ErrorResponse.Create(errorCode!, errorMessage!, requestId),
+            statusCode: statusCode);
+    }
+
+    jsonLogger.StepInfo(
+        $"Trigger processed: event={request.Event}, message_id={response.MessageId}, template={response.TemplateId}",
+        requestId);
+
+    return Results.Json(response, statusCode: 202);
+});
+
+app.MapPost("/api/v1/webhook/delivery-status", async (
+    HttpContext ctx,
+    OutboundRepository repository,
+    JsonLinesLogger jsonLogger,
+    DeliveryStatusRequest? request) =>
+{
+    var requestId = ctx.Request.Headers["X-Request-Id"].FirstOrDefault() ?? Guid.NewGuid().ToString("N");
+
+    if (request == null || string.IsNullOrWhiteSpace(request.ExternalMessageId))
+    {
+        return Results.Json(
+            ErrorResponse.Create(ErrorCodes.OutboundDeliveryStatusFailed, "external_message_id is required", requestId),
+            statusCode: 400);
+    }
+
+    if (request.Status is not ("sent" or "delivered" or "read" or "failed"))
+    {
+        return Results.Json(
+            ErrorResponse.Create(ErrorCodes.OutboundDeliveryStatusFailed,
+                "status must be one of: sent, delivered, read, failed", requestId),
+            statusCode: 400);
+    }
+
+    var found = await repository.FindMessageByExternalIdAsync(request.ExternalMessageId);
+    if (found == null)
+    {
+        return Results.Json(
+            ErrorResponse.Create(ErrorCodes.OutboundDeliveryStatusFailed,
+                $"Message not found for external_message_id: {request.ExternalMessageId}", requestId),
+            statusCode: 404);
+    }
+
+    var (messageId, broadcastId, tenantId) = found.Value;
+
+    await repository.UpdateMessageStatusAsync(
+        messageId, request.Status, failedReason: request.FailedReason);
+
+    // Update broadcast counters if applicable
+    if (broadcastId.HasValue && request.Status is "delivered" or "read" or "failed")
+    {
+        await repository.IncrementBroadcastCounterAsync(broadcastId.Value, request.Status);
+    }
+
+    jsonLogger.StepInfo(
+        $"Delivery status updated: external_id={request.ExternalMessageId}, status={request.Status}", requestId);
+
+    return Results.Ok(new { updated = true });
+});
+
+app.MapPost("/api/v1/webhook/message", async (
+    HttpContext ctx,
+    OptOutManager optOutManager,
+    JsonLinesLogger jsonLogger,
+    IncomingMessageRequest? request) =>
+{
+    var requestId = ctx.Request.Headers["X-Request-Id"].FirstOrDefault() ?? Guid.NewGuid().ToString("N");
+
+    if (request == null || string.IsNullOrWhiteSpace(request.Phone) || string.IsNullOrWhiteSpace(request.MessageText))
+    {
+        return Results.Json(
+            ErrorResponse.Create(ErrorCodes.OutboundInvalidBroadcastPayload, "phone and message_text are required", requestId),
+            statusCode: 400);
+    }
+
+    var tenantContext = ctx.Items["TenantContext"] as TenantContext;
+    if (tenantContext == null)
+    {
+        return Results.Json(
+            ErrorResponse.Create(ErrorCodes.AuthUnauthorized, "Tenant context not available", requestId),
+            statusCode: 401);
+    }
+
+    var (optedOut, keyword) = await optOutManager.ProcessIncomingMessageAsync(
+        tenantContext.TenantId, request.Phone, request.MessageText);
+
+    if (optedOut)
+    {
+        jsonLogger.StepInfo(
+            $"Opt-out detected: tenant={tenantContext.TenantId}, phone={request.Phone}, keyword={keyword}", requestId);
+    }
+
+    return Results.Ok(new IncomingMessageResponse
+    {
+        OptedOut = optedOut,
+        KeywordMatched = keyword
+    });
+});
+
+// ============================================================
+// Template CRUD endpoints
+// ============================================================
+
+app.MapGet("/api/v1/templates", async (
+    HttpContext ctx,
+    OutboundRepository repository) =>
+{
+    var tenantContext = ctx.Items["TenantContext"] as TenantContext;
+    if (tenantContext == null)
+        return Results.Json(ErrorResponse.Create(ErrorCodes.AuthUnauthorized, "Tenant context not available", "-"), statusCode: 401);
+
+    var templates = await repository.GetActiveTemplatesAsync(tenantContext.TenantId);
+    return Results.Ok(new { templates });
+});
+
+app.MapPost("/api/v1/templates", async (
+    HttpContext ctx,
+    OutboundRepository repository,
+    JsonLinesLogger jsonLogger,
+    TemplateCreateRequest? request) =>
+{
+    var requestId = ctx.Request.Headers["X-Request-Id"].FirstOrDefault() ?? Guid.NewGuid().ToString("N");
+
+    if (request == null || string.IsNullOrWhiteSpace(request.Name) || string.IsNullOrWhiteSpace(request.MessageTemplate))
+    {
+        return Results.Json(
+            ErrorResponse.Create(ErrorCodes.OutboundInvalidTemplatePayload, "name and message_template are required", requestId),
+            statusCode: 400);
+    }
+
+    if (request.Name.Length > 200)
+    {
+        return Results.Json(
+            ErrorResponse.Create(ErrorCodes.OutboundInvalidTemplatePayload, "name must be 200 characters or less", requestId),
+            statusCode: 400);
+    }
+
+    // Validate trigger_event
+    var validEvents = new[] { "manual", "new_lead", "payment_received", "appointment_reminder" };
+    if (!validEvents.Contains(request.TriggerEvent))
+    {
+        return Results.Json(
+            ErrorResponse.Create(ErrorCodes.OutboundInvalidTemplatePayload,
+                $"trigger_event must be one of: {string.Join(", ", validEvents)}", requestId),
+            statusCode: 400);
+    }
+
+    var tenantContext = ctx.Items["TenantContext"] as TenantContext;
+    if (tenantContext == null)
+        return Results.Json(ErrorResponse.Create(ErrorCodes.AuthUnauthorized, "Tenant context not available", requestId), statusCode: 401);
+
+    var id = await repository.CreateTemplateAsync(
+        tenantContext.TenantId, request.Name, request.TriggerEvent,
+        request.MessageTemplate, request.VariablesJson);
+
+    jsonLogger.StepInfo($"Template created: id={id}, name={request.Name}, event={request.TriggerEvent}", requestId);
+
+    return Results.Json(new { id, name = request.Name }, statusCode: 201);
+});
+
+app.MapPut("/api/v1/templates/{id:int}", async (
+    HttpContext ctx,
+    OutboundRepository repository,
+    JsonLinesLogger jsonLogger,
+    int id,
+    TemplateUpdateRequest? request) =>
+{
+    var requestId = ctx.Request.Headers["X-Request-Id"].FirstOrDefault() ?? Guid.NewGuid().ToString("N");
+
+    if (request == null)
+    {
+        return Results.Json(
+            ErrorResponse.Create(ErrorCodes.OutboundInvalidTemplatePayload, "Request body is required", requestId),
+            statusCode: 400);
+    }
+
+    // Validate trigger_event if provided
+    if (request.TriggerEvent != null)
+    {
+        var validEvents = new[] { "manual", "new_lead", "payment_received", "appointment_reminder" };
+        if (!validEvents.Contains(request.TriggerEvent))
+        {
+            return Results.Json(
+                ErrorResponse.Create(ErrorCodes.OutboundInvalidTemplatePayload,
+                    $"trigger_event must be one of: {string.Join(", ", validEvents)}", requestId),
+                statusCode: 400);
+        }
+    }
+
+    var tenantContext = ctx.Items["TenantContext"] as TenantContext;
+    if (tenantContext == null)
+        return Results.Json(ErrorResponse.Create(ErrorCodes.AuthUnauthorized, "Tenant context not available", requestId), statusCode: 401);
+
+    var updated = await repository.UpdateTemplateAsync(tenantContext.TenantId, id, request);
+    if (!updated)
+    {
+        return Results.Json(
+            ErrorResponse.Create(ErrorCodes.OutboundTemplateNotFound, $"Template {id} not found or inactive", requestId),
+            statusCode: 404);
+    }
+
+    jsonLogger.StepInfo($"Template updated: id={id}", requestId);
+    return Results.Ok(new { id, updated = true });
+});
+
+app.MapDelete("/api/v1/templates/{id:int}", async (
+    HttpContext ctx,
+    OutboundRepository repository,
+    JsonLinesLogger jsonLogger,
+    int id) =>
+{
+    var requestId = ctx.Request.Headers["X-Request-Id"].FirstOrDefault() ?? Guid.NewGuid().ToString("N");
+
+    var tenantContext = ctx.Items["TenantContext"] as TenantContext;
+    if (tenantContext == null)
+        return Results.Json(ErrorResponse.Create(ErrorCodes.AuthUnauthorized, "Tenant context not available", requestId), statusCode: 401);
+
+    var deactivated = await repository.DeactivateTemplateAsync(tenantContext.TenantId, id);
+    if (!deactivated)
+    {
+        return Results.Json(
+            ErrorResponse.Create(ErrorCodes.OutboundTemplateNotFound, $"Template {id} not found or already inactive", requestId),
+            statusCode: 404);
+    }
+
+    jsonLogger.StepInfo($"Template deactivated: id={id}", requestId);
+    return Results.Ok(new { id, deactivated = true });
+});
+
+// ============================================================
+// Opt-out endpoints
+// ============================================================
+
+app.MapPost("/api/v1/optout", async (
+    HttpContext ctx,
+    OutboundRepository repository,
+    JsonLinesLogger jsonLogger,
+    OptOutRequest? request) =>
+{
+    var requestId = ctx.Request.Headers["X-Request-Id"].FirstOrDefault() ?? Guid.NewGuid().ToString("N");
+
+    if (request == null || string.IsNullOrWhiteSpace(request.Phone))
+    {
+        return Results.Json(
+            ErrorResponse.Create(ErrorCodes.OutboundInvalidBroadcastPayload, "phone is required", requestId),
+            statusCode: 400);
+    }
+
+    var tenantContext = ctx.Items["TenantContext"] as TenantContext;
+    if (tenantContext == null)
+        return Results.Json(ErrorResponse.Create(ErrorCodes.AuthUnauthorized, "Tenant context not available", requestId), statusCode: 401);
+
+    await repository.AddOptOutAsync(tenantContext.TenantId, request.Phone, request.Reason);
+    jsonLogger.StepInfo($"Manual opt-out added: phone={request.Phone}", requestId);
+
+    return Results.Ok(new { phone = request.Phone, opted_out = true });
+});
+
+app.MapDelete("/api/v1/optout/{phone}", async (
+    HttpContext ctx,
+    OutboundRepository repository,
+    JsonLinesLogger jsonLogger,
+    string phone) =>
+{
+    var requestId = ctx.Request.Headers["X-Request-Id"].FirstOrDefault() ?? Guid.NewGuid().ToString("N");
+
+    var tenantContext = ctx.Items["TenantContext"] as TenantContext;
+    if (tenantContext == null)
+        return Results.Json(ErrorResponse.Create(ErrorCodes.AuthUnauthorized, "Tenant context not available", requestId), statusCode: 401);
+
+    var removed = await repository.RemoveOptOutAsync(tenantContext.TenantId, phone);
+    if (!removed)
+    {
+        return Results.Json(
+            ErrorResponse.Create(ErrorCodes.OutboundRecipientOptedOut, $"Opt-out record not found for {phone}", requestId),
+            statusCode: 404);
+    }
+
+    jsonLogger.StepInfo($"Opt-out removed: phone={phone}", requestId);
+    return Results.Ok(new { phone, removed = true });
+});
+
+app.MapGet("/api/v1/optout/check/{phone}", async (
+    HttpContext ctx,
+    OutboundRepository repository,
+    string phone) =>
+{
+    var tenantContext = ctx.Items["TenantContext"] as TenantContext;
+    if (tenantContext == null)
+        return Results.Json(ErrorResponse.Create(ErrorCodes.AuthUnauthorized, "Tenant context not available", "-"), statusCode: 401);
+
+    var optOutDate = await repository.GetOptOutDateAsync(tenantContext.TenantId, phone);
+    return Results.Ok(new OptOutCheckResponse
+    {
+        Phone = phone,
+        OptedOut = optOutDate.HasValue,
+        OptedOutAt = optOutDate
+    });
+});
+
+// ============================================================
+// Endpoint discovery
+// ============================================================
+
+app.MapGet("/api/ops/endpoints", () =>
+{
+    var endpoints = new List<EndpointInfo>
+    {
+        new() { Method = "POST", Path = "/api/v1/broadcast/send", Description = "Submit broadcast (async, 202)", Auth = "Bearer JWT", Category = "Broadcast" },
+        new() { Method = "GET", Path = "/api/v1/broadcast/{broadcastId}/status", Description = "Get broadcast delivery status", Auth = "Bearer JWT", Category = "Broadcast" },
+        new() { Method = "POST", Path = "/api/v1/webhook/trigger", Description = "Receive trigger event from Main App", Auth = "Bearer JWT", Category = "Webhook" },
+        new() { Method = "POST", Path = "/api/v1/webhook/delivery-status", Description = "Receive delivery status update", Auth = "Bearer JWT", Category = "Webhook" },
+        new() { Method = "POST", Path = "/api/v1/webhook/message", Description = "Receive incoming message for opt-out detection", Auth = "Bearer JWT", Category = "Webhook" },
+        new() { Method = "GET", Path = "/api/v1/templates", Description = "List active templates", Auth = "Bearer JWT", Category = "Templates" },
+        new() { Method = "POST", Path = "/api/v1/templates", Description = "Create template", Auth = "Bearer JWT", Category = "Templates" },
+        new() { Method = "PUT", Path = "/api/v1/templates/{id}", Description = "Update template", Auth = "Bearer JWT", Category = "Templates" },
+        new() { Method = "DELETE", Path = "/api/v1/templates/{id}", Description = "Deactivate template", Auth = "Bearer JWT", Category = "Templates" },
+        new() { Method = "POST", Path = "/api/v1/optout", Description = "Manual opt-out add", Auth = "Bearer JWT", Category = "OptOut" },
+        new() { Method = "DELETE", Path = "/api/v1/optout/{phone}", Description = "Remove opt-out", Auth = "Bearer JWT", Category = "OptOut" },
+        new() { Method = "GET", Path = "/api/v1/optout/check/{phone}", Description = "Check if phone opted out", Auth = "Bearer JWT", Category = "OptOut" },
+        new() { Method = "GET", Path = "/health", Description = "Health check", Auth = "none", Category = "Health" },
+        new() { Method = "GET", Path = "/ready", Description = "Readiness probe (DB check)", Auth = "none", Category = "Health" },
+        new() { Method = "GET", Path = "/api/ops/endpoints", Description = "Endpoint discovery (this)", Auth = "none", Category = "Ops" },
+    };
+
+    return Results.Ok(new EndpointDiscoveryResponse
+    {
+        Service = ServiceConstants.OutboundServiceName,
+        Port = ServiceConstants.OutboundPort,
+        Endpoints = endpoints
+    });
+});
+
+logger.SystemInfo($"Outbound service starting on port {listenPort}");
+app.Run();
+
+// Required for integration tests
+public partial class Program { }
diff --git a/src/Invekto.Outbound/Services/BroadcastOrchestrator.cs b/src/Invekto.Outbound/Services/BroadcastOrchestrator.cs
new file mode 100644
index 0000000..bbb0c23
--- /dev/null
+++ b/src/Invekto.Outbound/Services/BroadcastOrchestrator.cs
@@ -0,0 +1,115 @@
+using Invekto.Outbound.Data;
+using Invekto.Shared.Constants;
+using Invekto.Shared.DTOs.Outbound;
+using Invekto.Shared.Logging;
+
+namespace Invekto.Outbound.Services;
+
+/// <summary>
+/// Orchestrates broadcast creation: validates, checks opt-outs,
+/// applies template, inserts messages as 'queued'.
+/// Thread-safe, register as singleton.
+/// </summary>
+public sealed class BroadcastOrchestrator
+{
+    private readonly OutboundRepository _repository;
+    private readonly TemplateEngine _templateEngine;
+    private readonly OptOutManager _optOutManager;
+    private readonly JsonLinesLogger _logger;
+
+    public BroadcastOrchestrator(
+        OutboundRepository repository,
+        TemplateEngine templateEngine,
+        OptOutManager optOutManager,
+        JsonLinesLogger logger)
+    {
+        _repository = repository;
+        _templateEngine = templateEngine;
+        _optOutManager = optOutManager;
+        _logger = logger;
+    }
+
+    /// <summary>
+    /// Create a broadcast: validate template, filter opt-outs, insert messages.
+    /// Returns the broadcast response or an error tuple.
+    /// </summary>
+    public async Task<(BroadcastSendResponse? response, string? errorCode, string? errorMessage)>
+        CreateBroadcastAsync(
+            int tenantId, BroadcastSendRequest request, CancellationToken ct = default)
+    {
+        // Validate recipients count
+        if (request.Recipients == null || request.Recipients.Count == 0)
+            return (null, ErrorCodes.OutboundInvalidBroadcastPayload, "recipients is required and cannot be empty");
+
+        if (request.Recipients.Count > 1000)
+            return (null, ErrorCodes.OutboundTooManyRecipients, $"Max 1000 recipients per broadcast, got {request.Recipients.Count}");
+
+        // Validate template exists
+        var template = await _repository.GetTemplateByIdAsync(tenantId, request.TemplateId, ct);
+        if (template == null)
+            return (null, ErrorCodes.OutboundTemplateNotFound, $"Template {request.TemplateId} not found or inactive");
+
+        // Collect valid phones for batch opt-out check
+        var validRecipients = request.Recipients
+            .Where(r => !string.IsNullOrWhiteSpace(r.Phone))
+            .ToList();
+
+        // Batch opt-out check (single query instead of N queries)
+        var phones = validRecipients.Select(r => r.Phone).ToList();
+        var optedOutPhones = await _repository.BatchCheckOptOutsAsync(tenantId, phones, ct);
+
+        // Filter and prepare messages
+        var skippedOptout = 0;
+        var messagesToInsert = new List<(string phone, string text)>();
+
+        foreach (var recipient in validRecipients)
+        {
+            if (optedOutPhones.Contains(recipient.Phone))
+            {
+                skippedOptout++;
+                continue;
+            }
+
+            // Apply template variables
+            var (messageText, missingVars) = _templateEngine.Substitute(
+                template.MessageTemplate, recipient.Variables);
+
+            if (missingVars.Count > 0)
+            {
+                _logger.SystemWarn(
+                    $"Broadcast skipping {recipient.Phone}: missing variables [{string.Join(", ", missingVars)}]");
+                continue;
+            }
+
+            messagesToInsert.Add((recipient.Phone, messageText));
+        }
+
+        if (messagesToInsert.Count == 0)
+        {
+            return (null, ErrorCodes.OutboundInvalidBroadcastPayload,
+                "No valid recipients after opt-out filtering and variable validation");
+        }
+
+        // Create broadcast record
+        var broadcastId = await _repository.CreateBroadcastAsync(
+            tenantId, request.TemplateId, request.Recipients.Count,
+            messagesToInsert.Count, request.ScheduledAt, ct);
+
+        // Batch insert all messages (single multi-row INSERT)
+        await _repository.BatchInsertMessagesAsync(
+            tenantId, broadcastId, request.TemplateId, messagesToInsert, ct);
+        var queuedCount = messagesToInsert.Count;
+
+        _logger.SystemInfo(
+            $"Broadcast created: id={broadcastId}, tenant={tenantId}, " +
+            $"total={request.Recipients.Count}, queued={queuedCount}, skipped_optout={skippedOptout}");
+
+        return (new BroadcastSendResponse
+        {
+            BroadcastId = broadcastId,
+            TotalRecipients = request.Recipients.Count,
+            Queued = queuedCount,
+            SkippedOptout = skippedOptout
+        }, null, null);
+    }
+}
diff --git a/src/Invekto.Outbound/Services/MessageSenderService.cs b/src/Invekto.Outbound/Services/MessageSenderService.cs
new file mode 100644
index 0000000..389f18c
--- /dev/null
+++ b/src/Invekto.Outbound/Services/MessageSenderService.cs
@@ -0,0 +1,204 @@
+using Invekto.Outbound.Data;
+using Invekto.Shared.Constants;
+using Invekto.Shared.DTOs.Integration;
+using Invekto.Shared.Integration;
+using Invekto.Shared.Logging;
+
+namespace Invekto.Outbound.Services;
+
+/// <summary>
+/// Background service that dequeues messages and sends them via Main App callback.
+/// Respects tenant-based rate limits. Graceful shutdown via CancellationToken.
+/// </summary>
+public sealed class MessageSenderService : IHostedService, IDisposable
+{
+    private readonly OutboundRepository _repository;
+    private readonly RateLimiter _rateLimiter;
+    private readonly MainAppCallbackClient _callbackClient;
+    private readonly JsonLinesLogger _logger;
+    private readonly int _intervalMs;
+
+    private Timer? _timer;
+    private int _isProcessing; // 0 = idle, 1 = processing (interlocked)
+    private CancellationTokenSource? _cts;
+
+    public MessageSenderService(
+        OutboundRepository repository,
+        RateLimiter rateLimiter,
+        MainAppCallbackClient callbackClient,
+        JsonLinesLogger logger,
+        int intervalMs = 1000)
+    {
+        _repository = repository;
+        _rateLimiter = rateLimiter;
+        _callbackClient = callbackClient;
+        _logger = logger;
+        _intervalMs = intervalMs;
+    }
+
+    public Task StartAsync(CancellationToken cancellationToken)
+    {
+        _cts = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken);
+        _logger.SystemInfo($"MessageSenderService starting (interval={_intervalMs}ms)");
+        _timer = new Timer(ProcessQueue, null, _intervalMs, _intervalMs);
+        return Task.CompletedTask;
+    }
+
+    public async Task StopAsync(CancellationToken cancellationToken)
+    {
+        _logger.SystemInfo("MessageSenderService stopping (graceful shutdown)");
+        _timer?.Change(Timeout.Infinite, 0);
+        _cts?.Cancel();
+
+        // Wait for current processing to finish (max 10s)
+        var waitCount = 0;
+        while (Interlocked.CompareExchange(ref _isProcessing, 0, 0) == 1 && waitCount < 100)
+        {
+            Thread.Sleep(100);
+            waitCount++;
+        }
+
+        // Reset any messages stuck in 'sending' back to 'queued'
+        try
+        {
+            await _repository.ResetSendingMessagesAsync(cancellationToken);
+        }
+        catch (Exception ex)
+        {
+            _logger.SystemError($"Failed to reset stale sending messages: {ex.Message}");
+        }
+    }
+
+    public void Dispose()
+    {
+        _timer?.Dispose();
+        _cts?.Dispose();
+    }
+
+    private async void ProcessQueue(object? state)
+    {
+        // Prevent overlapping processing
+        if (Interlocked.CompareExchange(ref _isProcessing, 1, 0) != 0)
+            return;
+
+        try
+        {
+            var ct = _cts?.Token ?? CancellationToken.None;
+            if (ct.IsCancellationRequested) return;
+
+            // Dequeue a small batch
+            var messages = await _repository.DequeueMessagesAsync(10, ct);
+            if (messages.Count == 0) return;
+
+            foreach (var msg in messages)
+            {
+                if (ct.IsCancellationRequested) break;
+
+                // Check rate limit per tenant
+                if (!_rateLimiter.TryAcquire(msg.TenantId))
+                {
+                    // Put back to queued (rate limited - will retry next cycle)
+                    await _repository.UpdateMessageStatusAsync(msg.Id, "queued", ct: ct);
+                    _logger.SystemInfo($"Rate limited: tenant={msg.TenantId}, message={msg.Id}, requeued");
+                    continue;
+                }
+
+                await SendMessageAsync(msg, ct);
+            }
+        }
+        catch (OperationCanceledException)
+        {
+            // Graceful shutdown
+        }
+        catch (Exception ex)
+        {
+            _logger.SystemError($"MessageSenderService error: {ex.Message}");
+        }
+        finally
+        {
+            Interlocked.Exchange(ref _isProcessing, 0);
+        }
+    }
+
+    private async Task SendMessageAsync(QueuedMessage msg, CancellationToken ct)
+    {
+        try
+        {
+            var callback = new OutgoingCallback
+            {
+                RequestId = Guid.NewGuid().ToString("N"),
+                Action = CallbackActions.SendMessage,
+                TenantId = msg.TenantId,
+                ChatId = 0, // Outbound doesn't have a chat context
+                SequenceId = msg.Id,
+                Data = new CallbackData
+                {
+                    MessageText = msg.MessageText,
+                    Phone = msg.RecipientPhone,
+                    BroadcastId = msg.BroadcastId,
+                    OutboundMessageId = msg.Id
+                },
+                ProcessingTimeMs = 0,
+                Timestamp = DateTime.UtcNow
+            };
+
+            var success = await _callbackClient.SendCallbackAsync(callback, ct: ct);
+
+            if (success)
+            {
+                // Mark as sent - delivery status will come via webhook later
+                await _repository.UpdateMessageStatusAsync(msg.Id, "sent", ct: ct);
+
+                if (msg.BroadcastId.HasValue)
+                    await _repository.IncrementBroadcastCounterAsync(msg.BroadcastId.Value, "sent", ct);
+
+                // Check if broadcast is complete
+                if (msg.BroadcastId.HasValue)
+                    await TryCompleteBroadcastAsync(msg.BroadcastId.Value, ct);
+            }
+            else
+            {
+                await _repository.UpdateMessageStatusAsync(
+                    msg.Id, "failed", failedReason: "Callback to Main App failed after retries", ct: ct);
+
+                if (msg.BroadcastId.HasValue)
+                    await _repository.IncrementBroadcastCounterAsync(msg.BroadcastId.Value, "failed", ct);
+
+                if (msg.BroadcastId.HasValue)
+                    await TryCompleteBroadcastAsync(msg.BroadcastId.Value, ct);
+
+                _logger.SystemError(
+                    $"[{ErrorCodes.OutboundMessageSendCallbackFailed}] Message send failed: " +
+                    $"id={msg.Id}, tenant={msg.TenantId}, phone={msg.RecipientPhone}");
+            }
+        }
+        catch (Exception ex)
+        {
+            _logger.SystemError($"SendMessage exception: id={msg.Id}, error={ex.Message}");
+            await _repository.UpdateMessageStatusAsync(
+                msg.Id, "failed", failedReason: $"Exception: {ex.Message}", ct: ct);
+
+            if (msg.BroadcastId.HasValue)
+            {
+                await _repository.IncrementBroadcastCounterAsync(msg.BroadcastId.Value, "failed", ct);
+                await TryCompleteBroadcastAsync(msg.BroadcastId.Value, ct);
+            }
+        }
+    }
+
+    private async Task TryCompleteBroadcastAsync(Guid broadcastId, CancellationToken ct)
+    {
+        try
+        {
+            if (await _repository.IsBroadcastCompleteAsync(broadcastId, ct))
+            {
+                await _repository.UpdateBroadcastStatusAsync(broadcastId, "completed", ct);
+                _logger.SystemInfo($"Broadcast completed: {broadcastId}");
+            }
+        }
+        catch (Exception ex)
+        {
+            _logger.SystemError($"Error checking broadcast completion: {broadcastId}, {ex.Message}");
+        }
+    }
+}
diff --git a/src/Invekto.Outbound/Services/OptOutManager.cs b/src/Invekto.Outbound/Services/OptOutManager.cs
new file mode 100644
index 0000000..5a72e9a
--- /dev/null
+++ b/src/Invekto.Outbound/Services/OptOutManager.cs
@@ -0,0 +1,74 @@
+using Invekto.Outbound.Data;
+using Invekto.Shared.Logging;
+
+namespace Invekto.Outbound.Services;
+
+/// <summary>
+/// Manages opt-out registry and stop keyword detection.
+/// Thread-safe, register as singleton.
+/// </summary>
+public sealed class OptOutManager
+{
+    private readonly OutboundRepository _repository;
+    private readonly JsonLinesLogger _logger;
+
+    // Stop keywords - normalized to uppercase for comparison
+    private static readonly string[] StopKeywords =
+    {
+        "STOP", "DUR", "─░PTAL", "IPTAL", "DURDU", "├çIKI┼₧", "CIKIS"
+    };
+
+    public OptOutManager(OutboundRepository repository, JsonLinesLogger logger)
+    {
+        _repository = repository;
+        _logger = logger;
+    }
+
+    /// <summary>
+    /// Check if a phone number has opted out for a given tenant.
+    /// </summary>
+    public Task<bool> IsOptedOutAsync(int tenantId, string phone, CancellationToken ct = default)
+        => _repository.IsOptedOutAsync(tenantId, phone, ct);
+
+    /// <summary>
+    /// Detect stop keyword in incoming message text.
+    /// Returns the matched keyword or null.
+    /// </summary>
+    public string? DetectStopKeyword(string messageText)
+    {
+        if (string.IsNullOrWhiteSpace(messageText))
+            return null;
+
+        var normalized = messageText.Trim().ToUpperInvariant();
+        foreach (var keyword in StopKeywords)
+        {
+            if (normalized == keyword)
+                return keyword;
+        }
+        return null;
+    }
+
+    /// <summary>
+    /// Process incoming message for opt-out detection.
+    /// Returns (optedOut, matchedKeyword).
+    /// </summary>
+    public async Task<(bool optedOut, string? keyword)> ProcessIncomingMessageAsync(
+        int tenantId, string phone, string messageText, CancellationToken ct = default)
+    {
+        var keyword = DetectStopKeyword(messageText);
+        if (keyword == null)
+            return (false, null);
+
+        var added = await _repository.AddOptOutAsync(tenantId, phone, $"Keyword: {keyword}", ct);
+        if (added)
+        {
+            _logger.SystemInfo($"Opt-out registered: tenant={tenantId}, phone={phone}, keyword={keyword}");
+        }
+        else
+        {
+            _logger.SystemInfo($"Opt-out already exists: tenant={tenantId}, phone={phone}");
+        }
+
+        return (true, keyword);
+    }
+}
diff --git a/src/Invekto.Outbound/Services/RateLimiter.cs b/src/Invekto.Outbound/Services/RateLimiter.cs
new file mode 100644
index 0000000..e79962d
--- /dev/null
+++ b/src/Invekto.Outbound/Services/RateLimiter.cs
@@ -0,0 +1,79 @@
+using System.Collections.Concurrent;
+using Invekto.Shared.Logging;
+
+namespace Invekto.Outbound.Services;
+
+/// <summary>
+/// Tenant-based in-memory rate limiter. Tracks messages per minute per tenant.
+/// When limit is exceeded, messages stay in the DB queue (not rejected).
+/// Thread-safe, register as singleton.
+/// </summary>
+public sealed class RateLimiter
+{
+    private readonly int _defaultMessagesPerMinute;
+    private readonly JsonLinesLogger _logger;
+
+    // Track per-tenant send timestamps (sliding window)
+    private readonly ConcurrentDictionary<int, TenantWindow> _windows = new();
+
+    public RateLimiter(int defaultMessagesPerMinute, JsonLinesLogger logger)
+    {
+        _defaultMessagesPerMinute = defaultMessagesPerMinute;
+        _logger = logger;
+    }
+
+    /// <summary>
+    /// Check if tenant can send a message right now.
+    /// Returns true if within rate limit, false if should wait.
+    /// </summary>
+    public bool TryAcquire(int tenantId)
+    {
+        var window = _windows.GetOrAdd(tenantId, _ => new TenantWindow());
+        return window.TryAcquire(_defaultMessagesPerMinute);
+    }
+
+    /// <summary>
+    /// Get how many messages tenant has sent in the current minute window.
+    /// </summary>
+    public int GetCurrentCount(int tenantId)
+    {
+        if (_windows.TryGetValue(tenantId, out var window))
+            return window.GetCurrentCount();
+        return 0;
+    }
+
+    private sealed class TenantWindow
+    {
+        private readonly object _lock = new();
+        private readonly Queue<DateTime> _timestamps = new();
+
+        public bool TryAcquire(int maxPerMinute)
+        {
+            lock (_lock)
+            {
+                PurgeOld();
+                if (_timestamps.Count >= maxPerMinute)
+                    return false;
+
+                _timestamps.Enqueue(DateTime.UtcNow);
+                return true;
+            }
+        }
+
+        public int GetCurrentCount()
+        {
+            lock (_lock)
+            {
+                PurgeOld();
+                return _timestamps.Count;
+            }
+        }
+
+        private void PurgeOld()
+        {
+            var cutoff = DateTime.UtcNow.AddMinutes(-1);
+            while (_timestamps.Count > 0 && _timestamps.Peek() < cutoff)
+                _timestamps.Dequeue();
+        }
+    }
+}
diff --git a/src/Invekto.Outbound/Services/TemplateEngine.cs b/src/Invekto.Outbound/Services/TemplateEngine.cs
new file mode 100644
index 0000000..4fc7a3b
--- /dev/null
+++ b/src/Invekto.Outbound/Services/TemplateEngine.cs
@@ -0,0 +1,37 @@
+using Invekto.Shared.Logging;
+using Invekto.Shared.Services;
+
+namespace Invekto.Outbound.Services;
+
+/// <summary>
+/// Outbound-specific template engine wrapper.
+/// Delegates core {{variable}} substitution to shared TemplateSubstitution.
+/// Thread-safe, register as singleton.
+/// </summary>
+public sealed class TemplateEngine
+{
+    private readonly JsonLinesLogger _logger;
+
+    public TemplateEngine(JsonLinesLogger logger)
+    {
+        _logger = logger;
+    }
+
+    /// <summary>
+    /// Apply variables to a template string. Returns (result, missingVars).
+    /// If any variables are missing, the message is NOT sent (missingVars.Count > 0).
+    /// </summary>
+    public (string result, List<string> missingVars) Substitute(
+        string template, Dictionary<string, string>? variables)
+    {
+        return TemplateSubstitution.Substitute(template, variables);
+    }
+
+    /// <summary>
+    /// Extract all variable names from a template string.
+    /// </summary>
+    public static List<string> ExtractVariables(string template)
+    {
+        return TemplateSubstitution.ExtractVariables(template);
+    }
+}
diff --git a/src/Invekto.Outbound/Services/TriggerProcessor.cs b/src/Invekto.Outbound/Services/TriggerProcessor.cs
new file mode 100644
index 0000000..3019f9b
--- /dev/null
+++ b/src/Invekto.Outbound/Services/TriggerProcessor.cs
@@ -0,0 +1,88 @@
+using Invekto.Outbound.Data;
+using Invekto.Shared.Constants;
+using Invekto.Shared.DTOs.Outbound;
+using Invekto.Shared.Logging;
+
+namespace Invekto.Outbound.Services;
+
+/// <summary>
+/// Processes trigger events from Main App webhooks.
+/// Finds matching template, applies variables, inserts single message.
+/// Thread-safe, register as singleton.
+/// </summary>
+public sealed class TriggerProcessor
+{
+    private readonly OutboundRepository _repository;
+    private readonly TemplateEngine _templateEngine;
+    private readonly OptOutManager _optOutManager;
+    private readonly JsonLinesLogger _logger;
+
+    public TriggerProcessor(
+        OutboundRepository repository,
+        TemplateEngine templateEngine,
+        OptOutManager optOutManager,
+        JsonLinesLogger logger)
+    {
+        _repository = repository;
+        _templateEngine = templateEngine;
+        _optOutManager = optOutManager;
+        _logger = logger;
+    }
+
+    /// <summary>
+    /// Process a trigger event. Returns response or error.
+    /// </summary>
+    public async Task<(TriggerWebhookResponse? response, string? errorCode, string? errorMessage, int statusCode)>
+        ProcessTriggerAsync(
+            int tenantId, TriggerWebhookRequest request, CancellationToken ct = default)
+    {
+        if (string.IsNullOrWhiteSpace(request.Event))
+            return (null, ErrorCodes.OutboundInvalidBroadcastPayload, "event is required", 400);
+
+        if (string.IsNullOrWhiteSpace(request.Phone))
+            return (null, ErrorCodes.OutboundInvalidBroadcastPayload, "phone is required", 400);
+
+        // Check opt-out
+        if (await _optOutManager.IsOptedOutAsync(tenantId, request.Phone, ct))
+        {
+            _logger.SystemInfo($"Trigger skipped (opted out): tenant={tenantId}, phone={request.Phone}, event={request.Event}");
+            return (null, ErrorCodes.OutboundRecipientOptedOut,
+                $"Recipient {request.Phone} has opted out of messages", 409);
+        }
+
+        // Find matching trigger template
+        var template = await _repository.GetTriggerTemplateAsync(tenantId, request.Event, ct);
+        if (template == null)
+        {
+            return (null, ErrorCodes.OutboundNoMatchingTriggerTemplate,
+                $"No active template found for event '{request.Event}' in tenant {tenantId}", 404);
+        }
+
+        // Apply template variables
+        var (messageText, missingVars) = _templateEngine.Substitute(
+            template.MessageTemplate, request.Variables);
+
+        if (missingVars.Count > 0)
+        {
+            _logger.SystemWarn(
+                $"Trigger template {template.Id} has missing variables: [{string.Join(", ", missingVars)}]");
+            return (null, ErrorCodes.OutboundInvalidBroadcastPayload,
+                $"Template requires variables: {string.Join(", ", missingVars)}", 400);
+        }
+
+        // Insert single message (no broadcast_id)
+        var messageId = await _repository.InsertMessageAsync(
+            tenantId, null, template.Id, request.Phone, messageText, ct);
+
+        _logger.SystemInfo(
+            $"Trigger message queued: id={messageId}, tenant={tenantId}, " +
+            $"event={request.Event}, phone={request.Phone}, template={template.Id}");
+
+        return (new TriggerWebhookResponse
+        {
+            MessageId = messageId,
+            TemplateId = template.Id,
+            TemplateName = template.Name
+        }, null, null, 202);
+    }
+}
diff --git a/src/Invekto.Outbound/appsettings.json b/src/Invekto.Outbound/appsettings.json
new file mode 100644
index 0000000..490e373
--- /dev/null
+++ b/src/Invekto.Outbound/appsettings.json
@@ -0,0 +1,27 @@
+{
+  "Service": {
+    "ListenPort": 7107
+  },
+  "Logging": {
+    "FilePath": "logs"
+  },
+  "Jwt": {
+    "SecretKey": "",
+    "Issuer": null,
+    "Audience": null,
+    "ClockSkewSeconds": 60
+  },
+  "ConnectionStrings": {
+    "PostgreSQL": "Host=localhost;Port=5432;Database=invekto;Username=invekto;Password="
+  },
+  "RateLimit": {
+    "DefaultMessagesPerMinute": 30,
+    "SenderIntervalMs": 1000
+  },
+  "Callback": {
+    "DefaultCallbackUrl": "",
+    "MaxRetries": 3,
+    "BaseDelayMs": 500,
+    "TimeoutMs": 5000
+  }
+}
diff --git a/src/Invekto.Shared/Constants/ErrorCodes.cs b/src/Invekto.Shared/Constants/ErrorCodes.cs
index 9c5c16f..cf41acc 100644
--- a/src/Invekto.Shared/Constants/ErrorCodes.cs
+++ b/src/Invekto.Shared/Constants/ErrorCodes.cs
@@ -55,6 +55,18 @@ public static class ErrorCodes
     public const string AgentAIClaudeTimeout = "INV-AA-005";
     public const string AgentAIInvalidFeedback = "INV-AA-006";
 
+    // Outbound errors (INV-OB-xxx) -- GR-1.3
+    public const string OutboundInvalidBroadcastPayload = "INV-OB-001";
+    public const string OutboundTemplateNotFound = "INV-OB-002";
+    public const string OutboundRateLimitExceeded = "INV-OB-003";
+    public const string OutboundRecipientOptedOut = "INV-OB-004";
+    public const string OutboundBroadcastNotFound = "INV-OB-005";
+    public const string OutboundDeliveryStatusFailed = "INV-OB-006";
+    public const string OutboundInvalidTemplatePayload = "INV-OB-007";
+    public const string OutboundNoMatchingTriggerTemplate = "INV-OB-008";
+    public const string OutboundMessageSendCallbackFailed = "INV-OB-009";
+    public const string OutboundTooManyRecipients = "INV-OB-010";
+
     // Database errors (INV-DB-xxx)
     public const string DatabaseConnectionFailed = "INV-DB-001";
     public const string DatabaseQueryTimeout = "INV-DB-002";
diff --git a/src/Invekto.Shared/DTOs/Integration/OutgoingCallback.cs b/src/Invekto.Shared/DTOs/Integration/OutgoingCallback.cs
index fa506e4..991eefa 100644
--- a/src/Invekto.Shared/DTOs/Integration/OutgoingCallback.cs
+++ b/src/Invekto.Shared/DTOs/Integration/OutgoingCallback.cs
@@ -77,6 +77,19 @@ public sealed class CallbackData
     /// <summary>Error message when processing fails</summary>
     [JsonPropertyName("error_message")]
     public string? ErrorMessage { get; init; }
+
+    // GR-1.3 Outbound: fields for send_message callback
+    /// <summary>Recipient phone number (E.164 format) for outbound message delivery</summary>
+    [JsonPropertyName("phone")]
+    public string? Phone { get; init; }
+
+    /// <summary>Broadcast ID that this message belongs to (null for trigger-based)</summary>
+    [JsonPropertyName("broadcast_id")]
+    public Guid? BroadcastId { get; init; }
+
+    /// <summary>Outbound message record ID for delivery status correlation</summary>
+    [JsonPropertyName("outbound_message_id")]
+    public long? OutboundMessageId { get; init; }
 }
 
 /// <summary>
diff --git a/src/Invekto.Shared/DTOs/Outbound/BroadcastDtos.cs b/src/Invekto.Shared/DTOs/Outbound/BroadcastDtos.cs
new file mode 100644
index 0000000..2205700
--- /dev/null
+++ b/src/Invekto.Shared/DTOs/Outbound/BroadcastDtos.cs
@@ -0,0 +1,85 @@
+using System.Text.Json.Serialization;
+
+namespace Invekto.Shared.DTOs.Outbound;
+
+/// <summary>
+/// POST /api/v1/broadcast/send request body.
+/// Main App sends recipients + template_id to start a broadcast.
+/// </summary>
+public sealed class BroadcastSendRequest
+{
+    [JsonPropertyName("template_id")]
+    public int TemplateId { get; set; }
+
+    [JsonPropertyName("recipients")]
+    public List<BroadcastRecipient> Recipients { get; set; } = new();
+
+    [JsonPropertyName("scheduled_at")]
+    public DateTime? ScheduledAt { get; set; }
+}
+
+public sealed class BroadcastRecipient
+{
+    [JsonPropertyName("phone")]
+    public string Phone { get; set; } = "";
+
+    [JsonPropertyName("variables")]
+    public Dictionary<string, string>? Variables { get; set; }
+}
+
+/// <summary>
+/// 202 Accepted response for broadcast send.
+/// </summary>
+public sealed class BroadcastSendResponse
+{
+    [JsonPropertyName("broadcast_id")]
+    public Guid BroadcastId { get; set; }
+
+    [JsonPropertyName("total_recipients")]
+    public int TotalRecipients { get; set; }
+
+    [JsonPropertyName("queued")]
+    public int Queued { get; set; }
+
+    [JsonPropertyName("skipped_optout")]
+    public int SkippedOptout { get; set; }
+}
+
+/// <summary>
+/// GET /api/v1/broadcast/{broadcastId}/status response.
+/// </summary>
+public sealed class BroadcastStatusResponse
+{
+    [JsonPropertyName("broadcast_id")]
+    public Guid BroadcastId { get; set; }
+
+    [JsonPropertyName("status")]
+    public string Status { get; set; } = "";
+
+    [JsonPropertyName("total_recipients")]
+    public int TotalRecipients { get; set; }
+
+    [JsonPropertyName("queued")]
+    public int Queued { get; set; }
+
+    [JsonPropertyName("sent")]
+    public int Sent { get; set; }
+
+    [JsonPropertyName("delivered")]
+    public int Delivered { get; set; }
+
+    [JsonPropertyName("read")]
+    public int Read { get; set; }
+
+    [JsonPropertyName("failed")]
+    public int Failed { get; set; }
+
+    [JsonPropertyName("created_at")]
+    public DateTime CreatedAt { get; set; }
+
+    [JsonPropertyName("started_at")]
+    public DateTime? StartedAt { get; set; }
+
+    [JsonPropertyName("completed_at")]
+    public DateTime? CompletedAt { get; set; }
+}
diff --git a/src/Invekto.Shared/DTOs/Outbound/TemplateDtos.cs b/src/Invekto.Shared/DTOs/Outbound/TemplateDtos.cs
new file mode 100644
index 0000000..972d0c0
--- /dev/null
+++ b/src/Invekto.Shared/DTOs/Outbound/TemplateDtos.cs
@@ -0,0 +1,69 @@
+using System.Text.Json.Serialization;
+
+namespace Invekto.Shared.DTOs.Outbound;
+
+/// <summary>
+/// POST /api/v1/templates request body.
+/// </summary>
+public sealed class TemplateCreateRequest
+{
+    [JsonPropertyName("name")]
+    public string Name { get; set; } = "";
+
+    [JsonPropertyName("trigger_event")]
+    public string TriggerEvent { get; set; } = "manual";
+
+    [JsonPropertyName("message_template")]
+    public string MessageTemplate { get; set; } = "";
+
+    [JsonPropertyName("variables_json")]
+    public Dictionary<string, string>? VariablesJson { get; set; }
+}
+
+/// <summary>
+/// PUT /api/v1/templates/{id} request body. All fields optional.
+/// </summary>
+public sealed class TemplateUpdateRequest
+{
+    [JsonPropertyName("name")]
+    public string? Name { get; set; }
+
+    [JsonPropertyName("trigger_event")]
+    public string? TriggerEvent { get; set; }
+
+    [JsonPropertyName("message_template")]
+    public string? MessageTemplate { get; set; }
+
+    [JsonPropertyName("variables_json")]
+    public Dictionary<string, string>? VariablesJson { get; set; }
+}
+
+/// <summary>
+/// Template list item in GET /api/v1/templates response.
+/// </summary>
+public sealed class TemplateDto
+{
+    [JsonPropertyName("id")]
+    public int Id { get; set; }
+
+    [JsonPropertyName("name")]
+    public string Name { get; set; } = "";
+
+    [JsonPropertyName("trigger_event")]
+    public string TriggerEvent { get; set; } = "";
+
+    [JsonPropertyName("message_template")]
+    public string MessageTemplate { get; set; } = "";
+
+    [JsonPropertyName("variables_json")]
+    public Dictionary<string, string>? VariablesJson { get; set; }
+
+    [JsonPropertyName("is_active")]
+    public bool IsActive { get; set; }
+
+    [JsonPropertyName("created_at")]
+    public DateTime CreatedAt { get; set; }
+
+    [JsonPropertyName("updated_at")]
+    public DateTime UpdatedAt { get; set; }
+}
diff --git a/src/Invekto.Shared/DTOs/Outbound/WebhookDtos.cs b/src/Invekto.Shared/DTOs/Outbound/WebhookDtos.cs
new file mode 100644
index 0000000..03f239f
--- /dev/null
+++ b/src/Invekto.Shared/DTOs/Outbound/WebhookDtos.cs
@@ -0,0 +1,102 @@
+using System.Text.Json.Serialization;
+
+namespace Invekto.Shared.DTOs.Outbound;
+
+/// <summary>
+/// POST /api/v1/webhook/trigger request - event from Main App triggers a template message.
+/// </summary>
+public sealed class TriggerWebhookRequest
+{
+    [JsonPropertyName("event")]
+    public string Event { get; set; } = "";
+
+    [JsonPropertyName("phone")]
+    public string Phone { get; set; } = "";
+
+    [JsonPropertyName("variables")]
+    public Dictionary<string, string>? Variables { get; set; }
+}
+
+/// <summary>
+/// 202 response for trigger webhook.
+/// </summary>
+public sealed class TriggerWebhookResponse
+{
+    [JsonPropertyName("message_id")]
+    public long MessageId { get; set; }
+
+    [JsonPropertyName("template_id")]
+    public int TemplateId { get; set; }
+
+    [JsonPropertyName("template_name")]
+    public string TemplateName { get; set; } = "";
+}
+
+/// <summary>
+/// POST /api/v1/webhook/delivery-status - delivery status from Main App.
+/// </summary>
+public sealed class DeliveryStatusRequest
+{
+    [JsonPropertyName("external_message_id")]
+    public string ExternalMessageId { get; set; } = "";
+
+    [JsonPropertyName("status")]
+    public string Status { get; set; } = "";
+
+    [JsonPropertyName("failed_reason")]
+    public string? FailedReason { get; set; }
+
+    [JsonPropertyName("timestamp")]
+    public DateTime? Timestamp { get; set; }
+}
+
+/// <summary>
+/// POST /api/v1/webhook/message - incoming message for opt-out detection.
+/// </summary>
+public sealed class IncomingMessageRequest
+{
+    [JsonPropertyName("phone")]
+    public string Phone { get; set; } = "";
+
+    [JsonPropertyName("message_text")]
+    public string MessageText { get; set; } = "";
+}
+
+/// <summary>
+/// Response for incoming message opt-out check.
+/// </summary>
+public sealed class IncomingMessageResponse
+{
+    [JsonPropertyName("opted_out")]
+    public bool OptedOut { get; set; }
+
+    [JsonPropertyName("keyword_matched")]
+    public string? KeywordMatched { get; set; }
+}
+
+/// <summary>
+/// POST /api/v1/optout request - manual opt-out add.
+/// </summary>
+public sealed class OptOutRequest
+{
+    [JsonPropertyName("phone")]
+    public string Phone { get; set; } = "";
+
+    [JsonPropertyName("reason")]
+    public string? Reason { get; set; }
+}
+
+/// <summary>
+/// GET /api/v1/optout/check/{phone} response.
+/// </summary>
+public sealed class OptOutCheckResponse
+{
+    [JsonPropertyName("phone")]
+    public string Phone { get; set; } = "";
+
+    [JsonPropertyName("opted_out")]
+    public bool OptedOut { get; set; }
+
+    [JsonPropertyName("opted_out_at")]
+    public DateTime? OptedOutAt { get; set; }
+}
diff --git a/src/Invekto.Shared/Services/TemplateSubstitution.cs b/src/Invekto.Shared/Services/TemplateSubstitution.cs
new file mode 100644
index 0000000..1e8cb7a
--- /dev/null
+++ b/src/Invekto.Shared/Services/TemplateSubstitution.cs
@@ -0,0 +1,52 @@
+using System.Text.RegularExpressions;
+
+namespace Invekto.Shared.Services;
+
+/// <summary>
+/// Shared {{variable}} substitution utility.
+/// Used by Outbound (broadcast templates) and AgentAI (reply templates).
+/// Thread-safe static methods.
+/// </summary>
+public static class TemplateSubstitution
+{
+    private static readonly Regex VariablePattern = new(@"\{\{(\w+)\}\}", RegexOptions.Compiled);
+
+    /// <summary>
+    /// Substitute {{variable}} placeholders in template text.
+    /// Returns (result, missingVars). Missing variables are left as-is.
+    /// </summary>
+    public static (string result, List<string> missingVars) Substitute(
+        string template, Dictionary<string, string>? variables)
+    {
+        var missingVars = new List<string>();
+
+        if (string.IsNullOrEmpty(template))
+            return (template, missingVars);
+
+        var result = VariablePattern.Replace(template, match =>
+        {
+            var varName = match.Groups[1].Value;
+            if (variables != null && variables.TryGetValue(varName, out var value))
+                return value;
+
+            missingVars.Add(varName);
+            return match.Value;
+        });
+
+        return (result, missingVars);
+    }
+
+    /// <summary>
+    /// Extract all variable names from a template string.
+    /// </summary>
+    public static List<string> ExtractVariables(string template)
+    {
+        if (string.IsNullOrEmpty(template))
+            return new List<string>();
+
+        return VariablePattern.Matches(template)
+            .Select(m => m.Groups[1].Value)
+            .Distinct()
+            .ToList();
+    }
+}
