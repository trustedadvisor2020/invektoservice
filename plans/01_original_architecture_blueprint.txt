
INVEKTO MICROSERVICE SYSTEM ARCHITECTURE
=======================================

PURPOSE
-------
This document defines the complete, production-grade microservice system architecture for Invekto.
It is designed to be simple, manageable, observable, scalable (10x), bottleneck-resistant, and
safe to operate under real production pressure.

This is NOT an application plan.
This is a SYSTEM blueprint.

--------------------------------------------------
1. HIGH-LEVEL FLOW
--------------------------------------------------

UI
 -> Invekto Backend (SOURCE OF TRUTH)
   -> Nginx (Windows, reverse proxy)
     -> Microservice (Windows Service, stateless)
       -> Redis / RabbitMQ (async)
         -> Result back to Backend
           -> UI render

Rules:
- UI NEVER talks to microservices directly
- Backend owns all business truth
- Microservices compute, transform, analyze only

--------------------------------------------------
2. CORE PRINCIPLES
--------------------------------------------------

- Backend is the ONLY source of truth
- Microservices are stateless
- Default ASYNC, sync only by exception
- Redis for hot/ephemeral state
- SQL Server for durable business data only
- Observability from DAY ONE
- Fail fast, degrade safely
- No silent retries in sync paths
- Everything traceable

--------------------------------------------------
3. SYNCHRONOUS RULES
--------------------------------------------------

- P95 latency target: <= 800ms
- Backend -> Microservice timeout: 600ms
- Retry: 0 (STRICT)
- Max downstream sync hop: 1
- Downstream timeout: 150–250ms
- If dependency slow/fails: return PARTIAL

Sync allowed only for:
- Pure computation
- Deterministic transform
- Single fast lookup

FORBIDDEN:
- Service call chains (A->B->C)
- Third-party APIs (Zoho etc.)
- SQL writes
- Long jobs

--------------------------------------------------
4. ASYNC JOB MODEL
--------------------------------------------------

- Heavy jobs return:
  status = accepted
  jobId = ULID

- Processing via RabbitMQ
- Delivery: at-least-once
- Consumer MUST be idempotent

Retry:
- 2s
- 10s
- 30s
- 2m
- 10m
-> DLQ

DLQ:
- Manual inspection
- Manual reprocess
- Full trace visibility

--------------------------------------------------
5. REDIS + SQL SERVER (NO BOTTLENECK)
--------------------------------------------------

REDIS (HOT PATH ONLY):
- Idempotency keys (TTL)
- Request deduplication
- Rate limit counters
- Short job state
- Distributed locks (minimal)
- Tenant/chat scoped keys

SQL SERVER (COLD PATH):
- Business data
- Reporting
- Audit logs
- Outbox table

RULE:
SQL is NEVER required for microservice response generation.

--------------------------------------------------
6. OUTBOX PATTERN
--------------------------------------------------

- Backend SQL transaction:
  - Write business data
  - Write outbox event

- Separate dispatcher publishes to RabbitMQ
- Guarantees no data loss

--------------------------------------------------
7. IDENTITY & CONTEXT
--------------------------------------------------

Every request/event includes:
- tenantId
- chatId
- requestId
- traceId
- idempotencyKey (if applicable)

Rules:
- tenantId + chatId are PLAIN internally
- Logs/traces export masked or hashed
- Payload content NEVER logged

--------------------------------------------------
8. AUTHENTICATION (INTERNAL)
--------------------------------------------------

- Backend -> Microservice:
  - HMAC signed internal token
  - Short TTL
  - Replay protection

- Microservices do NOT manage users

--------------------------------------------------
9. REVERSE PROXY (NGINX - WINDOWS)
--------------------------------------------------

- Single entry point for microservices
- Static upstreams (IP:PORT)
- Health checks: /health /ready
- Connection limits
- Rate limits
- No retries
- Config reload without downtime

--------------------------------------------------
10. LOAD DISTRIBUTION
--------------------------------------------------

- Sync traffic: Nginx upstream
- Async traffic: RabbitMQ consumer model
- Backend NEVER load-balances

--------------------------------------------------
11. BACKPRESSURE
--------------------------------------------------

- Nginx: connection + rate limit
- Microservice: in-flight request cap
- RabbitMQ: prefetch=50
- Consumer concurrency hard cap

Behavior:
- No drops
- Fast fail or partial response

--------------------------------------------------
12. CIRCUIT BREAKER
--------------------------------------------------

- Per downstream dependency
- Trip if:
  - Error rate > 50% in 30s
  - Timeout spike

- Open:
  - Fast fail
  - Partial or async fallback

- Half-open retry after 30–60s

--------------------------------------------------
13. OBSERVABILITY (MANDATORY)
--------------------------------------------------

Enabled from FIRST RELEASE.

Stack:
- OpenTelemetry SDK
- Prometheus
- Jaeger
- Loki
- Grafana

Every flow includes:
- traceId
- stage
- waitReason

Stages:
- received
- queued
- waiting
- processing
- downstream
- retry
- done
- failed

--------------------------------------------------
14. TROUBLESHOOTING (KISS)
--------------------------------------------------

You MUST be able to answer:
- Where is it stuck?
- What is waiting?
- What is overloaded?
- Why did it fail?

Required:
- Queue depth + oldest message age
- Latency breakdown
- Redis ops + latency
- CPU/RAM per service
- Last 100 failures
- Last 100 slow requests
- Circuit breaker activations

--------------------------------------------------
15. ADMIN UI (OPS PANEL)
--------------------------------------------------

- Exists from FIRST VERSION
- Node.js + PM2
- Reverse proxied by Nginx
- Public access
- Google Login (email allowlist)

Permissions:
- view
- full

Capabilities:
- DLQ viewer + reprocess
- Queue stats
- Flag / kill-switch management
- Health overview
- Trace jump
- Troubleshoot dashboard

--------------------------------------------------
16. AUDIT TRAIL
--------------------------------------------------

For ALL admin actions:
- email
- action
- target
- timestamp
- before/after snapshot

Append-only.
Never editable.

--------------------------------------------------
17. KILL-SWITCH / FEATURE FLAGS
--------------------------------------------------

- File-based flags.json
- Activated by restart
- Service-level disable supported

Disable behavior:
- Sync: partial / accepted
- Async: no event produced

Flags visible in:
- Logs
- Dashboard
- Audit

--------------------------------------------------
18. VERSIONING & CONTRACTS
--------------------------------------------------

HTTP:
- /v1 /v2 URL versioning
- OpenAPI mandatory

Events:
- JSON Schema
- schemaVersion field
- Backward compatible only

Shared Schema Repo:
- Headers
- Error codes
- DTOs
- Event schemas

--------------------------------------------------
19. ERROR STANDARD
--------------------------------------------------

Format:
SVC-CAT-NNN

Response:
- errorCode
- message
- details (ops only)

--------------------------------------------------
20. RATE LIMITING
--------------------------------------------------

- Tenant-based
- Implemented at Nginx + Redis

Behavior:
- Soft limit -> partial + warning
- Hard limit -> 429

--------------------------------------------------
21. DEPLOYMENT (WINDOWS ONLY)
--------------------------------------------------

Microservices:
- Windows Service
- Multi-instance via ports

Deploy:
- Zip replace
- Service restart
- Rollback via zip

Rollout:
- Nginx upstream add/remove
- Gradual traffic shift

--------------------------------------------------
22. NETWORK SECURITY
--------------------------------------------------

- No VLAN
- IP allowlist via firewall
- Minimal open ports
- Redis/RabbitMQ private

--------------------------------------------------
23. TEST DISCIPLINE
--------------------------------------------------

Required:
- Contract tests (OpenAPI / JSON Schema)
- Smoke tests post-deploy

Not required (yet):
- Load tests

--------------------------------------------------
24. FIRST MICROSERVICE SCOPE
--------------------------------------------------

- Chat-based analysis
- Extract / normalize / score
- Deterministic JSON output
- Backend renders UI

--------------------------------------------------
END OF DOCUMENT
--------------------------------------------------
